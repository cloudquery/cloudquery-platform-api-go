// Package cloudquery_platform_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package cloudquery_platform_api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/hashicorp/go-retryablehttp"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for AlertSeverity.
const (
	AlertSeverityCritical AlertSeverity = "critical"
	AlertSeverityHigh     AlertSeverity = "high"
	AlertSeverityLow      AlertSeverity = "low"
	AlertSeverityMedium   AlertSeverity = "medium"
)

// Defines values for AlertState.
const (
	AlertStateInactive  AlertState = "inactive"
	AlertStatePending   AlertState = "pending"
	AlertStateTriggered AlertState = "triggered"
	AlertStateUnknown   AlertState = "unknown"
)

// Defines values for ConversationCreateMode.
const (
	ConversationCreateModeAsk ConversationCreateMode = "ask"
	ConversationCreateModeSql ConversationCreateMode = "sql"
)

// Defines values for ConversationMessageMessageType.
const (
	ConversationMessageMessageTypeError      ConversationMessageMessageType = "error"
	ConversationMessageMessageTypeMessage    ConversationMessageMessageType = "message"
	ConversationMessageMessageTypeToolResult ConversationMessageMessageType = "tool_result"
	ConversationMessageMessageTypeToolUse    ConversationMessageMessageType = "tool_use"
)

// Defines values for ConversationMessageMode.
const (
	ConversationMessageModeAsk ConversationMessageMode = "ask"
	ConversationMessageModeSql ConversationMessageMode = "sql"
)

// Defines values for ConversationMessageRole.
const (
	ConversationMessageRoleAssistant ConversationMessageRole = "assistant"
	ConversationMessageRoleSystem    ConversationMessageRole = "system"
	ConversationMessageRoleUser      ConversationMessageRole = "user"
)

// Defines values for ConversationSendMessageMode.
const (
	ConversationSendMessageModeAsk ConversationSendMessageMode = "ask"
	ConversationSendMessageModeSql ConversationSendMessageMode = "sql"
)

// Defines values for CustomColumnSortBy.
const (
	CustomColumnSortByColumnName  CustomColumnSortBy = "column_name"
	CustomColumnSortByCreatedAt   CustomColumnSortBy = "created_at"
	CustomColumnSortByCreatedBy   CustomColumnSortBy = "created_by"
	CustomColumnSortByDescription CustomColumnSortBy = "description"
	CustomColumnSortById          CustomColumnSortBy = "id"
	CustomColumnSortByLabel       CustomColumnSortBy = "label"
	CustomColumnSortByUpdatedAt   CustomColumnSortBy = "updated_at"
	CustomColumnSortByValueExpr   CustomColumnSortBy = "value_expr"
)

// Defines values for CustomColumnSortDirection.
const (
	CustomColumnSortDirectionAsc  CustomColumnSortDirection = "asc"
	CustomColumnSortDirectionDesc CustomColumnSortDirection = "desc"
)

// Defines values for NotificationDestinationType.
const (
	NotificationDestinationTypeSlack   NotificationDestinationType = "slack"
	NotificationDestinationTypeWebhook NotificationDestinationType = "webhook"
)

// Defines values for NotificationDestinationCreateType.
const (
	NotificationDestinationCreateTypeSlack   NotificationDestinationCreateType = "slack"
	NotificationDestinationCreateTypeWebhook NotificationDestinationCreateType = "webhook"
)

// Defines values for NotificationDestinationDataType.
const (
	NotificationDestinationDataTypeSlack   NotificationDestinationDataType = "slack"
	NotificationDestinationDataTypeWebhook NotificationDestinationDataType = "webhook"
)

// Defines values for NotificationDestinationListItemType.
const (
	NotificationDestinationListItemTypeSlack   NotificationDestinationListItemType = "slack"
	NotificationDestinationListItemTypeWebhook NotificationDestinationListItemType = "webhook"
)

// Defines values for OnboardingAWSAccountsType.
const (
	OnboardingAWSAccountsTypeAccount OnboardingAWSAccountsType = "account"
	OnboardingAWSAccountsTypeOU      OnboardingAWSAccountsType = "OU"
	OnboardingAWSAccountsTypeRoot    OnboardingAWSAccountsType = "root"
)

// Defines values for PluginCategory.
const (
	PluginCategoryCloudFinops          PluginCategory = "cloud-finops"
	PluginCategoryCloudInfrastructure  PluginCategory = "cloud-infrastructure"
	PluginCategoryCustomerSupport      PluginCategory = "customer-support"
	PluginCategoryDataWarehouses       PluginCategory = "data-warehouses"
	PluginCategoryDatabases            PluginCategory = "databases"
	PluginCategoryEngineeringAnalytics PluginCategory = "engineering-analytics"
	PluginCategoryFinance              PluginCategory = "finance"
	PluginCategoryFleetManagement      PluginCategory = "fleet-management"
	PluginCategoryHumanResources       PluginCategory = "human-resources"
	PluginCategoryMarketingAnalytics   PluginCategory = "marketing-analytics"
	PluginCategoryOther                PluginCategory = "other"
	PluginCategoryProductAnalytics     PluginCategory = "product-analytics"
	PluginCategoryProjectManagement    PluginCategory = "project-management"
	PluginCategorySalesMarketing       PluginCategory = "sales-marketing"
	PluginCategorySecurity             PluginCategory = "security"
	PluginCategoryShipmentTracking     PluginCategory = "shipment-tracking"
)

// Defines values for PluginKind.
const (
	PluginKindDestination PluginKind = "destination"
	PluginKindSource      PluginKind = "source"
	PluginKindTransformer PluginKind = "transformer"
)

// Defines values for PluginPackageType.
const (
	PluginPackageTypeDocker PluginPackageType = "docker"
	PluginPackageTypeNative PluginPackageType = "native"
)

// Defines values for PluginPriceCategory.
const (
	PluginPriceCategoryApi      PluginPriceCategory = "api"
	PluginPriceCategoryDatabase PluginPriceCategory = "database"
	PluginPriceCategoryFree     PluginPriceCategory = "free"
)

// Defines values for PluginReleaseStage.
const (
	PluginReleaseStageComingSoon PluginReleaseStage = "coming-soon"
	PluginReleaseStageDeprecated PluginReleaseStage = "deprecated"
	PluginReleaseStageGa         PluginReleaseStage = "ga"
	PluginReleaseStagePreview    PluginReleaseStage = "preview"
)

// Defines values for PluginTier.
const (
	PluginTierFree     PluginTier = "free"
	PluginTierOpenCore PluginTier = "open-core"
	PluginTierPaid     PluginTier = "paid"
)

// Defines values for PolicyDomain.
const (
	PolicyDomainCompliance PolicyDomain = "compliance"
	PolicyDomainFinops     PolicyDomain = "finops"
	PolicyDomainGovernance PolicyDomain = "governance"
	PolicyDomainOperations PolicyDomain = "operations"
	PolicyDomainSecurity   PolicyDomain = "security"
)

// Defines values for PolicySeverity.
const (
	PolicySeverityCritical PolicySeverity = "critical"
	PolicySeverityHigh     PolicySeverity = "high"
	PolicySeverityLow      PolicySeverity = "low"
	PolicySeverityMedium   PolicySeverity = "medium"
)

// Defines values for PolicyStatus.
const (
	PolicyStatusActive PolicyStatus = "active"
	PolicyStatusPaused PolicyStatus = "paused"
)

// Defines values for RBACPermissionSortBy.
const (
	RBACPermissionSortByCreatedAt   RBACPermissionSortBy = "created_at"
	RBACPermissionSortByCreatedBy   RBACPermissionSortBy = "created_by"
	RBACPermissionSortByDescription RBACPermissionSortBy = "description"
	RBACPermissionSortById          RBACPermissionSortBy = "id"
	RBACPermissionSortByName        RBACPermissionSortBy = "name"
	RBACPermissionSortByUpdatedAt   RBACPermissionSortBy = "updated_at"
)

// Defines values for RBACPermissionSortDirection.
const (
	RBACPermissionSortDirectionAsc  RBACPermissionSortDirection = "asc"
	RBACPermissionSortDirectionDesc RBACPermissionSortDirection = "desc"
)

// Defines values for RBACRoleSortBy.
const (
	RBACRoleSortByCreatedAt   RBACRoleSortBy = "created_at"
	RBACRoleSortByCreatedBy   RBACRoleSortBy = "created_by"
	RBACRoleSortByDescription RBACRoleSortBy = "description"
	RBACRoleSortById          RBACRoleSortBy = "id"
	RBACRoleSortByName        RBACRoleSortBy = "name"
	RBACRoleSortByUpdatedAt   RBACRoleSortBy = "updated_at"
)

// Defines values for RBACRoleSortDirection.
const (
	RBACRoleSortDirectionAsc  RBACRoleSortDirection = "asc"
	RBACRoleSortDirectionDesc RBACRoleSortDirection = "desc"
)

// Defines values for ReportSortBy.
const (
	ReportSortByCreatedAt   ReportSortBy = "created_at"
	ReportSortByDescription ReportSortBy = "description"
	ReportSortById          ReportSortBy = "id"
	ReportSortByPrivate     ReportSortBy = "private"
	ReportSortByTitle       ReportSortBy = "title"
	ReportSortByUpdatedAt   ReportSortBy = "updated_at"
)

// Defines values for ReportSortDirection.
const (
	ReportSortDirectionAsc  ReportSortDirection = "asc"
	ReportSortDirectionDesc ReportSortDirection = "desc"
)

// Defines values for ReportTemplateSortBy.
const (
	ReportTemplateSortByCreatedAt   ReportTemplateSortBy = "created_at"
	ReportTemplateSortByDescription ReportTemplateSortBy = "description"
	ReportTemplateSortById          ReportTemplateSortBy = "id"
	ReportTemplateSortByTitle       ReportTemplateSortBy = "title"
	ReportTemplateSortByUpdatedAt   ReportTemplateSortBy = "updated_at"
	ReportTemplateSortByVisible     ReportTemplateSortBy = "visible"
)

// Defines values for ReportTemplateSortDirection.
const (
	ReportTemplateSortDirectionAsc  ReportTemplateSortDirection = "asc"
	ReportTemplateSortDirectionDesc ReportTemplateSortDirection = "desc"
)

// Defines values for RoleType.
const (
	RoleTypeAdminRead    RoleType = "admin:read"
	RoleTypeAdminWrite   RoleType = "admin:write"
	RoleTypeCI           RoleType = "ci"
	RoleTypeCustom       RoleType = "custom"
	RoleTypeGeneralRead  RoleType = "general:read"
	RoleTypeGeneralWrite RoleType = "general:write"
	RoleTypeSchemaOnly   RoleType = "schema-only"
)

// Defines values for SyncDestinationMigrateMode.
const (
	SyncDestinationMigrateModeForced SyncDestinationMigrateMode = "forced"
	SyncDestinationMigrateModeSafe   SyncDestinationMigrateMode = "safe"
)

// Defines values for SyncDestinationMigrateModeUpdate.
const (
	SyncDestinationMigrateModeUpdateForced SyncDestinationMigrateModeUpdate = "forced"
	SyncDestinationMigrateModeUpdateSafe   SyncDestinationMigrateModeUpdate = "safe"
)

// Defines values for SyncDestinationWriteMode.
const (
	SyncDestinationWriteModeAppend               SyncDestinationWriteMode = "append"
	SyncDestinationWriteModeOverwrite            SyncDestinationWriteMode = "overwrite"
	SyncDestinationWriteModeOverwriteDeleteStale SyncDestinationWriteMode = "overwrite-delete-stale"
)

// Defines values for SyncDestinationWriteModeUpdate.
const (
	SyncDestinationWriteModeUpdateAppend               SyncDestinationWriteModeUpdate = "append"
	SyncDestinationWriteModeUpdateOverwrite            SyncDestinationWriteModeUpdate = "overwrite"
	SyncDestinationWriteModeUpdateOverwriteDeleteStale SyncDestinationWriteModeUpdate = "overwrite-delete-stale"
)

// Defines values for SyncGenericSortBy.
const (
	SyncGenericSortByCreatedAt   SyncGenericSortBy = "created_at"
	SyncGenericSortByDisplayName SyncGenericSortBy = "display_name"
	SyncGenericSortByDraft       SyncGenericSortBy = "draft"
	SyncGenericSortByName        SyncGenericSortBy = "name"
	SyncGenericSortByPath        SyncGenericSortBy = "path"
	SyncGenericSortByUpdatedAt   SyncGenericSortBy = "updated_at"
	SyncGenericSortByVersion     SyncGenericSortBy = "version"
)

// Defines values for SyncLastUpdateSource.
const (
	SyncLastUpdateSourceUi   SyncLastUpdateSource = "ui"
	SyncLastUpdateSourceYaml SyncLastUpdateSource = "yaml"
)

// Defines values for SyncRunStatus.
const (
	SyncRunStatusCancelled SyncRunStatus = "cancelled"
	SyncRunStatusCompleted SyncRunStatus = "completed"
	SyncRunStatusCreated   SyncRunStatus = "created"
	SyncRunStatusFailed    SyncRunStatus = "failed"
	SyncRunStatusPending   SyncRunStatus = "pending"
	SyncRunStatusStarted   SyncRunStatus = "started"
)

// Defines values for SyncRunStatusReason.
const (
	SyncRunStatusReasonError           SyncRunStatusReason = "error"
	SyncRunStatusReasonIngestionFailed SyncRunStatusReason = "ingestion_failed"
	SyncRunStatusReasonOomKilled       SyncRunStatusReason = "oom_killed"
	SyncRunStatusReasonPartialSuccess  SyncRunStatusReason = "partial_success"
)

// Defines values for SyncRunTableSortBy.
const (
	SyncRunTableSortByCompletedAt    SyncRunTableSortBy = "completed_at"
	SyncRunTableSortByErrors         SyncRunTableSortBy = "errors"
	SyncRunTableSortByName           SyncRunTableSortBy = "name"
	SyncRunTableSortByResources      SyncRunTableSortBy = "resources"
	SyncRunTableSortByRuntimeSeconds SyncRunTableSortBy = "runtime_seconds"
	SyncRunTableSortByStartedAt      SyncRunTableSortBy = "started_at"
)

// Defines values for SyncRunWorkerPhase.
const (
	SyncRunWorkerPhaseFailed    SyncRunWorkerPhase = "Failed"
	SyncRunWorkerPhasePending   SyncRunWorkerPhase = "Pending"
	SyncRunWorkerPhaseRunning   SyncRunWorkerPhase = "Running"
	SyncRunWorkerPhaseSucceeded SyncRunWorkerPhase = "Succeeded"
	SyncRunWorkerPhaseUnknown   SyncRunWorkerPhase = "Unknown"
)

// Defines values for SyncSortBy.
const (
	SyncSortByCpu                SyncSortBy = "cpu"
	SyncSortByCreatedAt          SyncSortBy = "created_at"
	SyncSortByCreatedBy          SyncSortBy = "created_by"
	SyncSortByDestinations       SyncSortBy = "destinations"
	SyncSortByDisabled           SyncSortBy = "disabled"
	SyncSortByDisplayName        SyncSortBy = "display_name"
	SyncSortByLastRunCompletedAt SyncSortBy = "last_run_completed_at"
	SyncSortByLastRunCreatedAt   SyncSortBy = "last_run_created_at"
	SyncSortByLastRunErrors      SyncSortBy = "last_run_errors"
	SyncSortByLastRunMigration   SyncSortBy = "last_run_migration"
	SyncSortByLastRunStatus      SyncSortBy = "last_run_status"
	SyncSortByLastRunTotalRows   SyncSortBy = "last_run_total_rows"
	SyncSortByLastRunUpdatedAt   SyncSortBy = "last_run_updated_at"
	SyncSortByLastRunWarnings    SyncSortBy = "last_run_warnings"
	SyncSortByMemory             SyncSortBy = "memory"
	SyncSortByName               SyncSortBy = "name"
	SyncSortBySchedule           SyncSortBy = "schedule"
	SyncSortBySource             SyncSortBy = "source"
	SyncSortByUpdatedAt          SyncSortBy = "updated_at"
)

// Defines values for SyncSortDirection.
const (
	SyncSortDirectionAsc  SyncSortDirection = "asc"
	SyncSortDirectionDesc SyncSortDirection = "desc"
)

// Defines values for SyncTestConnectionStatus.
const (
	SyncTestConnectionStatusCompleted SyncTestConnectionStatus = "completed"
	SyncTestConnectionStatusCreated   SyncTestConnectionStatus = "created"
	SyncTestConnectionStatusFailed    SyncTestConnectionStatus = "failed"
	SyncTestConnectionStatusStarted   SyncTestConnectionStatus = "started"
)

// Defines values for TableDataActionAction.
const (
	TableDataActionActionDelete TableDataActionAction = "delete"
)

// Defines values for TableSchemaColumnKind.
const (
	TableSchemaColumnKindAny      TableSchemaColumnKind = "any"
	TableSchemaColumnKindArray    TableSchemaColumnKind = "array"
	TableSchemaColumnKindBool     TableSchemaColumnKind = "bool"
	TableSchemaColumnKindDate     TableSchemaColumnKind = "date"
	TableSchemaColumnKindDatetime TableSchemaColumnKind = "datetime"
	TableSchemaColumnKindEnum     TableSchemaColumnKind = "enum"
	TableSchemaColumnKindMap      TableSchemaColumnKind = "map"
	TableSchemaColumnKindNumber   TableSchemaColumnKind = "number"
	TableSchemaColumnKindString   TableSchemaColumnKind = "string"
	TableSchemaColumnKindTuple    TableSchemaColumnKind = "tuple"
	TableSchemaColumnKindUnknown  TableSchemaColumnKind = "unknown"
	TableSchemaColumnKindUuid     TableSchemaColumnKind = "uuid"
)

// Defines values for TableSortDirection.
const (
	TableSortDirectionAsc  TableSortDirection = "asc"
	TableSortDirectionDesc TableSortDirection = "desc"
)

// Defines values for UsageSummaryMetadataAggregationPeriod.
const (
	UsageSummaryMetadataAggregationPeriodDay   UsageSummaryMetadataAggregationPeriod = "day"
	UsageSummaryMetadataAggregationPeriodMonth UsageSummaryMetadataAggregationPeriod = "month"
)

// Defines values for UsageSummaryMetadataMetrics.
const (
	UsageSummaryMetadataMetricsCloudEgressBytes     UsageSummaryMetadataMetrics = "cloud_egress_bytes"
	UsageSummaryMetadataMetricsCloudVcpuSeconds     UsageSummaryMetadataMetrics = "cloud_vcpu_seconds"
	UsageSummaryMetadataMetricsCloudVramByteSeconds UsageSummaryMetadataMetrics = "cloud_vram_byte_seconds"
	UsageSummaryMetadataMetricsPaidRows             UsageSummaryMetadataMetrics = "paid_rows"
)

// Defines values for UserProvider.
const (
	UserProviderLocal UserProvider = "local"
	UserProviderSaml  UserProvider = "saml"
)

// Defines values for PluginSortBy.
const (
	PluginSortByCreatedAt PluginSortBy = "created_at"
	PluginSortByDownloads PluginSortBy = "downloads"
	PluginSortByName      PluginSortBy = "name"
	PluginSortByUpdatedAt PluginSortBy = "updated_at"
)

// Defines values for TableFilterMode.
const (
	TableFilterModeColumn TableFilterMode = "column"
	TableFilterModeSearch TableFilterMode = "search"
	TableFilterModeSmart  TableFilterMode = "smart"
)

// Defines values for VersionSortBy.
const (
	VersionSortByCreatedAt VersionSortBy = "created_at"
)

// Defines values for ListPluginsParamsSortBy.
const (
	ListPluginsParamsSortByCreatedAt ListPluginsParamsSortBy = "created_at"
	ListPluginsParamsSortByDownloads ListPluginsParamsSortBy = "downloads"
	ListPluginsParamsSortByName      ListPluginsParamsSortBy = "name"
	ListPluginsParamsSortByUpdatedAt ListPluginsParamsSortBy = "updated_at"
)

// Defines values for ListPluginVersionsParamsSortBy.
const (
	ListPluginVersionsParamsSortByCreatedAt ListPluginVersionsParamsSortBy = "created_at"
)

// Defines values for ListPoliciesParamsSortBy.
const (
	ListPoliciesParamsSortByCreatedAt      ListPoliciesParamsSortBy = "created_at"
	ListPoliciesParamsSortByDomain         ListPoliciesParamsSortBy = "domain"
	ListPoliciesParamsSortByLastRunAt      ListPoliciesParamsSortBy = "last_run_at"
	ListPoliciesParamsSortByName           ListPoliciesParamsSortBy = "name"
	ListPoliciesParamsSortBySeverity       ListPoliciesParamsSortBy = "severity"
	ListPoliciesParamsSortByViolationCount ListPoliciesParamsSortBy = "violation_count"
)

// Defines values for ListPoliciesParamsSortDir.
const (
	ListPoliciesParamsSortDirAsc  ListPoliciesParamsSortDir = "asc"
	ListPoliciesParamsSortDirDesc ListPoliciesParamsSortDir = "desc"
)

// Defines values for ListPoliciesInGroupParamsSortBy.
const (
	ListPoliciesInGroupParamsSortByName        ListPoliciesInGroupParamsSortBy = "name"
	ListPoliciesInGroupParamsSortByPolicyCount ListPoliciesInGroupParamsSortBy = "policy_count"
)

// Defines values for ListPoliciesInGroupParamsSortDir.
const (
	ListPoliciesInGroupParamsSortDirAsc  ListPoliciesInGroupParamsSortDir = "asc"
	ListPoliciesInGroupParamsSortDirDesc ListPoliciesInGroupParamsSortDir = "desc"
)

// Defines values for ExecuteAdHocQueryParamsFilterMode.
const (
	ExecuteAdHocQueryParamsFilterModeColumn ExecuteAdHocQueryParamsFilterMode = "column"
	ExecuteAdHocQueryParamsFilterModeSearch ExecuteAdHocQueryParamsFilterMode = "search"
	ExecuteAdHocQueryParamsFilterModeSmart  ExecuteAdHocQueryParamsFilterMode = "smart"
)

// Defines values for ExecuteSavedQueryParamsFilterMode.
const (
	ExecuteSavedQueryParamsFilterModeColumn ExecuteSavedQueryParamsFilterMode = "column"
	ExecuteSavedQueryParamsFilterModeSearch ExecuteSavedQueryParamsFilterMode = "search"
	ExecuteSavedQueryParamsFilterModeSmart  ExecuteSavedQueryParamsFilterMode = "smart"
)

// Defines values for ListReportsParamsVisibility.
const (
	ListReportsParamsVisibilityPrivate ListReportsParamsVisibility = "private"
	ListReportsParamsVisibilityPublic  ListReportsParamsVisibility = "public"
)

// Defines values for ListSyncUpgradesParamsSortBy.
const (
	ListSyncUpgradesParamsSortByCreatedAt   ListSyncUpgradesParamsSortBy = "created_at"
	ListSyncUpgradesParamsSortByKind        ListSyncUpgradesParamsSortBy = "kind"
	ListSyncUpgradesParamsSortByNewVersion  ListSyncUpgradesParamsSortBy = "new_version"
	ListSyncUpgradesParamsSortByPath        ListSyncUpgradesParamsSortBy = "path"
	ListSyncUpgradesParamsSortByPrevVersion ListSyncUpgradesParamsSortBy = "prev_version"
)

// Defines values for TableListColumnsParamsFilterMode.
const (
	TableListColumnsParamsFilterModeColumn TableListColumnsParamsFilterMode = "column"
	TableListColumnsParamsFilterModeSearch TableListColumnsParamsFilterMode = "search"
	TableListColumnsParamsFilterModeSmart  TableListColumnsParamsFilterMode = "smart"
)

// Defines values for TableColumnListValuesParamsFilterMode.
const (
	TableColumnListValuesParamsFilterModeColumn TableColumnListValuesParamsFilterMode = "column"
	TableColumnListValuesParamsFilterModeSearch TableColumnListValuesParamsFilterMode = "search"
	TableColumnListValuesParamsFilterModeSmart  TableColumnListValuesParamsFilterMode = "smart"
)

// Defines values for TableListRowsParamsFilterMode.
const (
	TableListRowsParamsFilterModeColumn TableListRowsParamsFilterMode = "column"
	TableListRowsParamsFilterModeSearch TableListRowsParamsFilterMode = "search"
	TableListRowsParamsFilterModeSmart  TableListRowsParamsFilterMode = "smart"
)

// Defines values for TableRowByIdParamsFilterMode.
const (
	TableRowByIdParamsFilterModeColumn TableRowByIdParamsFilterMode = "column"
	TableRowByIdParamsFilterModeSearch TableRowByIdParamsFilterMode = "search"
	TableRowByIdParamsFilterModeSmart  TableRowByIdParamsFilterMode = "smart"
)

// Defines values for GetTeamUsageSummaryParamsMetrics.
const (
	GetTeamUsageSummaryParamsMetricsCloudVcpuSeconds     GetTeamUsageSummaryParamsMetrics = "cloud_vcpu_seconds"
	GetTeamUsageSummaryParamsMetricsCloudVramByteSeconds GetTeamUsageSummaryParamsMetrics = "cloud_vram_byte_seconds"
	GetTeamUsageSummaryParamsMetricsNetworkEgressBytes   GetTeamUsageSummaryParamsMetrics = "network_egress_bytes"
	GetTeamUsageSummaryParamsMetricsPaidRows             GetTeamUsageSummaryParamsMetrics = "paid_rows"
)

// Defines values for GetTeamUsageSummaryParamsAggregationPeriod.
const (
	GetTeamUsageSummaryParamsAggregationPeriodDay   GetTeamUsageSummaryParamsAggregationPeriod = "day"
	GetTeamUsageSummaryParamsAggregationPeriodMonth GetTeamUsageSummaryParamsAggregationPeriod = "month"
)

// Defines values for GetGroupedTeamUsageSummaryParamsMetrics.
const (
	GetGroupedTeamUsageSummaryParamsMetricsCloudVcpuSeconds     GetGroupedTeamUsageSummaryParamsMetrics = "cloud_vcpu_seconds"
	GetGroupedTeamUsageSummaryParamsMetricsCloudVramByteSeconds GetGroupedTeamUsageSummaryParamsMetrics = "cloud_vram_byte_seconds"
	GetGroupedTeamUsageSummaryParamsMetricsNetworkEgressBytes   GetGroupedTeamUsageSummaryParamsMetrics = "network_egress_bytes"
	GetGroupedTeamUsageSummaryParamsMetricsPaidRows             GetGroupedTeamUsageSummaryParamsMetrics = "paid_rows"
)

// Defines values for GetGroupedTeamUsageSummaryParamsAggregationPeriod.
const (
	GetGroupedTeamUsageSummaryParamsAggregationPeriodDay   GetGroupedTeamUsageSummaryParamsAggregationPeriod = "day"
	GetGroupedTeamUsageSummaryParamsAggregationPeriodMonth GetGroupedTeamUsageSummaryParamsAggregationPeriod = "month"
)

// Defines values for GetGroupedTeamUsageSummaryParamsGroupBy.
const (
	GetGroupedTeamUsageSummaryParamsGroupByPlugin        GetGroupedTeamUsageSummaryParamsGroupBy = "plugin"
	GetGroupedTeamUsageSummaryParamsGroupByPriceCategory GetGroupedTeamUsageSummaryParamsGroupBy = "price_category"
	GetGroupedTeamUsageSummaryParamsGroupBySyncId        GetGroupedTeamUsageSummaryParamsGroupBy = "sync_id"
)

// APIKey API Key to interact with CloudQuery Platform
type APIKey struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatedBy email of the user that created the API key
	CreatedBy *string `json:"created_by,omitempty"`

	// Expired Whether the API key has expired or not
	Expired bool `json:"expired"`

	// ExpiresAt Timestamp at which API key will stop working
	ExpiresAt time.Time `json:"expires_at"`

	// APIKeyID ID of the API key
	APIKeyID APIKeyID `json:"id"`

	// Key API key. Will be shown only in the response when creating the key.
	Key *string `json:"key,omitempty"`

	// LastAccessAt Timestamp at which API key was last used - accurate to the day only.
	LastAccessAt *time.Time `json:"last_access_at,omitempty"`

	// Name Name of the API key
	Name  APIKeyName `json:"name"`
	Roles []Role     `json:"roles"`
}

// APIKeyID ID of the API key
type APIKeyID = openapi_types.UUID

// APIKeyName Name of the API key
type APIKeyName = string

// Alert An alert instance that can be triggered by a query
type Alert struct {
	// CreatedAt Timestamp when the alert was created
	CreatedAt time.Time `json:"created_at"`

	// Enabled Indicates if the alert is enabled
	Enabled bool `json:"enabled"`

	// ID Unique identifier for the alert
	ID openapi_types.UUID `json:"id"`

	// LastEvaluatedAt Timestamp when the alert was last evaluated
	LastEvaluatedAt *time.Time `json:"last_evaluated_at,omitempty"`

	// Message Alert message content
	Message string `json:"message"`

	// NumDestinations Number of notification destinations this alert is configured to send to
	NumDestinations int `json:"num_destinations"`

	// QueryID Reference to the associated query
	QueryID  openapi_types.UUID `json:"query_id"`
	Severity AlertSeverity      `json:"severity"`
	State    AlertState         `json:"state"`

	// TotalViolations Number of violations that triggered the alert
	TotalViolations int64 `json:"total_violations"`

	// TriggeredAt Timestamp when the alert was triggered
	TriggeredAt *time.Time `json:"triggered_at,omitempty"`

	// UpdatedAt Timestamp when the alert was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// AlertCreate Create an alert
type AlertCreate struct {
	// Enabled Indicates if the alert is enabled
	Enabled bool   `json:"enabled"`
	Message string `json:"message"`

	// NotificationDestinations List of notification destinations to send alerts to
	NotificationDestinations []NotificationDestinationID `json:"notification_destinations,omitempty"`
	Severity                 AlertSeverity               `json:"severity"`
}

// AlertDetail An alert instance that can be triggered by a query including notification destinations for the alert
type AlertDetail struct {
	// CreatedAt Timestamp when the alert was created
	CreatedAt time.Time `json:"created_at"`

	// Enabled Indicates if the alert is enabled
	Enabled bool `json:"enabled"`

	// ID Unique identifier for the alert
	ID openapi_types.UUID `json:"id"`

	// LastEvaluatedAt Timestamp when the alert was last evaluated
	LastEvaluatedAt *time.Time `json:"last_evaluated_at,omitempty"`

	// Message Alert message content
	Message string `json:"message"`

	// NotificationDestinations List of notification destinations this alert is configured to send to
	NotificationDestinations []NotificationDestinationListItem `json:"notification_destinations"`

	// QueryID Reference to the associated query
	QueryID  openapi_types.UUID `json:"query_id"`
	Severity AlertSeverity      `json:"severity"`
	State    AlertState         `json:"state"`

	// TotalViolations Number of violations that triggered the alert
	TotalViolations int64 `json:"total_violations"`

	// TriggeredAt Timestamp when the alert was triggered
	TriggeredAt *time.Time `json:"triggered_at,omitempty"`

	// UpdatedAt Timestamp when the alert was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// AlertSeverity defines model for AlertSeverity.
type AlertSeverity string

// AlertState defines model for AlertState.
type AlertState string

// AlertTestResponse Alert Test Response
type AlertTestResponse struct {
	// DestinationID The ID of the notification destination.
	DestinationID string `json:"destination_id"`

	// Error An error message if the test failed, otherwise null.
	Error *string `json:"error,omitempty"`

	// Response Notification Destination Test Response
	Response NotificationDestinationTestResponse `json:"response"`
}

// AlertUpdate Alert Update Definition
type AlertUpdate struct {
	// Enabled Indicates if the alert is enabled
	Enabled *bool   `json:"enabled,omitempty"`
	Message *string `json:"message,omitempty"`

	// NotificationDestinations List of notification destinations to send alerts to
	NotificationDestinations *[]NotificationDestinationID `json:"notification_destinations,omitempty"`
	Severity                 *AlertSeverity               `json:"severity,omitempty"`
}

// AuditLogEvent defines model for AuditLogEvent.
type AuditLogEvent struct {
	// CreatedAt The timestamp when the event was created
	CreatedAt time.Time `json:"created_at"`

	// EntityDisplayName The display name of the entity that was affected
	EntityDisplayName *string `json:"entity_display_name"`

	// EventDetails Additional details about the event
	EventDetails *map[string]interface{} `json:"event_details,omitempty"`

	// EventType The type of event that was logged
	EventType string `json:"event_type"`

	// Id The unique identifier of the audit log event
	Id openapi_types.UUID `json:"id"`

	// IsSuccess Whether the event was successful
	IsSuccess *bool `json:"is_success,omitempty"`

	// User User
	User User `json:"user"`

	// UserIpAddress The IP address of the user who performed the action
	UserIpAddress string `json:"user_ip_address"`
}

// BaseNotification defines model for BaseNotification.
type BaseNotification struct {
	Status string `json:"status"`
}

// BasicError Basic Error
type BasicError struct {
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// BatchTableSchemaItem defines model for BatchTableSchemaItem.
type BatchTableSchemaItem struct {
	DefaultColumns []string    `json:"default_columns"`
	Schema         TableSchema `json:"schema"`

	// TableName Table name
	TableName string `json:"table_name"`
}

// CompletedNotification defines model for CompletedNotification.
type CompletedNotification struct {
	AdditionalStackIds  *[]string   `json:"additional_stack_ids,omitempty"`
	AdminRoleArn        string      `json:"admin_role_arn"`
	FailedAccounts      *float32    `json:"failed_accounts,omitempty"`
	OrganizationalUnits []string    `json:"organizational_units"`
	SkippedAccounts     []string    `json:"skipped_accounts"`
	Status              interface{} `json:"status"`
	SyncRoleName        string      `json:"sync_role_name"`
}

// CompletedSingleAccountNotification defines model for CompletedSingleAccountNotification.
type CompletedSingleAccountNotification struct {
	StackId     string      `json:"stack_id"`
	Status      interface{} `json:"status"`
	SyncRoleArn string      `json:"sync_role_arn"`
}

// Conversation defines model for Conversation.
type Conversation struct {
	CreatedAt time.Time `json:"created_at"`

	// ID Unique identifier of the conversation
	ID       openapi_types.UUID    `json:"id"`
	Messages []ConversationMessage `json:"messages"`

	// Title Optional title of the conversation
	Title     *string   `json:"title,omitempty"`
	UpdatedAt time.Time `json:"updated_at"`
}

// ConversationCreate defines model for ConversationCreate.
type ConversationCreate struct {
	// CurrentQuery An optional current query to provide context for the conversation.
	CurrentQuery *string `json:"current_query,omitempty"`

	// Message The initial message to start the conversation.
	Message string `json:"message"`

	// Mode The mode of the conversation, which can influence the behavior of the AI.
	Mode *ConversationCreateMode `json:"mode,omitempty"`
}

// ConversationCreateMode The mode of the conversation, which can influence the behavior of the AI.
type ConversationCreateMode string

// ConversationMessage defines model for ConversationMessage.
type ConversationMessage struct {
	// Content Content of the message. In the case of tool use or tool result, this will contain JSON data.
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`

	// EndTurn Whether this message ends the conversation turn
	EndTurn bool `json:"end_turn"`

	// ID Unique identifier of the message
	ID openapi_types.UUID `json:"id"`

	// MessageType Type of the message content
	MessageType ConversationMessageMessageType `json:"message_type"`

	// Mode The mode of the conversation when this message was sent, which can influence the behavior of the AI.
	Mode ConversationMessageMode `json:"mode"`

	// QueryContext The current query context when the message was sent, if applicable
	QueryContext *string `json:"query_context,omitempty"`

	// Role Role of the message sender
	Role ConversationMessageRole `json:"role"`
}

// ConversationMessageMessageType Type of the message content
type ConversationMessageMessageType string

// ConversationMessageMode The mode of the conversation when this message was sent, which can influence the behavior of the AI.
type ConversationMessageMode string

// ConversationMessageRole Role of the message sender
type ConversationMessageRole string

// ConversationSendMessage Send a message in a conversation
type ConversationSendMessage struct {
	// Message The message content to be sent
	Message string `json:"message"`

	// Mode The mode of the conversation, which can influence the behavior of the AI.
	Mode *ConversationSendMessageMode `json:"mode,omitempty"`

	// QueryContext Optional context for the message, such as the current SQL query being edited
	QueryContext *string `json:"query_context,omitempty"`
}

// ConversationSendMessageMode The mode of the conversation, which can influence the behavior of the AI.
type ConversationSendMessageMode string

// CreateSyncDestinationTestConnectionV2 defines model for CreateSyncDestinationTestConnectionV2.
type CreateSyncDestinationTestConnectionV2 struct {
	// DestinationName Name of an existing destination
	DestinationName *string `json:"destination_name,omitempty"`

	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// MigrateMode Migrate mode for the destination
	MigrateMode *SyncDestinationMigrateMode `json:"migrate_mode,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path        SyncPluginPath          `json:"path"`
	Spec        *map[string]interface{} `json:"spec,omitempty"`
	SyncGroupID *string                 `json:"sync_group_id,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`

	// WriteMode Write mode for the destination
	WriteMode *SyncDestinationWriteMode `json:"write_mode,omitempty"`
}

// CreateSyncDestinationV2 Sync Destination Definition
type CreateSyncDestinationV2 struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// MigrateMode Migrate mode for the destination
	MigrateMode *SyncDestinationMigrateMode `json:"migrate_mode,omitempty"`

	// Name Descriptive, unique name for the destination
	Name string `json:"name"`

	// OverwriteDestination Set this to allow overwriting an existing sync destination. Defaults to true to preserve compatibility.
	OverwriteDestination *bool `json:"overwrite_destination,omitempty"`
	SendSyncSummary      *bool `json:"send_sync_summary,omitempty"`

	// SyncDestinationTestConnectionID ID of the Sync Destination Test Connection
	SyncDestinationTestConnectionID *SyncDestinationTestConnectionID `json:"sync_destination_test_connection_id,omitempty"`

	// WriteMode Write mode for the destination
	WriteMode *SyncDestinationWriteMode `json:"write_mode,omitempty"`
}

// CreatedBy defines model for CreatedBy.
type CreatedBy struct {
	Email string `json:"email"`

	// UserID ID of the User
	UserID UserID `json:"id"`

	// Name The unique name for the user.
	Name UserName `json:"name"`
}

// CustomColumn A custom column that is configured manually by the user.
type CustomColumn struct {
	// ColumnName The name for the custom column.
	ColumnName  CustomColumnColumnName `json:"column_name"`
	CreatedAt   time.Time              `json:"created_at"`
	CreatedBy   CreatedBy              `json:"created_by"`
	Description *string                `json:"description,omitempty"`

	// CustomColumnID The unique ID for the custom column.
	CustomColumnID CustomColumnID `json:"id"`
	Label          string         `json:"label"`

	// ValueExpr The SQL expression for the custom column.
	ValueExpr CustomColumnValueExpr `json:"value_expr"`
}

// CustomColumnColumnName The name for the custom column.
type CustomColumnColumnName = string

// CustomColumnCreateOrUpdate Create or update a custom column
type CustomColumnCreateOrUpdate struct {
	// ColumnName The name for the custom column.
	ColumnName  CustomColumnColumnName `json:"column_name"`
	Description *string                `json:"description,omitempty"`
	Label       string                 `json:"label"`

	// ValueExpr The SQL expression for the custom column.
	ValueExpr CustomColumnValueExpr `json:"value_expr"`
}

// CustomColumnID The unique ID for the custom column.
type CustomColumnID = openapi_types.UUID

// CustomColumnSortBy defines model for CustomColumnSortBy.
type CustomColumnSortBy string

// CustomColumnSortDirection defines model for CustomColumnSortDirection.
type CustomColumnSortDirection string

// CustomColumnValueExpr The SQL expression for the custom column.
type CustomColumnValueExpr = string

// DeployedNotification defines model for DeployedNotification.
type DeployedNotification struct {
	DeploymentMode    string      `json:"deployment_mode"`
	ManagementRoleArn string      `json:"management_role_arn"`
	StackId           string      `json:"stack_id"`
	Status            interface{} `json:"status"`
}

// DisplayName A human-readable display name
type DisplayName = string

// FailedNotification defines model for FailedNotification.
type FailedNotification struct {
	Reason string      `json:"reason"`
	Status interface{} `json:"status"`
}

// FieldError defines model for FieldError.
type FieldError struct {
	Errors      *[]string          `json:"errors,omitempty"`
	FieldErrors *map[string]string `json:"field_errors,omitempty"`
	Message     string             `json:"message"`
	Status      int                `json:"status"`
}

// Filter Saved filter
type Filter struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`

	// Expression A table column filter.
	Expression FilterExpression `json:"expression"`

	// ID ID of the Filter
	ID   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`

	// QueryID The unique ID for the query.
	QueryID *QueryID `json:"query_id,omitempty"`

	// Table The name of the table.
	Table *TableName  `json:"table,omitempty"`
	Tags  []FilterTag `json:"tags,omitempty"`

	// UserID ID of the User
	UserID *UserID `json:"user_id,omitempty"`
}

// FilterCreate Saved filter
type FilterCreate struct {
	Description *string `json:"description,omitempty"`

	// Expression A table column filter.
	Expression FilterExpression `json:"expression"`
	Name       string           `json:"name"`

	// Public Whether the filter is visible to all users, or only to the user who created it
	Public bool        `json:"public"`
	Tags   []FilterTag `json:"tags,omitempty"`
}

// FilterExpression A table column filter.
type FilterExpression = string

// FilterID The unique ID for the filter.
type FilterID = openapi_types.UUID

// FilterTag A table column filter tag.
type FilterTag = string

// FilterUpdate Filter Update Definition
type FilterUpdate struct {
	Description *string `json:"description,omitempty"`

	// Expression A table column filter.
	Expression *FilterExpression `json:"expression,omitempty"`
	Name       *string           `json:"name,omitempty"`
	Tags       *[]FilterTag      `json:"tags,omitempty"`
}

// ListMetadata defines model for ListMetadata.
type ListMetadata struct {
	LastPage   *int `json:"last_page,omitempty"`
	PageSize   int  `json:"page_size"`
	TimeMs     *int `json:"time_ms,omitempty"`
	TotalCount *int `json:"total_count,omitempty"`
}

// ListPlugin defines model for ListPlugin.
type ListPlugin struct {
	// Category Supported categories for plugins
	Category  PluginCategory `json:"category"`
	CreatedAt time.Time      `json:"created_at"`

	// DisplayName The plugin's display name
	DisplayName string `json:"display_name"`

	// FreeRowsPerMonth Deprecated. Refer to `price_category` instead.
	// Deprecated:
	FreeRowsPerMonth int64   `json:"free_rows_per_month"`
	Homepage         *string `json:"homepage,omitempty"`

	// Kind The kind of plugin, ie. source or destination.
	Kind PluginKind `json:"kind"`

	// LatestVersion The version in semantic version format.
	LatestVersion *VersionName `json:"latest_version,omitempty"`
	Logo          string       `json:"logo"`

	// Name The unique name for the plugin.
	Name PluginName `json:"name"`

	// Official True if the plugin is maintained by CloudQuery, false otherwise
	Official bool `json:"official"`

	// PriceCategory Supported price categories for billing
	PriceCategory *PluginPriceCategory `json:"price_category,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public *bool `json:"public,omitempty"`

	// ReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
	// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
	// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
	// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
	ReleaseStage     PluginReleaseStage `json:"release_stage"`
	Repository       *string            `json:"repository,omitempty"`
	ShortDescription string             `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier This field is deprecated, refer to `price_category` instead.
	// This field is only kept for backward compatibility and may be removed in a future release.
	// Supported tiers for plugins.
	//   - free: Free tier, with no paid tables.
	//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
	//   - open-core: This option is deprecated, values will either be free or paid.
	// Deprecated:
	Tier      PluginTier `json:"tier"`
	UpdatedAt time.Time  `json:"updated_at"`

	// USDPerRow Deprecated. Refer to `price_category` instead.
	// Deprecated:
	USDPerRow string `json:"usd_per_row"`
}

// ListPlugins defines model for ListPlugins.
type ListPlugins = []ListPlugin

// ListSync defines model for ListSync.
type ListSync struct {
	// CPU CPU quota for the sync
	CPU string `json:"cpu"`

	// CreatedAt Time when the sync was created
	CreatedAt time.Time `json:"created_at"`
	CreatedBy *string   `json:"created_by,omitempty"`

	// Destinations List of destinations for the sync
	Destinations []string `json:"destinations"`

	// Disabled Whether the sync is disabled
	Disabled bool `json:"disabled"`

	// DisplayName A human-readable display name
	DisplayName DisplayName `json:"display_name"`

	// LastRun Managed Sync List Entry Last Run Info
	LastRun *ListSyncLastRun `json:"last_run,omitempty"`

	// Memory Memory quota for the sync
	Memory string `json:"memory"`

	// Name Descriptive, unique name for the sync
	Name string `json:"name"`

	// Schedule Cron schedule for the sync
	Schedule string `json:"schedule"`

	// Source Unique name of the source
	Source string `json:"source"`

	// UpdatedAt Time when the sync was updated
	UpdatedAt time.Time `json:"updated_at"`
}

// ListSyncLastRun Managed Sync List Entry Last Run Info
type ListSyncLastRun struct {
	// CompletedAt Time the sync run was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the sync run was created
	CreatedAt time.Time `json:"created_at"`

	// Errors Number of errors encountered during the sync
	Errors int64 `json:"errors"`

	// ID unique ID of the run
	ID openapi_types.UUID `json:"id"`

	// Ingested Whether the sync run's data has been ingested
	Ingested bool `json:"ingested"`

	// Migration Whether the sync run was a migration
	Migration bool `json:"migration"`

	// Status The status of the sync run
	Status SyncRunStatus `json:"status"`

	// StatusReason The reason for the status
	StatusReason *SyncRunStatusReason `json:"status_reason,omitempty"`

	// TotalRows Total number of rows in the sync
	TotalRows int64 `json:"total_rows"`

	// Warnings Number of warnings encountered during the sync
	Warnings int64 `json:"warnings"`
}

// NotificationDestination Notification Destination
type NotificationDestination struct {
	CreatedAt time.Time `json:"created_at"`

	// CustomMessage Optional custom message prepended to the alert when sending to Slack (only for slack type)
	CustomMessage *string `json:"custom_message"`
	Enabled       bool    `json:"enabled"`

	// HTTPBody HTTP body template (required for webhook type, must not be set for slack type). Supports simple variable interpolation using {{variable}} syntax. Available variables: {{query_name}}, {{query_url}}, {{alert_status}}, {{alert_message}}, {{alert_severity}}, {{alert_violations}}.
	HTTPBody    *string           `json:"http_body,omitempty"`
	HTTPHeaders map[string]string `json:"http_headers,omitempty"`

	// NotificationDestinationID The unique ID for the notification destination.
	NotificationDestinationID NotificationDestinationID `json:"id"`

	// LastNotificationErrorCode Error code of the last notification error
	LastNotificationErrorCode *string `json:"last_notification_error_code"`

	// LastNotificationErrorMessage Error message of the last notification error
	LastNotificationErrorMessage *string `json:"last_notification_error_message"`

	// LastNotificationErrorTimestamp Timestamp of the last notification error
	LastNotificationErrorTimestamp *time.Time `json:"last_notification_error_timestamp"`
	Name                           string     `json:"name"`

	// SlackChannels List of Slack channel IDs (only for slack type)
	SlackChannels *[]string `json:"slack_channels,omitempty"`

	// SlackConnectionID Slack connection ID (only for slack type)
	SlackConnectionID *openapi_types.UUID `json:"slack_connection_id"`

	// Type Type of notification destination
	Type      NotificationDestinationType `json:"type"`
	UpdatedAt time.Time                   `json:"updated_at"`
	URL       string                      `json:"url"`
}

// NotificationDestinationType Type of notification destination
type NotificationDestinationType string

// NotificationDestinationCreate defines model for NotificationDestinationCreate.
type NotificationDestinationCreate struct {
	// CustomMessage Optional custom message prepended to the alert when sending to Slack (only for slack type, must not be set for webhook)
	CustomMessage *string `json:"custom_message,omitempty"`
	Enabled       bool    `json:"enabled"`

	// HTTPBody HTTP body template (required for webhook type, must not be set for slack type). Supports simple variable interpolation using {{variable}} syntax. Available variables: {{query_name}}, {{query_url}}, {{alert_status}}, {{alert_message}}, {{alert_severity}}, {{alert_violations}}.
	HTTPBody *string `json:"http_body,omitempty"`

	// HTTPHeaders HTTP headers (required for webhook type, must not be set for slack type)
	HTTPHeaders map[string]string `json:"http_headers,omitempty"`
	Name        string            `json:"name"`

	// SlackChannels List of Slack channel IDs to send notifications to (required for slack type)
	SlackChannels *[]string `json:"slack_channels,omitempty"`

	// SlackConnectionID Slack connection ID (required for slack type)
	SlackConnectionID *openapi_types.UUID `json:"slack_connection_id,omitempty"`

	// Type Type of notification destination
	Type *NotificationDestinationCreateType `json:"type,omitempty"`

	// URL Webhook URL (required for webhook type, must not be set for slack type)
	URL *string `json:"url,omitempty"`
}

// NotificationDestinationCreateType Type of notification destination
type NotificationDestinationCreateType string

// NotificationDestinationData Notification Destination Data
type NotificationDestinationData struct {
	// CustomMessage Optional custom message prepended to the alert when sending to Slack (only for slack type, must not be set for webhook)
	CustomMessage *string `json:"custom_message,omitempty"`

	// HTTPBody HTTP body template (required for webhook type, must not be set for slack type). Supports simple variable interpolation using {{variable}} syntax. Available variables: {{query_name}}, {{query_url}}, {{alert_status}}, {{alert_message}}, {{alert_severity}}, {{alert_violations}}.
	HTTPBody *string `json:"http_body,omitempty"`

	// HTTPHeaders HTTP headers (required for webhook type, must not be set for slack type)
	HTTPHeaders map[string]string `json:"http_headers,omitempty"`

	// SlackChannels List of Slack channel IDs to send notifications to (required for slack type)
	SlackChannels *[]string `json:"slack_channels,omitempty"`

	// SlackConnectionID Slack connection ID (required for slack type)
	SlackConnectionID *openapi_types.UUID `json:"slack_connection_id,omitempty"`

	// Type Type of notification destination
	Type *NotificationDestinationDataType `json:"type,omitempty"`

	// URL Webhook URL (required for webhook type, must not be set for slack type)
	URL *string `json:"url,omitempty"`
}

// NotificationDestinationDataType Type of notification destination
type NotificationDestinationDataType string

// NotificationDestinationID The unique ID for the notification destination.
type NotificationDestinationID = openapi_types.UUID

// NotificationDestinationListItem Notification Destination List Item
type NotificationDestinationListItem struct {
	CreatedAt time.Time `json:"created_at"`
	Enabled   bool      `json:"enabled"`

	// NotificationDestinationID The unique ID for the notification destination.
	NotificationDestinationID NotificationDestinationID `json:"id"`
	Name                      string                    `json:"name"`

	// Type Type of notification destination
	Type      NotificationDestinationListItemType `json:"type"`
	UpdatedAt time.Time                           `json:"updated_at"`
	URL       string                              `json:"url"`
}

// NotificationDestinationListItemType Type of notification destination
type NotificationDestinationListItemType string

// NotificationDestinationTestResponse Notification Destination Test Response
type NotificationDestinationTestResponse struct {
	// HTTPBody Body of the HTTP response from the notification destination
	HTTPBody string `json:"http_body"`

	// HTTPHeaders Headers returned by the notification destination
	HTTPHeaders map[string]string `json:"http_headers"`

	// HTTPStatus HTTP status message returned by the notification destination
	HTTPStatus string `json:"http_status"`

	// HTTPStatusCode HTTP status code returned by the notification destination
	HTTPStatusCode int `json:"http_status_code"`

	// IsSuccess Indicates if the test was successful
	IsSuccess bool `json:"is_success"`
}

// NotificationDestinationUpdate Update Notification Destination
type NotificationDestinationUpdate struct {
	// CustomMessage Optional custom message prepended to the alert when sending to Slack (only for slack type, must not be set for webhook)
	CustomMessage *string `json:"custom_message,omitempty"`
	Enabled       *bool   `json:"enabled,omitempty"`

	// HTTPBody HTTP body template (required for webhook type, must not be set for slack type). Supports simple variable interpolation using {{variable}} syntax. Available variables: {{query_name}}, {{query_url}}, {{alert_status}}, {{alert_message}}, {{alert_severity}}, {{alert_violations}}.
	HTTPBody    *string            `json:"http_body,omitempty"`
	HTTPHeaders *map[string]string `json:"http_headers,omitempty"`
	Name        *string            `json:"name,omitempty"`

	// SlackChannels List of Slack channel IDs to send notifications to (only for slack type, must not be set for webhook)
	SlackChannels *[]string `json:"slack_channels,omitempty"`

	// SlackConnectionID Slack connection ID (only for slack type, must not be set for webhook)
	SlackConnectionID *openapi_types.UUID `json:"slack_connection_id,omitempty"`
	URL               *string             `json:"url,omitempty"`
}

// NotificationDetail A notification instance for a triggered alert, including one notification destination. Each notification destination for an alert will result in a separate notification item.
type NotificationDetail struct {
	// CreatedAt Timestamp when the alert was created
	CreatedAt time.Time `json:"created_at"`

	// ID Unique identifier for the alert
	ID openapi_types.UUID `json:"id"`

	// LastEvaluatedAt Timestamp when the alert was last evaluated
	LastEvaluatedAt *time.Time `json:"last_evaluated_at,omitempty"`

	// Message Alert message content
	Message string `json:"message"`

	// NotificationDestination Notification Destination List Item
	NotificationDestination *NotificationDestinationListItem `json:"notification_destination,omitempty"`

	// PolicyID Reference to the associated policy
	PolicyID openapi_types.UUID `json:"policy_id"`

	// QueryID Reference to the associated query
	QueryID  openapi_types.UUID `json:"query_id"`
	Severity AlertSeverity      `json:"severity"`
	State    AlertState         `json:"state"`

	// TotalViolations Number of violations that triggered the alert
	TotalViolations int64 `json:"total_violations"`

	// TriggeredAt Timestamp when the alert was triggered
	TriggeredAt *time.Time `json:"triggered_at,omitempty"`

	// UpdatedAt Timestamp when the alert was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// OnboardingAWS AWS OpenID onboarding
type OnboardingAWS struct {
	// Audience OpenID audience claim for the trust realshionship
	Audience  string    `json:"audience"`
	CreatedAt time.Time `json:"created_at"`

	// FailureReason CloudFormation stack errors
	FailureReason *string `json:"failure_reason,omitempty"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID OnboardingID `json:"id"`

	// IssuerURL URL of the OpenID server to use when setting up a trust relationship
	IssuerURL string `json:"issuer_url"`

	// ManagementRoleARN Role used to manage the platform onboarding
	ManagementRoleARN *string `json:"management_role_arn,omitempty"`

	// OrganizationalUnitIDs (organization mode) A list of Organizational Unit (OU) IDs included in this onboarding.
	OrganizationalUnitIDs *[]string `json:"organizational_units,omitempty"`

	// OnboardingStage Stage of the onboarding process
	OnboardingStage string `json:"stage"`

	// Subject OpenID subject claim for the trust relationship
	Subject string `json:"subject"`

	// SyncRoleName (organization mode) The name of the sync role used to sync a specific account within the organization.
	// Note: This is the role name only, not the full ARN.
	SyncRoleName *string   `json:"sync_role_name,omitempty"`
	UpdatedAt    time.Time `json:"updated_at"`
}

// OnboardingAWSAccounts AWS OpenID onboarding account structure
type OnboardingAWSAccounts struct {
	// ARN ARN of the account or OU
	ARN *string `json:"arn,omitempty"`

	// Children Children accounts and OUs of the target account
	Children *[]OnboardingAWSAccounts `json:"children,omitempty"`

	// ID ID of the account or OU
	ID string `json:"id"`

	// Name Display name of the account or OU
	Name *string `json:"name,omitempty"`

	// Type Type of the account
	Type OnboardingAWSAccountsType `json:"type"`
}

// OnboardingAWSAccountsType Type of the account
type OnboardingAWSAccountsType string

// OnboardingAWSCreateResponse AWS OpenID onboarding
type OnboardingAWSCreateResponse struct {
	// Audience OpenID audience claim for the trust realshionship
	Audience string `json:"audience"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID OnboardingID `json:"id"`

	// IssuerURL URL of the OpenID server to use when setting up a trust relationship
	IssuerURL string `json:"issuer_url"`

	// NotifyPath Path of the notify endpoint to use for status updates
	NotifyPath string `json:"notify_path"`

	// NotifyToken An authentication token that should be used for notifications
	NotifyToken string `json:"notify_token"`

	// Region An AWS region (such as 'us-east-1') where stack is deployed
	Region *string `json:"region,omitempty"`

	// StackName Stack name that should be used
	StackName *string `json:"stack_name,omitempty"`

	// Subject OpenID subject claim for the trust relationship
	Subject string `json:"subject"`

	// TemplateURL URL of the CloudFormation template to use for the authentication
	TemplateURL string `json:"template_url"`
}

// OnboardingAWSNotification defines model for OnboardingAWSNotification.
type OnboardingAWSNotification struct {
	union json.RawMessage
}

// OnboardingAWSProvision Stackset provisioning configuration
type OnboardingAWSProvision struct {
	// NotifyUrl URL that should be used for provisioning notifications (including scheme, hostname, and path)
	NotifyUrl string `json:"notify_url"`

	// OrganizationalUnits OUs to provision roles into
	OrganizationalUnits []string `json:"organizational_units"`

	// SkipAccounts Account IDs to skip onboarding
	SkipAccounts *[]string `json:"skip_accounts,omitempty"`
}

// OnboardingID ID of the cloud provider onboarding session
type OnboardingID = openapi_types.UUID

// OrganizationalUnitID ID of an organizational unit in AWS
type OrganizationalUnitID = string

// PlatformDataSettings Platform data settings definition
type PlatformDataSettings struct {
	// OwnershipTags List of tag names for asset ownership
	OwnershipTags []string `json:"ownership_tags"`
}

// PlatformDataSettingsUpdate Platform data settings partial update
type PlatformDataSettingsUpdate struct {
	// OwnershipTags List of tag names for asset ownership
	OwnershipTags *[]string `json:"ownership_tags,omitempty"`
}

// PlatformSettings Platform settings definition
type PlatformSettings struct {
	// EnforceMfa Whether or not to require MFA for all users
	EnforceMfa bool `json:"enforce_mfa"`
}

// PlatformSettingsUpdate Platform settings partial update
type PlatformSettingsUpdate struct {
	// EnforceMfa Whether or not to require MFA for all users
	EnforceMfa *bool `json:"enforce_mfa,omitempty"`
}

// PlatformVersion defines model for PlatformVersion.
type PlatformVersion struct {
	// CreatedAt Time when the version was first installed
	CreatedAt time.Time `json:"created_at"`

	// Name Name of the version
	Name string `json:"name"`
}

// Plugin CloudQuery Plugin
type Plugin struct {
	// Category Supported categories for plugins
	Category  PluginCategory `json:"category"`
	CreatedAt time.Time      `json:"created_at"`

	// DisplayName The plugin's display name
	DisplayName string `json:"display_name"`

	// FreeRowsPerMonth Deprecated. Refer to `price_category` instead.
	// Deprecated:
	FreeRowsPerMonth int64   `json:"free_rows_per_month"`
	Homepage         *string `json:"homepage,omitempty"`

	// Kind The kind of plugin, ie. source or destination.
	Kind PluginKind `json:"kind"`
	Logo string     `json:"logo"`

	// Name The unique name for the plugin.
	Name PluginName `json:"name"`

	// Official True if the plugin is maintained by CloudQuery, false otherwise
	Official bool `json:"official"`

	// PriceCategory Supported price categories for billing
	PriceCategory *PluginPriceCategory `json:"price_category,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public *bool `json:"public,omitempty"`

	// ReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
	// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
	// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
	// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
	ReleaseStage     PluginReleaseStage `json:"release_stage"`
	Repository       *string            `json:"repository,omitempty"`
	ShortDescription string             `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier This field is deprecated, refer to `price_category` instead.
	// This field is only kept for backward compatibility and may be removed in a future release.
	// Supported tiers for plugins.
	//   - free: Free tier, with no paid tables.
	//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
	//   - open-core: This option is deprecated, values will either be free or paid.
	// Deprecated:
	Tier      PluginTier `json:"tier"`
	UpdatedAt time.Time  `json:"updated_at"`

	// USDPerRow Deprecated. Refer to `price_category` instead.
	// Deprecated:
	USDPerRow string `json:"usd_per_row"`
}

// PluginAsset CloudQuery Plugin Asset
type PluginAsset struct {
	// Checksum The checksum of the plugin asset
	Checksum string `json:"checksum"`

	// Location The location to download the plugin asset from
	Location string `json:"location"`
}

// PluginCategory Supported categories for plugins
type PluginCategory string

// PluginKind The kind of plugin, ie. source or destination.
type PluginKind string

// PluginName The unique name for the plugin.
type PluginName = string

// PluginPackageType The package type of the plugin assets
type PluginPackageType string

// PluginPriceCategory Supported price categories for billing
type PluginPriceCategory string

// PluginProtocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
type PluginProtocols = []int

// PluginReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
type PluginReleaseStage string

// PluginSpecJSONSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
type PluginSpecJSONSchema = string

// PluginTable CloudQuery Plugin Table
type PluginTable struct {
	// Description Description of the table
	Description string `json:"description"`

	// IsIncremental Whether the table is incremental
	IsIncremental bool `json:"is_incremental"`

	// IsPaid Whether the table is paid
	IsPaid *bool `json:"is_paid,omitempty"`

	// Name Name of the table
	Name PluginTableName `json:"name"`

	// Parent Name of the parent table, if any
	Parent *string `json:"parent,omitempty"`

	// Relations Names of the tables that depend on this table
	Relations []string `json:"relations"`

	// Title Title of the table
	Title string `json:"title"`
}

// PluginTableColumn CloudQuery Plugin Column
type PluginTableColumn struct {
	// Description Description of the column
	Description string `json:"description"`

	// IncrementalKey Whether the column is used as an incremental key
	IncrementalKey bool `json:"incremental_key"`

	// Name Name of the column
	Name string `json:"name"`

	// NotNull Whether the column is nullable
	NotNull bool `json:"not_null"`

	// PrimaryKey Whether the column is part of the primary key
	PrimaryKey bool `json:"primary_key"`

	// Type Arrow Type of the column
	Type string `json:"type"`

	// TypeSchema For columns of type JSON, the schema of the JSON object
	TypeSchema *string `json:"type_schema,omitempty"`

	// Unique Whether the column has a unique constraint
	Unique bool `json:"unique"`
}

// PluginTableDetails defines model for PluginTableDetails.
type PluginTableDetails struct {
	// Columns List of columns
	Columns []PluginTableColumn `json:"columns"`

	// Description Description of the table
	Description string `json:"description"`

	// IsIncremental Whether the table is incremental
	IsIncremental bool `json:"is_incremental"`

	// IsPaid Whether the table is paid
	IsPaid *bool `json:"is_paid,omitempty"`

	// Name Name of the table
	Name string `json:"name"`

	// Parent Name of the parent table, if any
	Parent *string `json:"parent,omitempty"`

	// PermissionsNeeded List of permissions needed to access this table, if any
	PermissionsNeeded []string `json:"permissions_needed"`

	// Relations Names of the tables that depend on this table
	Relations []string `json:"relations"`

	// Title Title of the table
	Title string `json:"title"`
}

// PluginTableName Name of the table
type PluginTableName = string

// PluginTier This field is deprecated, refer to `price_category` instead.
// This field is only kept for backward compatibility and may be removed in a future release.
// Supported tiers for plugins.
//   - free: Free tier, with no paid tables.
//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
//   - open-core: This option is deprecated, values will either be free or paid.
type PluginTier string

// PluginVersion defines model for PluginVersion.
type PluginVersion struct {
	// Checksums The checksums of the plugin assets
	Checksums []string `json:"checksums"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`

	// SpecJsonSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
	SpecJsonSchema *PluginSpecJSONSchema `json:"spec_json_schema,omitempty"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`
}

// PluginVersionBase CloudQuery Plugin Version
type PluginVersionBase struct {
	// Checksums The checksums of the plugin assets
	Checksums []string `json:"checksums"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`
}

// PluginVersionDetails defines model for PluginVersionDetails.
type PluginVersionDetails struct {
	// Checksums The checksums of the plugin assets
	Checksums []string `json:"checksums"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// ExampleConfig Example configuration for the plugin. This can be used in generated quickstart guides, for example. Markdown format.
	ExampleConfig string `json:"example_config"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`

	// SpecJsonSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
	SpecJsonSchema *PluginSpecJSONSchema `json:"spec_json_schema,omitempty"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`

	// UIBaseURL Base URL for the plugin's UI. Only available for plugins with a UI and for logged in users.
	UIBaseURL *string `json:"ui_base_url,omitempty"`

	// UIBaseURLv2 Base URL for the plugin's UI. Only available for plugins with a UI and for logged in users.
	UIBaseURLv2 *string `json:"ui_base_url_v2,omitempty"`
}

// PluginVersionList CloudQuery Plugin Version
type PluginVersionList = PluginVersionBase

// Policy Policy
type Policy struct {
	CreatedAt       time.Time          `json:"created_at"`
	CreatedByUserID openapi_types.UUID `json:"created_by"`
	Description     string             `json:"description"`

	// PolicyDomain Policy domain
	PolicyDomain PolicyDomain `json:"domain"`

	// PolicyID The unique ID for the policy.
	PolicyID PolicyID `json:"id"`
	Name     string   `json:"name"`

	// NotificationDestinations List of notification destinations configured for the policy's alert
	NotificationDestinations *[]NotificationDestinationListItem `json:"notification_destinations,omitempty"`

	// PolicyGroups List of policy groups this policy belongs to
	PolicyGroups *[]PolicyGroup `json:"policy_groups,omitempty"`

	// Query The SQL query string for the policy
	Query string `json:"query"`

	// QueryID The unique ID for the query.
	QueryID QueryID `json:"query_id"`

	// RunAt Timestamp of the last evaluation run
	RunAt *time.Time `json:"run_at"`

	// PolicySeverity Policy severity
	PolicySeverity PolicySeverity `json:"severity"`

	// PolicyStatus Policy status
	PolicyStatus    PolicyStatus        `json:"status"`
	TeamName        string              `json:"team_name"`
	UpdatedAt       time.Time           `json:"updated_at"`
	UpdatedByUserID *openapi_types.UUID `json:"updated_by"`

	// ViolationCount Number of violations from the last evaluation
	ViolationCount *int `json:"violation_count"`
}

// PolicyCreate Create a policy (implicitly creates a query and an enabled alert)
type PolicyCreate struct {
	Description *string `json:"description,omitempty"`

	// PolicyDomain Policy domain
	PolicyDomain PolicyDomain `json:"domain"`
	Name         string       `json:"name"`

	// NotificationDestinationIds Notification destination IDs to send alerts to
	NotificationDestinationIds *[]openapi_types.UUID `json:"notification_destination_ids"`

	// PolicyGroupIds Policy group IDs to add this policy to
	PolicyGroupIds *[]openapi_types.UUID `json:"policy_group_ids"`
	Query          string                `json:"query"`

	// PolicySeverity Policy severity
	PolicySeverity PolicySeverity `json:"severity"`
}

// PolicyDomain Policy domain
type PolicyDomain string

// PolicyEvaluationLog Policy evaluation log entry
type PolicyEvaluationLog struct {
	Id openapi_types.UUID `json:"id"`

	// PolicyID The unique ID for the policy.
	PolicyID       PolicyID  `json:"policy_id"`
	RunAt          time.Time `json:"run_at"`
	ViolationCount int       `json:"violation_count"`
}

// PolicyGroup Policy Group
type PolicyGroup struct {
	CreatedAt   time.Time          `json:"created_at"`
	Description string             `json:"description"`
	Id          openapi_types.UUID `json:"id"`
	Name        string             `json:"name"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// PolicyGroupCreate Create a policy group
type PolicyGroupCreate struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`

	// PolicyIds Optional array of policy IDs to add to this group
	PolicyIds *[]openapi_types.UUID `json:"policy_ids"`
}

// PolicyGroupID defines model for PolicyGroupID.
type PolicyGroupID = openapi_types.UUID

// PolicyGroupUpdate Update a policy group
type PolicyGroupUpdate struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`

	// PolicyIds Policy IDs to set for this group
	PolicyIds *[]openapi_types.UUID `json:"policy_ids"`
}

// PolicyGroupWithCounts defines model for PolicyGroupWithCounts.
type PolicyGroupWithCounts struct {
	CreatedAt   time.Time          `json:"created_at"`
	Description string             `json:"description"`
	Id          openapi_types.UUID `json:"id"`
	Name        string             `json:"name"`

	// PolicyCount Number of policies in this group
	PolicyCount *int      `json:"policy_count,omitempty"`
	UpdatedAt   time.Time `json:"updated_at"`

	// ViolationCountCritical Total violations from critical severity policies in this group
	ViolationCountCritical *int `json:"violation_count_critical,omitempty"`

	// ViolationCountHigh Total violations from high severity policies in this group
	ViolationCountHigh *int `json:"violation_count_high,omitempty"`

	// ViolationCountLow Total violations from low severity policies in this group
	ViolationCountLow *int `json:"violation_count_low,omitempty"`

	// ViolationCountMedium Total violations from medium severity policies in this group
	ViolationCountMedium *int `json:"violation_count_medium,omitempty"`
}

// PolicyID The unique ID for the policy.
type PolicyID = openapi_types.UUID

// PolicyMetrics Policy metrics summary
type PolicyMetrics struct {
	// HighSeverityViolations Total violations from high or critical severity policies
	HighSeverityViolations int `json:"high_severity_violations"`

	// TotalActiveViolations Total violations from active policies
	TotalActiveViolations int `json:"total_active_violations"`

	// ViolationsThisWeek Total violations from evaluations in the last 7 days
	ViolationsThisWeek int `json:"violations_this_week"`
}

// PolicySeverity Policy severity
type PolicySeverity string

// PolicyStatus Policy status
type PolicyStatus string

// PolicyUpdate Update a policy
type PolicyUpdate struct {
	Description *string `json:"description,omitempty"`

	// PolicyDomain Policy domain
	PolicyDomain *PolicyDomain `json:"domain,omitempty"`
	Name         *string       `json:"name,omitempty"`

	// NotificationDestinationIds Notification destination IDs to send alerts to
	NotificationDestinationIds *[]openapi_types.UUID `json:"notification_destination_ids"`

	// PolicyGroupIds Policy group IDs to set for this policy
	PolicyGroupIds *[]openapi_types.UUID `json:"policy_group_ids"`
	Query          *string               `json:"query,omitempty"`

	// PolicySeverity Policy severity
	PolicySeverity *PolicySeverity `json:"severity,omitempty"`
}

// PolicyViolation Policy violation resource information
type PolicyViolation struct {
	CqAccountName     string `json:"_cq_account_name"`
	CqPlatformId      string `json:"_cq_platform_id"`
	Cloud             string `json:"cloud"`
	Name              string `json:"name"`
	Region            string `json:"region"`
	ResourceTypeLabel string `json:"resource_type_label"`
}

// PromoteSyncDestinationTestConnection Sync Destination Definition
type PromoteSyncDestinationTestConnection struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// MigrateMode Migrate mode for the destination
	MigrateMode *SyncDestinationMigrateMode `json:"migrate_mode,omitempty"`

	// Name Descriptive, unique name for the destination
	Name string `json:"name"`

	// OverwriteDestination Set this to allow overwriting an existing sync destination. Defaults to true to preserve compatibility.
	OverwriteDestination *bool `json:"overwrite_destination,omitempty"`
	SendSyncSummary      *bool `json:"send_sync_summary,omitempty"`

	// WriteMode Write mode for the destination
	WriteMode *SyncDestinationWriteMode `json:"write_mode,omitempty"`
}

// PromoteSyncSourceTestConnection Sync Source Definition
type PromoteSyncSourceTestConnection struct {
	// DestinationNames List of sync destination names associated with this source
	DestinationNames *[]SyncDestinationNameField `json:"destination_names,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Name Descriptive, unique name for the source
	Name string `json:"name"`

	// OverwriteSource Set this to allow overwriting an existing sync source. Defaults to true to preserve compatibility.
	OverwriteSource *bool `json:"overwrite_source,omitempty"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables *[]string `json:"skip_tables,omitempty"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables []string `json:"tables"`
}

// Query Saved query
type Query struct {
	// Alert An alert instance that can be triggered by a query
	Alert *Alert `json:"alert,omitempty"`

	// AlertConfigured Indicates if the query has an alert configured
	AlertConfigured bool      `json:"alert_configured"`
	CreatedAt       time.Time `json:"created_at"`
	Description     *string   `json:"description,omitempty"`

	// QueryID The unique ID for the query.
	QueryID QueryID `json:"id"`
	Name    string  `json:"name"`

	// Query Query expression
	Query QueryExpression `json:"query"`
	Tags  []QueryTag      `json:"tags,omitempty"`

	// UserID ID of the User
	UserID *UserID `json:"user_id,omitempty"`

	// ViewName The name of the view the query is saved to in the warehouse
	ViewName *QueryViewName `json:"view_name,omitempty"`
}

// QueryCreate Create a saved query
type QueryCreate struct {
	// Alert Create an alert
	Alert       *AlertCreate `json:"alert,omitempty"`
	Description *string      `json:"description,omitempty"`
	Name        string       `json:"name"`
	Public      bool         `json:"public"`
	Query       string       `json:"query"`
	Tags        []QueryTag   `json:"tags,omitempty"`

	// ViewName The name of the view the query is saved to in the warehouse
	ViewName *QueryViewName `json:"view_name,omitempty"`
}

// QueryDetail Query Detail
type QueryDetail struct {
	// Alert An alert instance that can be triggered by a query including notification destinations for the alert
	Alert *AlertDetail `json:"alert,omitempty"`

	// AlertConfigured Indicates if the query has an alert configured. When this is set, the alert field will be populated with the alert details.
	AlertConfigured bool      `json:"alert_configured"`
	CreatedAt       time.Time `json:"created_at"`
	Description     *string   `json:"description,omitempty"`

	// QueryID The unique ID for the query.
	QueryID QueryID `json:"id"`
	Name    string  `json:"name"`

	// Query Query expression
	Query QueryExpression `json:"query"`
	Tags  []QueryTag      `json:"tags,omitempty"`

	// UserID ID of the User
	UserID *UserID `json:"user_id,omitempty"`

	// ViewName The name of the view the query is saved to in the warehouse
	ViewName *QueryViewName `json:"view_name,omitempty"`
}

// QueryExpression Query expression
type QueryExpression = string

// QueryID The unique ID for the query.
type QueryID = openapi_types.UUID

// QueryTag A saved query tag.
type QueryTag = string

// QueryUpdate Update a saved query
type QueryUpdate struct {
	// Alert Alert Update Definition
	Alert       *AlertUpdate `json:"alert,omitempty"`
	Description *string      `json:"description,omitempty"`
	Name        *string      `json:"name,omitempty"`
	Public      *bool        `json:"public,omitempty"`
	Query       *string      `json:"query,omitempty"`
	Tags        *[]QueryTag  `json:"tags,omitempty"`

	// ViewName The name of the view the query is saved to in the warehouse
	ViewName *QueryViewName `json:"view_name,omitempty"`
}

// QueryViewName The name of the view the query is saved to in the warehouse
type QueryViewName = string

// RBACPermission defines model for RBACPermission.
type RBACPermission struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedBy   CreatedBy `json:"created_by"`
	Description string    `json:"description"`

	// RBACPermissionID The unique ID for the data permission.
	RBACPermissionID      RBACPermissionID `json:"id"`
	Name                  string           `json:"name"`
	NumberOfAffectedRoles int              `json:"number_of_affected_roles"`
	NumberOfAffectedUsers int              `json:"number_of_affected_users"`
	Query                 string           `json:"query"`
	UpdatedAt             time.Time        `json:"updated_at"`
}

// RBACPermissionCreate defines model for RBACPermissionCreate.
type RBACPermissionCreate struct {
	Description string `json:"description"`
	DryRun      *bool  `json:"dry_run,omitempty"`
	Name        string `json:"name"`
	Query       string `json:"query"`
}

// RBACPermissionID The unique ID for the data permission.
type RBACPermissionID = openapi_types.UUID

// RBACPermissionSortBy defines model for RBACPermissionSortBy.
type RBACPermissionSortBy string

// RBACPermissionSortDirection defines model for RBACPermissionSortDirection.
type RBACPermissionSortDirection string

// RBACPermissionUpdate defines model for RBACPermissionUpdate.
type RBACPermissionUpdate struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	Query       *string `json:"query,omitempty"`
}

// RBACRoleCreate defines model for RBACRoleCreate.
type RBACRoleCreate struct {
	Description *string            `json:"description,omitempty"`
	Name        string             `json:"name"`
	Permissions []RBACPermissionID `json:"permissions"`
}

// RBACRoleSortBy defines model for RBACRoleSortBy.
type RBACRoleSortBy string

// RBACRoleSortDirection defines model for RBACRoleSortDirection.
type RBACRoleSortDirection string

// RBACRoleUpdate defines model for RBACRoleUpdate.
type RBACRoleUpdate struct {
	Description *string             `json:"description,omitempty"`
	Name        *string             `json:"name,omitempty"`
	Permissions *[]RBACPermissionID `json:"permissions,omitempty"`
}

// Report defines model for Report.
type Report struct {
	// Content YAML body
	Content     string             `json:"content"`
	CreatedAt   *time.Time         `json:"created_at,omitempty"`
	CreatedBy   *CreatedBy         `json:"created_by,omitempty"`
	Description string             `json:"description"`
	ID          openapi_types.UUID `json:"id"`
	Private     bool               `json:"private"`
	Title       string             `json:"title"`
	UpdatedAt   *time.Time         `json:"updated_at,omitempty"`
	UpdatedBy   *CreatedBy         `json:"updated_by,omitempty"`
}

// ReportCreate defines model for ReportCreate.
type ReportCreate struct {
	// Content YAML body
	Content     string  `json:"content"`
	Description *string `json:"description,omitempty"`
	Private     *bool   `json:"private,omitempty"`

	// TemplateID Template ID, if report is being created from a template
	TemplateID *openapi_types.UUID `json:"template_id,omitempty"`
	Title      string              `json:"title"`
}

// ReportSortBy defines model for ReportSortBy.
type ReportSortBy string

// ReportSortDirection defines model for ReportSortDirection.
type ReportSortDirection string

// ReportTemplate defines model for ReportTemplate.
type ReportTemplate struct {
	// Content YAML body
	Content     string             `json:"content"`
	CreatedAt   *time.Time         `json:"created_at,omitempty"`
	Description string             `json:"description"`
	ID          openapi_types.UUID `json:"id"`
	Title       string             `json:"title"`
	UpdatedAt   *time.Time         `json:"updated_at,omitempty"`
	Visible     bool               `json:"visible"`
}

// ReportTemplateCreateOrUpdate defines model for ReportTemplateCreateOrUpdate.
type ReportTemplateCreateOrUpdate struct {
	// Content YAML body
	Content     *string `json:"content,omitempty"`
	Description *string `json:"description,omitempty"`
	Title       *string `json:"title,omitempty"`
	Visible     *bool   `json:"visible,omitempty"`
}

// ReportTemplateSortBy defines model for ReportTemplateSortBy.
type ReportTemplateSortBy string

// ReportTemplateSortDirection defines model for ReportTemplateSortDirection.
type ReportTemplateSortDirection string

// ReportUpdate defines model for ReportUpdate.
type ReportUpdate struct {
	// Content YAML body
	Content     *string `json:"content,omitempty"`
	Description *string `json:"description,omitempty"`
	Private     *bool   `json:"private,omitempty"`

	// TemplateID Template ID, if report is being created from a template
	TemplateID *openapi_types.UUID `json:"template_id,omitempty"`
	Title      *string             `json:"title,omitempty"`
}

// RevokedNotification defines model for RevokedNotification.
type RevokedNotification struct {
	Status interface{} `json:"status"`
}

// Role Role
type Role struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedBy   CreatedBy `json:"created_by"`
	Description string    `json:"description"`

	// ID The unique ID for the role.
	ID          openapi_types.UUID `json:"id"`
	Name        string             `json:"name"`
	Permissions []RBACPermission   `json:"permissions"`
	Type        RoleType           `json:"type"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// RoleID The unique ID for the role.
type RoleID = openapi_types.UUID

// RoleType defines model for RoleType.
type RoleType string

// SAMLConfig defines model for SAMLConfig.
type SAMLConfig struct {
	// CanEnable Whether SAML can be enabled
	CanEnable bool `json:"can_enable"`

	// DefaultRoles Default roles for new users who are not in any group
	DefaultRoles []Role `json:"default_roles"`

	// DisableAccessIfNoRoleGroup Whether to disable access if no role group is found in the SAML assertion. If true, users without a role group will not be able to log in.
	DisableAccessIfNoRoleGroup *bool `json:"disable_access_if_no_role_group,omitempty"`

	// Enabled Whether SAML is enabled
	Enabled bool `json:"enabled"`

	// LogoutURL Logout URL from identity provider
	LogoutURL *string `json:"logout_url,omitempty"`

	// MetadataURL Metadata URL from identity provider. Mutually exclusive with `metadata_xml`
	MetadataURL *string `json:"metadata_url,omitempty"`

	// MetadataXML Metadata file contents from identity provider. Mutually exclusive with `metadata_url`
	MetadataXML *string `json:"metadata_xml,omitempty"`

	// PlatformCertificateDownloadURL Platform Certificate download URL
	PlatformCertificateDownloadURL string `json:"platform_certificate_download_url"`

	// PlatformEntityID SAML Entity ID.
	PlatformEntityID string `json:"platform_entity_id"`

	// PlatformMetadataDownloadURL URL to download platform metadata.
	PlatformMetadataDownloadURL string `json:"platform_metadata_download_url"`

	// PlatformSSOURL SAML service URL.
	PlatformSSOURL string `json:"platform_sso_url"`

	// RoleGroupKey Role group key name
	RoleGroupKey *string `json:"role_group_key,omitempty"`

	// RoleMappings Mapping from IdP group names to roles. Each key is a potential IdP group value for the specified role_group_key, and each value is an array of roles to assign to users in that group.
	RoleMappings map[string][]Role `json:"role_mappings,omitempty"`
}

// SAMLConfigUpdate defines model for SAMLConfigUpdate.
type SAMLConfigUpdate struct {
	// DefaultRoles Default roles for new users who are not in any group
	DefaultRoles *[]RoleID `json:"default_roles,omitempty"`

	// DisableAccessIfNoRoleGroup Whether to disable access if no role group is found in the SAML assertion. If true, users without a role group will not be able to log in.
	DisableAccessIfNoRoleGroup *bool `json:"disable_access_if_no_role_group,omitempty"`

	// Enabled Whether to enable or disable SAML
	Enabled *bool `json:"enabled,omitempty"`

	// LogoutURL Logout URL from identity provider
	LogoutURL *string `json:"logout_url,omitempty"`

	// MetadataURL Metadata URL from identity provider. Mutually exclusive with `metadata_xml`
	MetadataURL *string `json:"metadata_url,omitempty"`

	// MetadataXML Metadata file contents from identity provider. Mutually exclusive with `metadata_url`
	MetadataXML *string `json:"metadata_xml,omitempty"`

	// RoleGroupKey Role group key name
	RoleGroupKey *string `json:"role_group_key,omitempty"`

	// RoleMappings Mapping from IdP group names to roles. Each key is a potential IdP group value for the specified role_group_key, and each value is an array of roles to assign to users in that group.
	RoleMappings *map[string][]RoleID `json:"role_mappings,omitempty"`
}

// SlackChannel Slack Channel
type SlackChannel struct {
	// Id Channel ID
	Id string `json:"id"`

	// IsArchived Whether the channel is archived
	IsArchived *bool `json:"is_archived,omitempty"`

	// IsPrivate Whether the channel is private
	IsPrivate *bool `json:"is_private,omitempty"`

	// Name Channel name
	Name string `json:"name"`
}

// SlackConnection Slack Connection
type SlackConnection struct {
	CreatedAt time.Time `json:"created_at"`

	// Id Slack connection ID
	Id openapi_types.UUID `json:"id"`

	// SlackWorkspaceID Slack workspace (team) ID
	SlackWorkspaceID string `json:"slack_workspace_id"`

	// TeamName Slack workspace (team) name
	TeamName  string    `json:"team_name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// SlackConnectionCreate Create Slack Connection
type SlackConnectionCreate struct {
	// Code OAuth code from Slack authorization
	Code string `json:"code"`

	// RedirectUri Redirect URI that was used when obtaining the OAuth code (required by Slack when exchanging the code)
	RedirectUri *string `json:"redirect_uri,omitempty"`
}

// StartedNotification defines model for StartedNotification.
type StartedNotification struct {
	Status interface{} `json:"status"`
}

// Sync Managed Sync definition
type Sync struct {
	// CPU CPU quota for the sync
	CPU string `json:"cpu"`

	// CreatedAt Time when the sync was created
	CreatedAt time.Time `json:"created_at"`
	CreatedBy *string   `json:"created_by,omitempty"`

	// Destinations List of destinations for the sync
	Destinations []string `json:"destinations"`

	// Disabled Whether the sync is disabled
	Disabled bool `json:"disabled"`

	// DisplayName A human-readable display name
	DisplayName DisplayName `json:"display_name"`

	// Memory Memory quota for the sync
	Memory string `json:"memory"`

	// Name Descriptive, unique name for the sync
	Name string `json:"name"`

	// Schedule Cron schedule for the sync
	Schedule string `json:"schedule"`

	// Source Unique name of the source
	Source string `json:"source"`

	// UpdatedAt Time when the sync was updated
	UpdatedAt time.Time `json:"updated_at"`
}

// SyncCreate Managed Sync definition
type SyncCreate struct {
	// CPU CPU quota for the sync
	CPU          *string  `json:"cpu,omitempty"`
	Destinations []string `json:"destinations"`

	// Disabled Whether the sync is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Memory Memory quota for the sync
	Memory *string `json:"memory,omitempty"`

	// Name Descriptive, unique name for the sync
	Name string `json:"name"`

	// Schedule Cron schedule for the sync
	Schedule *string `json:"schedule,omitempty"`

	// Source Unique name of the source
	Source string `json:"source"`
}

// SyncDestination defines model for SyncDestination.
type SyncDestination struct {
	// CreatedAt Time when the source was created
	CreatedAt time.Time `json:"created_at"`

	// DisplayName A human-readable display name
	DisplayName DisplayName `json:"display_name"`

	// Draft If a sync destination is in draft, it cannot be used in syncs. To get it out of draft, 'promote' it using a successful test connection ID.
	Draft bool `json:"draft"`

	// Env Environment variables for the plugin.
	Env []SyncEnv `json:"env"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource SyncLastUpdateSource `json:"last_update_source"`

	// MigrateMode Migrate mode for the destination
	MigrateMode SyncDestinationMigrateMode `json:"migrate_mode"`

	// Name Descriptive, unique name for the destination
	Name string `json:"name"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// PreviousVersion Previous version of the plugin during a version upgrade
	PreviousVersion *string                `json:"previous_version,omitempty"`
	SendSyncSummary *bool                  `json:"send_sync_summary,omitempty"`
	Spec            map[string]interface{} `json:"spec"`
	SyncGroupID     *string                `json:"sync_group_id,omitempty"`
	Transformers    []string               `json:"transformers"`

	// UpdatedAt Time when the source was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Version Version of the plugin
	Version string `json:"version"`

	// WriteMode Write mode for the destination
	WriteMode SyncDestinationWriteMode `json:"write_mode"`
}

// SyncDestinationCreate Sync Destination Definition
type SyncDestinationCreate struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// MigrateMode Migrate mode for the destination
	MigrateMode *SyncDestinationMigrateMode `json:"migrate_mode,omitempty"`

	// Name Descriptive, unique name for the destination
	Name string `json:"name"`

	// Path Plugin path in CloudQuery registry
	Path            SyncPluginPath          `json:"path"`
	SendSyncSummary *bool                   `json:"send_sync_summary,omitempty"`
	Spec            *map[string]interface{} `json:"spec,omitempty"`
	SyncGroupID     *string                 `json:"sync_group_id,omitempty"`
	Transformers    *[]string               `json:"transformers,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`

	// WriteMode Write mode for the destination
	WriteMode *SyncDestinationWriteMode `json:"write_mode,omitempty"`
}

// SyncDestinationMigrateMode Migrate mode for the destination
type SyncDestinationMigrateMode string

// SyncDestinationMigrateModeUpdate Migrate mode for the destination, for updating
type SyncDestinationMigrateModeUpdate string

// SyncDestinationNameField Descriptive, unique name for the destination
type SyncDestinationNameField = string

// SyncDestinationTestConnection defines model for SyncDestinationTestConnection.
type SyncDestinationTestConnection struct {
	// CompletedAt Time the test connection was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the test connection was created
	CreatedAt time.Time `json:"created_at"`

	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// ID unique ID of the test connection
	ID ID `json:"id"`

	// PluginPath Plugin path in CloudQuery registry
	PluginPath *SyncPluginPath `json:"plugin_path,omitempty"`

	// PluginVersion The version in semantic version format.
	PluginVersion *VersionName `json:"plugin_version,omitempty"`

	// Status The status of the sync run
	Status      SyncTestConnectionStatus `json:"status"`
	SyncGroupID *string                  `json:"sync_group_id,omitempty"`
}

// SyncDestinationTestConnectionCreate defines model for SyncDestinationTestConnectionCreate.
type SyncDestinationTestConnectionCreate struct {
	// DestinationName Name of an existing destination
	DestinationName *string `json:"destination_name,omitempty"`

	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// MigrateMode Migrate mode for the destination
	MigrateMode *SyncDestinationMigrateMode `json:"migrate_mode,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path        SyncPluginPath          `json:"path"`
	Spec        *map[string]interface{} `json:"spec,omitempty"`
	SyncGroupID *string                 `json:"sync_group_id,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`

	// WriteMode Write mode for the destination
	WriteMode *SyncDestinationWriteMode `json:"write_mode,omitempty"`
}

// SyncDestinationTestConnectionID ID of the Sync Destination Test Connection
type SyncDestinationTestConnectionID = openapi_types.UUID

// SyncDestinationTestConnectionV2 defines model for SyncDestinationTestConnectionV2.
type SyncDestinationTestConnectionV2 struct {
	// CompletedAt Time the test connection was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the test connection was created
	CreatedAt time.Time `json:"created_at"`

	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// ID unique ID of the test connection
	ID ID `json:"id"`

	// PluginPath Plugin path in CloudQuery registry
	PluginPath *SyncPluginPath `json:"plugin_path,omitempty"`

	// PluginVersion The version in semantic version format.
	PluginVersion *VersionName `json:"plugin_version,omitempty"`

	// Status The status of the sync run
	Status      SyncTestConnectionStatus `json:"status"`
	SyncGroupID *string                  `json:"sync_group_id,omitempty"`
}

// SyncDestinationUpdate Sync Destination Update Definition
type SyncDestinationUpdate struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// MigrateMode Migrate mode for the destination, for updating
	MigrateMode     *SyncDestinationMigrateModeUpdate `json:"migrate_mode,omitempty"`
	SendSyncSummary *bool                             `json:"send_sync_summary,omitempty"`
	Transformers    *[]string                         `json:"transformers,omitempty"`

	// WriteMode Write mode for the destination, for updating
	WriteMode *SyncDestinationWriteModeUpdate `json:"write_mode,omitempty"`
}

// SyncDestinationUpdateV2 Sync Destination Update Definition
type SyncDestinationUpdateV2 struct {
	// Disabled Whether the sync destination is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// MigrateMode Migrate mode for the destination, for updating
	MigrateMode     *SyncDestinationMigrateModeUpdate `json:"migrate_mode,omitempty"`
	SendSyncSummary *bool                             `json:"send_sync_summary,omitempty"`
	Transformers    *[]string                         `json:"transformers,omitempty"`

	// WriteMode Write mode for the destination, for updating
	WriteMode *SyncDestinationWriteModeUpdate `json:"write_mode,omitempty"`
}

// SyncDestinationV2 defines model for SyncDestinationV2.
type SyncDestinationV2 struct {
	// CreatedAt Time when the source was created
	CreatedAt time.Time `json:"created_at"`

	// Disabled If true, the sync destination is disabled and cannot be used in syncs.
	Disabled bool `json:"disabled"`

	// DisplayName A human-readable display name
	DisplayName DisplayName `json:"display_name"`

	// Draft If a sync destination is in draft, it cannot be used in syncs. To get it out of draft, 'promote' it using a successful test connection ID.
	Draft bool `json:"draft"`

	// Env Environment variables for the plugin.
	Env []SyncEnv `json:"env"`

	// LastRun Managed Sync Run definition
	LastRun *SyncRun `json:"last_run,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource SyncLastUpdateSource `json:"last_update_source"`

	// MigrateMode Migrate mode for the destination
	MigrateMode SyncDestinationMigrateMode `json:"migrate_mode"`

	// Name Descriptive, unique name for the destination
	Name string `json:"name"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// Plugin CloudQuery Plugin
	Plugin *Plugin `json:"plugin,omitempty"`

	// PreviousVersion Previous version of the plugin during a version upgrade
	PreviousVersion *string                `json:"previous_version,omitempty"`
	SendSyncSummary *bool                  `json:"send_sync_summary,omitempty"`
	Spec            map[string]interface{} `json:"spec"`
	SyncGroupID     *string                `json:"sync_group_id,omitempty"`
	Transformers    []string               `json:"transformers"`

	// UpdatedAt Time when the source was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Version Version of the plugin
	Version string `json:"version"`

	// WriteMode Write mode for the destination
	WriteMode SyncDestinationWriteMode `json:"write_mode"`
}

// SyncDestinationWriteMode Write mode for the destination
type SyncDestinationWriteMode string

// SyncDestinationWriteModeUpdate Write mode for the destination, for updating
type SyncDestinationWriteModeUpdate string

// SyncEnv Environment variable. Environment variables are assumed to be secret.
type SyncEnv struct {
	// Name Name of the environment variable
	Name string `json:"name"`
}

// SyncEnvCreate Environment variable. Environment variables are assumed to be secret.
type SyncEnvCreate struct {
	// Name Name of the environment variable
	Name string `json:"name"`

	// Value Value of the environment variable
	Value *string `json:"value,omitempty"`
}

// SyncGenericSortBy defines model for SyncGenericSortBy.
type SyncGenericSortBy string

// SyncIntegrationCreateV2 Create a new sync integration
type SyncIntegrationCreateV2 struct {
	// DestinationNames List of sync destination names associated with this integration
	DestinationNames []SyncDestinationNameField `json:"destination_names"`

	// Disabled Whether the integration is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Name Descriptive, unique name for the integration
	Name string `json:"name"`

	// Schedule Cron schedule for the integration
	Schedule *string `json:"schedule,omitempty"`

	// Source Integration Source Definition
	Source SyncIntegrationSourceCreateV2 `json:"source"`
}

// SyncIntegrationExpandedV2 defines model for SyncIntegrationExpandedV2.
type SyncIntegrationExpandedV2 struct {
	// CreatedAt Time when the sync was created
	CreatedAt *time.Time `json:"created_at,omitempty"`
	CreatedBy *string    `json:"created_by,omitempty"`

	// Destinations List of sync destinations associated with this integration
	Destinations *[]SyncDestinationV2 `json:"destinations,omitempty"`

	// Disabled Whether the integration is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// LastRun Managed Sync List Entry Last Run Info
	LastRun *ListSyncLastRun `json:"last_run,omitempty"`

	// Name Descriptive, unique name for the integration
	Name string `json:"name"`

	// Plugin CloudQuery Plugin
	Plugin *Plugin `json:"plugin,omitempty"`

	// Schedule Cron schedule for the integration
	Schedule *string `json:"schedule,omitempty"`

	// Source Integration Source Definition
	Source *SyncIntegrationSourceV2 `json:"source,omitempty"`

	// UpdatedAt Time when the sync was updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// SyncIntegrationSourceCreateV2 Integration Source Definition
type SyncIntegrationSourceCreateV2 struct {
	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables *[]string `json:"skip_tables,omitempty"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables []string `json:"tables"`

	// TestConnectionID unique ID of the test connection
	TestConnectionID openapi_types.UUID `json:"test_connection_id"`
}

// SyncIntegrationSourceUpdateV2 Integration Definition
type SyncIntegrationSourceUpdateV2 struct {
	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables *[]string `json:"skip_tables,omitempty"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables *[]string `json:"tables,omitempty"`

	// TestConnectionID unique ID of the test connection
	TestConnectionID *openapi_types.UUID `json:"test_connection_id,omitempty"`
}

// SyncIntegrationSourceV2 Integration Source Definition
type SyncIntegrationSourceV2 struct {
	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env []SyncEnv `json:"env"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID *OnboardingID `json:"onboarding_id,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables *[]string              `json:"skip_tables,omitempty"`
	Spec       map[string]interface{} `json:"spec"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables []string `json:"tables"`

	// TestConnectionID unique ID of the test connection
	TestConnectionID *openapi_types.UUID `json:"test_connection_id,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncIntegrationTestConnectionCreateV2 defines model for SyncIntegrationTestConnectionCreateV2.
type SyncIntegrationTestConnectionCreateV2 struct {
	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID *OnboardingID `json:"onboarding_id,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// SourceName Name of an existing source
	SourceName *string                 `json:"source_name,omitempty"`
	Spec       *map[string]interface{} `json:"spec,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncIntegrationTestConnectionV2 defines model for SyncIntegrationTestConnectionV2.
type SyncIntegrationTestConnectionV2 struct {
	// CompletedAt Time the test connection was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the test connection was created
	CreatedAt time.Time `json:"created_at"`

	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// ID unique ID of the test connection
	ID ID `json:"id"`

	// PluginPath Plugin path in CloudQuery registry
	PluginPath *SyncPluginPath `json:"plugin_path,omitempty"`

	// PluginVersion The version in semantic version format.
	PluginVersion *VersionName `json:"plugin_version,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// SyncIntegrationUpdateV2 Update an existing integration
type SyncIntegrationUpdateV2 struct {
	// DestinationNames List of sync destinations associated with this integration
	DestinationNames *[]SyncDestinationNameField `json:"destination_names,omitempty"`

	// Disabled Whether the integration is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Schedule Cron schedule for the integration
	Schedule *string `json:"schedule,omitempty"`

	// Source Integration Definition
	Source *SyncIntegrationSourceUpdateV2 `json:"source,omitempty"`
}

// SyncIntegrationV2 An integration definition
type SyncIntegrationV2 struct {
	// CreatedAt Time when the sync was created
	CreatedAt *time.Time `json:"created_at,omitempty"`
	CreatedBy *string    `json:"created_by,omitempty"`

	// Destinations List of sync destinations associated with this integration
	Destinations *[]SyncDestinationV2 `json:"destinations,omitempty"`

	// Disabled Whether the integration is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Name Descriptive, unique name for the integration
	Name string `json:"name"`

	// Plugin CloudQuery Plugin
	Plugin *Plugin `json:"plugin,omitempty"`

	// Schedule Cron schedule for the integration
	Schedule *string `json:"schedule,omitempty"`

	// Source Integration Source Definition
	Source *SyncIntegrationSourceV2 `json:"source,omitempty"`

	// UpdatedAt Time when the sync was updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// SyncLastUpdateSource How was the source or destination been created or updated last
type SyncLastUpdateSource string

// SyncPluginPath Plugin path in CloudQuery registry
type SyncPluginPath = string

// SyncRun Managed Sync Run definition
type SyncRun struct {
	// CompletedAt Time the sync run was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the sync run was created
	CreatedAt time.Time `json:"created_at"`

	// Errors Number of errors encountered during the sync
	Errors int64 `json:"errors"`

	// ID unique ID of the run
	ID openapi_types.UUID `json:"id"`

	// Ingested Whether the sync run's data has been ingested
	Ingested bool `json:"ingested"`

	// Migration Whether the sync run is a migration
	Migration *bool `json:"migration,omitempty"`

	// Status The status of the sync run
	Status SyncRunStatus `json:"status"`

	// StatusReason The reason for the status
	StatusReason *SyncRunStatusReason `json:"status_reason,omitempty"`

	// SyncName Name of the sync
	SyncName string `json:"sync_name"`

	// TotalRows Total number of rows in the sync
	TotalRows int64 `json:"total_rows"`

	// Warnings Number of warnings encountered during the sync
	Warnings int64 `json:"warnings"`

	// Workers Information about the workers used in the sync run
	Workers *[]SyncRunWorkerStatus `json:"workers,omitempty"`
}

// SyncRunDetails defines model for SyncRunDetails.
type SyncRunDetails struct {
	// CompletedAt Time the sync run was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CPUSeconds Total CPU seconds utilized during this sync run
	CPUSeconds *float64 `json:"cpu_seconds,omitempty"`

	// CreatedAt Time the sync run was created
	CreatedAt time.Time `json:"created_at"`

	// Errors Number of errors encountered during the sync
	Errors int64 `json:"errors"`

	// ID unique ID of the run
	ID openapi_types.UUID `json:"id"`

	// Ingested Whether the sync run's data has been ingested
	Ingested bool `json:"ingested"`

	// MemoryByteSeconds Total memory byte seconds utilized during this sync run
	MemoryByteSeconds *float64 `json:"memory_byte_seconds,omitempty"`

	// Migration Whether the sync run is a migration
	Migration *bool `json:"migration,omitempty"`

	// NetworkEgressBytes Total network egress bytes during this sync run
	NetworkEgressBytes *float64 `json:"network_egress_bytes,omitempty"`

	// Status The status of the sync run
	Status SyncRunStatus `json:"status"`

	// StatusReason The reason for the status
	StatusReason *SyncRunStatusReason `json:"status_reason,omitempty"`

	// SyncName Name of the sync
	SyncName string `json:"sync_name"`

	// TotalRows Total number of rows in the sync
	TotalRows int64 `json:"total_rows"`

	// Warnings Number of warnings encountered during the sync
	Warnings int64 `json:"warnings"`

	// Workers Information about the workers used in the sync run
	Workers *[]SyncRunWorkerStatus `json:"workers,omitempty"`
}

// SyncRunID ID of the SyncRun
type SyncRunID = openapi_types.UUID

// SyncRunStats defines model for SyncRunStats.
type SyncRunStats struct {
	// CompletedTables Number of tables completed
	CompletedTables uint64 `json:"completed_tables"`

	// Errors Number of total errors encountered
	Errors uint64 `json:"errors"`

	// LastCompletedAt Time the last table was completed
	LastCompletedAt *time.Time `json:"last_completed_at,omitempty"`

	// Panics Number of total panics encountered
	Panics uint64 `json:"panics"`

	// Resources Number of total resources fetched
	Resources uint64 `json:"resources"`

	// StartedAt Time the table sync was started
	StartedAt time.Time `json:"started_at"`
}

// SyncRunStatus The status of the sync run
type SyncRunStatus string

// SyncRunStatusReason The reason for the status
type SyncRunStatusReason string

// SyncRunTableProgress Table-specific progress information for a sync run
type SyncRunTableProgress map[string]struct {
	// Errors Number of errors for this table
	Errors int64 `json:"errors"`

	// Rows Number of rows processed for this table
	Rows int64 `json:"rows"`
}

// SyncRunTableSortBy defines model for SyncRunTableSortBy.
type SyncRunTableSortBy string

// SyncRunTableStat defines model for SyncRunTableStat.
type SyncRunTableStat struct {
	// CompletedAt Time the table sync was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// Errors Number of errors encountered
	Errors *uint64 `json:"errors,omitempty"`

	// Name Name of the table
	Name string `json:"name"`

	// Panics Number of panics encountered
	Panics *uint64 `json:"panics,omitempty"`

	// Resources Number of resources fetched
	Resources *uint64 `json:"resources,omitempty"`

	// RuntimeSeconds Number of seconds it took to sync a table
	RuntimeSeconds *int64 `json:"runtime_seconds,omitempty"`

	// ServiceName Name of the service
	ServiceName string `json:"service_name"`

	// StartedAt Time the table sync was started
	StartedAt time.Time `json:"started_at"`
}

// SyncRunWorkerPhase Phase of the worker in the sync run
type SyncRunWorkerPhase string

// SyncRunWorkerStatus The worker information for a sync run
type SyncRunWorkerStatus struct {
	// Phase Phase of the worker in the sync run
	Phase SyncRunWorkerPhase `json:"phase"`

	// Reason The reason for the status of the worker
	Reason *string `json:"reason,omitempty"`
}

// SyncSortBy defines model for SyncSortBy.
type SyncSortBy string

// SyncSortDirection defines model for SyncSortDirection.
type SyncSortDirection string

// SyncSource defines model for SyncSource.
type SyncSource struct {
	// CreatedAt Time when the source was created
	CreatedAt time.Time `json:"created_at"`

	// DisplayName A human-readable display name
	DisplayName DisplayName `json:"display_name"`

	// Draft If a sync source is in draft, it cannot be used in syncs. To get it out of draft, 'promote' it using a successful test connection ID.
	Draft bool `json:"draft"`

	// Env Environment variables for the plugin.
	Env []SyncEnv `json:"env"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource SyncLastUpdateSource `json:"last_update_source"`

	// Name Descriptive, unique name for the source
	Name string `json:"name"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID *OnboardingID `json:"onboarding_id,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// PreviousVersion Previous version of the plugin during a version upgrade
	PreviousVersion *string `json:"previous_version,omitempty"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables []string               `json:"skip_tables"`
	Spec       map[string]interface{} `json:"spec"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables []string `json:"tables"`

	// UpdatedAt Time when the source was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncSourceCreate Sync Source Definition
type SyncSourceCreate struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// Name Descriptive, unique name for the source
	Name string `json:"name"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID *OnboardingID `json:"onboarding_id,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables *[]string               `json:"skip_tables,omitempty"`
	Spec       *map[string]interface{} `json:"spec,omitempty"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables []string `json:"tables"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncSourceTestConnection defines model for SyncSourceTestConnection.
type SyncSourceTestConnection struct {
	// CompletedAt Time the test connection was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the test connection was created
	CreatedAt time.Time `json:"created_at"`

	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// ID unique ID of the test connection
	ID ID `json:"id"`

	// PluginPath Plugin path in CloudQuery registry
	PluginPath *SyncPluginPath `json:"plugin_path,omitempty"`

	// PluginVersion The version in semantic version format.
	PluginVersion *VersionName `json:"plugin_version,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// SyncSourceTestConnectionCreate defines model for SyncSourceTestConnectionCreate.
type SyncSourceTestConnectionCreate struct {
	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// OnboardingID ID of the cloud provider onboarding session
	OnboardingID *OnboardingID `json:"onboarding_id,omitempty"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// SourceName Name of an existing source
	SourceName *string                 `json:"source_name,omitempty"`
	Spec       *map[string]interface{} `json:"spec,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncSourceTestConnectionID ID of the Sync Source Test Connection
type SyncSourceTestConnectionID = openapi_types.UUID

// SyncSourceUpdate Sync Source Update Definition
type SyncSourceUpdate struct {
	// DestinationNames List of sync destination names associated with this source
	DestinationNames *[]SyncDestinationNameField `json:"destination_names,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// SkipTables Tables matched by `tables` that should be skipped. Wildcards are supported.
	SkipTables *[]string `json:"skip_tables,omitempty"`

	// Tables Tables to sync. Wildcards are supported. Note that child tables are excluded by default, and need to be explicitly specified.
	Tables *[]string `json:"tables,omitempty"`
}

// SyncTestConnection defines model for SyncTestConnection.
type SyncTestConnection struct {
	// CompletedAt Time the test connection was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Time the test connection was created
	CreatedAt time.Time `json:"created_at"`

	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// ID unique ID of the test connection
	ID ID `json:"id"`

	// PluginKind The kind of plugin, ie. source or destination.
	PluginKind *PluginKind `json:"plugin_kind,omitempty"`

	// PluginPath Plugin path in CloudQuery registry
	PluginPath *SyncPluginPath `json:"plugin_path,omitempty"`

	// PluginVersion The version in semantic version format.
	PluginVersion *VersionName `json:"plugin_version,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// ID unique ID of the test connection
type ID = openapi_types.UUID

// SyncTestConnectionStatus The status of the sync run
type SyncTestConnectionStatus string

// SyncTransformer defines model for SyncTransformer.
type SyncTransformer struct {
	// CreatedAt Time when the transformer was created
	CreatedAt time.Time `json:"created_at"`

	// DisplayName A human-readable display name
	DisplayName DisplayName `json:"display_name"`

	// Draft If a sync transformer is in draft, it cannot be used in syncs. To get it out of draft, 'promote' it using a successful test connection ID.
	Draft bool `json:"draft"`

	// Env Environment variables for the plugin.
	Env []SyncEnv `json:"env"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource SyncLastUpdateSource `json:"last_update_source"`

	// Name Descriptive, unique name for the transformer
	Name string `json:"name"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath         `json:"path"`
	Spec map[string]interface{} `json:"spec"`

	// UpdatedAt Time when the transformer was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncTransformerCreate Sync Transformer Definition
type SyncTransformerCreate struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Env Environment variables for the plugin. All environment variables will be stored as secrets.
	Env *[]SyncEnvCreate `json:"env,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`

	// Name Descriptive, unique name for the transformer
	Name string `json:"name"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath          `json:"path"`
	Spec *map[string]interface{} `json:"spec,omitempty"`

	// Version Version of the plugin
	Version string `json:"version"`
}

// SyncTransformerUpdate Sync Transformer Update Definition
type SyncTransformerUpdate struct {
	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// LastUpdateSource How was the source or destination been created or updated last
	LastUpdateSource *SyncLastUpdateSource `json:"last_update_source,omitempty"`
}

// SyncUpdate Managed Sync definition
type SyncUpdate struct {
	// CPU CPU quota for the sync
	CPU          *string   `json:"cpu,omitempty"`
	Destinations *[]string `json:"destinations,omitempty"`

	// Disabled Whether the sync is disabled
	Disabled *bool `json:"disabled,omitempty"`

	// DisplayName A human-readable display name
	DisplayName *DisplayName `json:"display_name,omitempty"`

	// Env Environment variables for the sync
	Env *[]SyncEnv `json:"env,omitempty"`

	// Memory Memory quota for the sync
	Memory *string `json:"memory,omitempty"`

	// Schedule Cron schedule for the sync
	Schedule *string `json:"schedule,omitempty"`

	// Source Unique name of the source
	Source *string `json:"source,omitempty"`
}

// SyncUpgrade Sync Version Upgrade Definition
type SyncUpgrade struct {
	// CreatedAt Time when the upgrade record was created
	CreatedAt time.Time `json:"created_at"`

	// Kind The kind of plugin, ie. source or destination.
	Kind PluginKind `json:"kind"`

	// NewVersion Upgraded version of the plugin
	NewVersion string `json:"new_version"`

	// Path Plugin path in CloudQuery registry
	Path SyncPluginPath `json:"path"`

	// PlatformVersion Version of the platform that the upgrade was made on
	PlatformVersion string `json:"platform_version"`

	// PrevVersion Previous version of the plugin
	PrevVersion string `json:"prev_version"`

	// DisplayNames List of sync sources or sync destinations (depending on kind) display names that were upgraded
	DisplayNames []string `json:"sync_source_destination_display_names"`

	// Names List of sync sources or sync destinations (depending on kind) that were upgraded
	Names []string `json:"sync_source_destination_names"`
}

// TableColumnListItem defines model for TableColumnListItem.
type TableColumnListItem struct {
	// Kind The kind of the schema column type
	Kind TableSchemaColumnKind `json:"kind"`

	// Name The name of the table column.
	Name TableColumnName `json:"name"`

	// Nullable Whether the column is nullable.
	Nullable bool `json:"nullable"`
}

// TableColumnName The name of the table column.
type TableColumnName = string

// TableColumnValueListItem defines model for TableColumnValueListItem.
type TableColumnValueListItem struct {
	// Kind The kind of the schema column type
	Kind  TableSchemaColumnKind `json:"kind"`
	Value *string               `json:"value,omitempty"`
}

// TableData defines model for TableData.
type TableData struct {
	Columns []struct {
		Name string `json:"name"`
		Type string `json:"type"`
	} `json:"columns"`

	// Query Query expression
	Query *QueryExpression `json:"query,omitempty"`
	Rows  [][]interface{}  `json:"rows"`
}

// TableDataAction Request body for performing actions on table data
type TableDataAction struct {
	// Action The action to perform on the table data
	Action TableDataActionAction `json:"action"`

	// Syncs Map of sync names to arrays of table names
	Syncs map[string][]string `json:"syncs"`
}

// TableDataActionAction The action to perform on the table data
type TableDataActionAction string

// TableDataListItem Sync with its associated tables
type TableDataListItem struct {
	// DisplayName Human-readable display name of the sync
	DisplayName *string `json:"display_name,omitempty"`

	// Plugin Plugin path in CloudQuery registry
	Plugin *SyncPluginPath `json:"plugin,omitempty"`

	// SyncName The unique name of the sync (source_name from synced_tables)
	SyncName string `json:"sync_name"`

	// Tables List of tables synced by this integration with their deletion status
	Tables []struct {
		// DeletionPending Whether this table's data is marked for deletion
		DeletionPending bool `json:"deletion_pending"`

		// Name The table name
		Name string `json:"name"`
	} `json:"tables"`
}

// TableGroupBy defines model for TableGroupBy.
type TableGroupBy = string

// TableListItem defines model for TableListItem.
type TableListItem struct {
	// Name The name of the table.
	Name TableName `json:"name"`
}

// TableName The name of the table.
type TableName = string

// TableRow defines model for TableRow.
type TableRow map[string]interface{}

// TableRowFieldMatch defines model for TableRowFieldMatch.
type TableRowFieldMatch struct {
	EndIndex   *int64 `json:"end_index,omitempty"`
	Key        string `json:"key"`
	StartIndex *int64 `json:"start_index,omitempty"`
	Value      string `json:"value"`
}

// TableRowID ID of the Resource
type TableRowID = string

// TableSchema defines model for TableSchema.
type TableSchema = []TableSchemaColumn

// TableSchemaColumn defines model for TableSchemaColumn.
type TableSchemaColumn struct {
	// Comment Comment on the column, or an empty string if it is not defined.
	Comment string `json:"comment"`

	// DefaultExpression Expression for the default value, or an empty string if it is not defined.
	DefaultExpression string `json:"default_expression"`

	// DefaultKind Expression type (DEFAULT, MATERIALIZED, ALIAS) for the default value, or an empty string if it is not defined.
	DefaultKind string `json:"default_kind"`

	// Kind The kind of the schema column type
	Kind TableSchemaColumnKind `json:"kind"`

	// Name Column name
	Name string `json:"name"`

	// Nullable Whether the column is nullable.
	Nullable bool `json:"nullable"`

	// Type Column type
	Type string `json:"type"`
}

// TableSchemaColumnKind The kind of the schema column type
type TableSchemaColumnKind string

// TableSelect defines model for TableSelect.
type TableSelect = string

// TableSortBy defines model for TableSortBy.
type TableSortBy = string

// TableSortDirection defines model for TableSortDirection.
type TableSortDirection string

// Team CloudQuery Team
type Team struct {
	// Name The unique name for the team.
	Name TeamName `json:"name"`
}

// TeamName The unique name for the team.
type TeamName = string

// UsageSummary A usage summary for a team, summarizing the paid rows synced and/or cloud resource usage over a given time range.
// Note that empty or all-zero values are not included in the response.
type UsageSummary struct {
	// Groups The groups of the usage summary. Every group will have a corresponding value at the same index in the values array.
	Groups []UsageSummaryGroup `json:"groups"`

	// Metadata Additional metadata about the usage summary. This may include information about the time range, the aggregation period, or other details.
	Metadata struct {
		// AggregationPeriod The aggregation period to sum data over. In other words, data will be returned at this granularity.
		AggregationPeriod UsageSummaryMetadataAggregationPeriod `json:"aggregation_period"`

		// End The exclusive end of the query time range.
		End time.Time `json:"end"`

		// Metrics List of metrics included in the response.
		Metrics []UsageSummaryMetadataMetrics `json:"metrics"`

		// Start The inclusive start of the query time range.
		Start time.Time `json:"start"`
	} `json:"metadata"`
	Values []UsageSummaryValue `json:"values"`
}

// UsageSummaryMetadataAggregationPeriod The aggregation period to sum data over. In other words, data will be returned at this granularity.
type UsageSummaryMetadataAggregationPeriod string

// UsageSummaryMetadataMetrics defines model for UsageSummary.Metadata.Metrics.
type UsageSummaryMetadataMetrics string

// UsageSummaryGroup A usage summary group.
type UsageSummaryGroup struct {
	// Name The name of the group.
	Name string `json:"name"`

	// Value The value of the group at this index.
	Value string `json:"value"`
}

// UsageSummaryValue A usage summary value.
type UsageSummaryValue struct {
	// CloudEgressBytes Egress bytes consumed in this period, one per group.
	CloudEgressBytes *[]int64 `json:"cloud_egress_bytes,omitempty"`

	// CloudVcpuSeconds vCPU/seconds consumed in this period, one per group.
	CloudVcpuSeconds *[]int64 `json:"cloud_vcpu_seconds,omitempty"`

	// CloudVramByteSeconds vRAM/byte-seconds consumed in this period, one per group.
	CloudVramByteSeconds *[]int64 `json:"cloud_vram_byte_seconds,omitempty"`

	// PaidRows The paid rows that were synced in this period, one per group.
	PaidRows *[]int64 `json:"paid_rows,omitempty"`

	// Timestamp The timestamp marking the start of a period.
	Timestamp time.Time `json:"timestamp"`
}

// User User
type User struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Email     string     `json:"email"`

	// Enabled Whether the user is enabled
	Enabled bool `json:"enabled"`

	// ID ID of the User
	ID          openapi_types.UUID `json:"id"`
	LastLoginAt *time.Time         `json:"last_login_at,omitempty"`

	// MFAConfigured Whether the user has MFA configured
	MFAConfigured bool `json:"mfa_configured"`

	// Name The unique name for the user.
	Name *UserName `json:"name,omitempty"`

	// ProfileImageURL Profile image URL of user
	ProfileImageURL *string      `json:"profile_image_url,omitempty"`
	Provider        UserProvider `json:"provider"`
	Roles           []Role       `json:"roles"`

	// TrackingOptedIn Whether anonymous user tracking was opted into
	TrackingOptedIn *bool      `json:"tracking_opted_in,omitempty"`
	UpdatedAt       *time.Time `json:"updated_at,omitempty"`
}

// UserID ID of the User
type UserID = openapi_types.UUID

// UserName The unique name for the user.
type UserName = string

// UserProvider defines model for UserProvider.
type UserProvider string

// VersionFilter A version filter in semantic version format with prefix ranges.
type VersionFilter = string

// VersionName The version in semantic version format.
type VersionName = string

// ViolationsByDomain Violations grouped by domain
type ViolationsByDomain struct {
	Items []ViolationsByDomainItem `json:"items"`

	// TotalViolations Total violations across all domains
	TotalViolations int `json:"total_violations"`
}

// ViolationsByDomainItem Violation count for a specific domain
type ViolationsByDomainItem struct {
	// PolicyDomain Policy domain
	PolicyDomain PolicyDomain `json:"domain"`

	// ViolationCount Number of violations for this domain
	ViolationCount int `json:"violation_count"`
}

// ViolationsHistory Violations history over time
type ViolationsHistory struct {
	Items []ViolationsHistoryItem `json:"items"`

	// Metadata Metadata for violations history query
	Metadata ViolationsHistoryMetadata `json:"metadata"`
}

// ViolationsHistoryItem Violation count for a specific date
type ViolationsHistoryItem struct {
	// Date Date of the violations
	Date openapi_types.Date `json:"date"`

	// ViolationCount Number of violations on this date
	ViolationCount int `json:"violation_count"`
}

// ViolationsHistoryMetadata Metadata for violations history query
type ViolationsHistoryMetadata struct {
	// EndDate End date of the query range
	EndDate openapi_types.Date `json:"end_date"`

	// Interval Interval in days used for grouping
	Interval string `json:"interval"`

	// StartDate Start date of the query range
	StartDate openapi_types.Date `json:"start_date"`
}

// AlertConfigured defines model for alert_configured.
type AlertConfigured = bool

// AlertEnabled defines model for alert_enabled.
type AlertEnabled = bool

// AlertMessageFilter Filter by alert message.
type AlertMessageFilter = string

// AlertStates defines model for alert_states.
type AlertStates = []AlertState

// ColumnName The name of a table column.
type ColumnName = string

// ConversationID defines model for conversation_id.
type ConversationID = openapi_types.UUID

// CustomColumnSortBys defines model for custom_columns_sort_bys.
type CustomColumnSortBys = []CustomColumnSortBy

// CustomColumnSortDirections defines model for custom_columns_sort_dirs.
type CustomColumnSortDirections = []CustomColumnSortDirection

// DownloadFile defines model for download_file.
type DownloadFile = bool

// Enabled defines model for enabled.
type Enabled = bool

// FilterExpressionFilter Filter by filter expression
type FilterExpressionFilter = string

// FilterNameFilter Filter by filter name
type FilterNameFilter = string

// FilterTags defines model for filter_tags.
type FilterTags = []FilterTag

// IncludeDrafts defines model for include_drafts.
type IncludeDrafts = bool

// IncludeFips defines model for include_fips.
type IncludeFips = bool

// IncludePrereleases defines model for include_prereleases.
type IncludePrereleases = bool

// MigrationFilter Filter by migration
type MigrationFilter = bool

// NotificationDestinationId The unique ID for the notification destination.
type NotificationDestinationId = NotificationDestinationID

// Page defines model for page.
type Page = int64

// PerPage defines model for per_page.
type PerPage = int64

// PluginExcludeReleaseStages defines model for plugin_exclude_release_stages.
type PluginExcludeReleaseStages = []PluginReleaseStage

// PluginIncludeReleaseStages defines model for plugin_include_release_stages.
type PluginIncludeReleaseStages = []PluginReleaseStage

// PluginSortBy defines model for plugin_sort_by.
type PluginSortBy string

// PluginTeam The unique name for the team.
type PluginTeam = TeamName

// QueryFilter Filter by query
type QueryFilter = string

// QueryNameFilter Filter by query name.
type QueryNameFilter = string

// QueryTags defines model for query_tags.
type QueryTags = []QueryTag

// RBACPermissionSortBys defines model for rbac_permissions_sort_bys.
type RBACPermissionSortBys = []RBACPermissionSortBy

// RBACPermissionSortDirections defines model for rbac_permissions_sort_dirs.
type RBACPermissionSortDirections = []RBACPermissionSortDirection

// RBACRoleSortBys defines model for rbac_roles_sort_bys.
type RBACRoleSortBys = []RBACRoleSortBy

// RBACRoleSortDirections defines model for rbac_roles_sort_dirs.
type RBACRoleSortDirections = []RBACRoleSortDirection

// ReportSortBys defines model for report_sort_bys.
type ReportSortBys = []ReportSortBy

// ReportSortDirections defines model for report_sort_dirs.
type ReportSortDirections = []ReportSortDirection

// ReportTemplateSortBys defines model for report_templates_sort_bys.
type ReportTemplateSortBys = []ReportTemplateSortBy

// ReportTemplateSortDirections defines model for report_templates_sort_dirs.
type ReportTemplateSortDirections = []ReportTemplateSortDirection

// SyncDestinationName Unique name of the sync destination
type SyncDestinationName = string

// SyncGenericSortBys defines model for sync_generic_sort_bys.
type SyncGenericSortBys = []SyncGenericSortBy

// SyncName Unique name of the sync
type SyncName = string

// SyncNameFilter Filter by name or display name
type SyncNameFilter = string

// SyncRunId ID of the SyncRun
type SyncRunId = SyncRunID

// SyncRunTableSortBys defines model for sync_run_table_sort_bys.
type SyncRunTableSortBys = []SyncRunTableSortBy

// SyncSortBys defines model for sync_sort_bys.
type SyncSortBys = []SyncSortBy

// SyncSortDirections defines model for sync_sort_dirs.
type SyncSortDirections = []SyncSortDirection

// SyncSourceName Unique name of the sync source
type SyncSourceName = string

// SyncTestConnectionId unique ID of the test connection
type SyncTestConnectionId = ID

// SyncTransformerName Unique name of the sync transformer
type SyncTransformerName = string

// SyncUpgradesKindFilter The kind of plugin, ie. source or destination.
type SyncUpgradesKindFilter = PluginKind

// SyncUpgradesPathFilter Plugin path in CloudQuery registry
type SyncUpgradesPathFilter = SyncPluginPath

// SyncUpgradesPlatformVersionFilter Filter by platform version
type SyncUpgradesPlatformVersionFilter = string

// SyncUpgradesSortBys defines model for sync_upgrades_sort_bys.
type SyncUpgradesSortBys = []string

// TableColumnNameFilter Filter by column name
type TableColumnNameFilter = string

// TableColumnValueFilter Filter by column value.
type TableColumnValueFilter = string

// FilterIDs defines model for table_filter_ids.
type FilterIDs = []FilterID

// TableFilterMode defines model for table_filter_mode.
type TableFilterMode string

// Filters defines model for table_filters.
type Filters = []FilterExpression

// GroupBys defines model for table_group_bys.
type GroupBys = []TableGroupBy

// TableRowId ID of the Resource
type TableRowId = TableRowID

// Selects defines model for table_selects.
type Selects = []TableSelect

// SortBys defines model for table_sort_bys.
type SortBys = []TableSortBy

// SortDirections defines model for table_sort_dirs.
type SortDirections = []TableSortDirection

// TargetName defines model for target_name.
type TargetName = string

// VersionSortBy defines model for version_sort_by.
type VersionSortBy string

// BadRequest defines model for BadRequest.
type BadRequest = FieldError

// Forbidden defines model for Forbidden.
type Forbidden = FieldError

// InternalError Basic Error
type InternalError = BasicError

// MethodNotAllowed Basic Error
type MethodNotAllowed = BasicError

// NotFound Basic Error
type NotFound = BasicError

// RequiresAuthentication Basic Error
type RequiresAuthentication = BasicError

// ServiceUnavailable Basic Error
type ServiceUnavailable = BasicError

// TooManyRequests Basic Error
type TooManyRequests = BasicError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = FieldError

// ListAllAlertsParams defines parameters for ListAllAlerts.
type ListAllAlertsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// AlertStates Alert states
	AlertStates AlertStates `form:"state,omitempty" json:"state,omitempty"`

	// Enabled Enabled
	Enabled *Enabled `form:"enabled,omitempty" json:"enabled,omitempty"`

	// QueryTags Query tags
	QueryTags QueryTags `form:"tag,omitempty" json:"tag,omitempty"`
}

// TestUnsavedAlertParams defines parameters for TestUnsavedAlert.
type TestUnsavedAlertParams struct {
	// QueryID ID of the query to fill in the alert
	QueryID *QueryID `form:"query_id,omitempty" json:"query_id,omitempty"`
}

// ListAPIKeysParams defines parameters for ListAPIKeys.
type ListAPIKeysParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// CreateAPIKeyJSONBody defines parameters for CreateAPIKey.
type CreateAPIKeyJSONBody struct {
	ExpiresAt time.Time `json:"expires_at"`

	// Name Name of the API key
	Name  APIKeyName `json:"name"`
	Roles *[]RoleID  `json:"roles,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// UserId Filter by user ID
	UserId *openapi_types.UUID `form:"user_id,omitempty" json:"user_id,omitempty"`

	// EventType Filter by event type
	EventType *string `form:"event_type,omitempty" json:"event_type,omitempty"`

	// EntityDisplayName Filter by entity display name
	EntityDisplayName *string `form:"entity_display_name,omitempty" json:"entity_display_name,omitempty"`

	// UserIpAddress Filter by user IP address
	UserIpAddress *string `form:"user_ip_address,omitempty" json:"user_ip_address,omitempty"`

	// StartTime Filter by start time (inclusive)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime Filter by end time (inclusive)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Search Search across user name, event type, entity display name, and user IP address
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListAllCustomColumnsParams defines parameters for ListAllCustomColumns.
type ListAllCustomColumnsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// CustomColumnSortBys Sort by options
	CustomColumnSortBys CustomColumnSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// CustomColumnSortDirections Custom column sort direction options
	CustomColumnSortDirections CustomColumnSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`

	// SearchTerm Filter columns by name, label, or description.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
}

// ListFiltersParams defines parameters for ListFilters.
type ListFiltersParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// FilterTags Filter tags
	FilterTags       *FilterTags             `form:"tag,omitempty" json:"tag,omitempty"`
	NameFilter       *FilterNameFilter       `form:"name_filter,omitempty" json:"name_filter,omitempty"`
	ExpressionFilter *FilterExpressionFilter `form:"expression_filter,omitempty" json:"expression_filter,omitempty"`
}

// ListFilterTagsParams defines parameters for ListFilterTags.
type ListFilterTagsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListNotificationsParams defines parameters for ListNotifications.
type ListNotificationsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Severities Filter by policy severities (policy matches any)
	Severities *[]PolicySeverity `form:"severities,omitempty" json:"severities,omitempty"`

	// PolicyGroupIds Filter by policy groups (policy matches any)
	PolicyGroupIds *[]PolicyGroupID `form:"policy_group_ids,omitempty" json:"policy_group_ids,omitempty"`
}

// GetNotificationDestinationAlertsParams defines parameters for GetNotificationDestinationAlerts.
type GetNotificationDestinationAlertsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListAllNotificationDestinationsParams defines parameters for ListAllNotificationDestinations.
type ListAllNotificationDestinationsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// CreateAWSOnboardingJSONBody defines parameters for CreateAWSOnboarding.
type CreateAWSOnboardingJSONBody struct {
	// SingleAccount Specifies the type of onboarding to create: either a single account onboarding or an organization onboarding
	SingleAccount bool `json:"single_account"`
}

// ListPlatformVersionsParams defines parameters for ListPlatformVersions.
type ListPlatformVersionsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPluginsParams defines parameters for ListPlugins.
type ListPluginsParams struct {
	// SortBy The field to sort by
	SortBy *ListPluginsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeReleaseStages Include these release stages in the response
	IncludeReleaseStages *PluginIncludeReleaseStages `form:"include_release_stages,omitempty" json:"include_release_stages,omitempty"`

	// ExcludeReleaseStages Exclude these release stages from the response
	ExcludeReleaseStages *PluginExcludeReleaseStages `form:"exclude_release_stages,omitempty" json:"exclude_release_stages,omitempty"`
}

// ListPluginsParamsSortBy defines parameters for ListPlugins.
type ListPluginsParamsSortBy string

// ListPluginVersionsParams defines parameters for ListPluginVersions.
type ListPluginVersionsParams struct {
	// SortBy The field to sort by
	SortBy *ListPluginVersionsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeDrafts Whether to include draft versions
	IncludeDrafts *IncludeDrafts `form:"include_drafts,omitempty" json:"include_drafts,omitempty"`

	// IncludeFips Whether to include fips versions
	IncludeFips *IncludeFips `form:"include_fips,omitempty" json:"include_fips,omitempty"`

	// IncludePrereleases Whether to include prerelease versions
	IncludePrereleases *IncludePrereleases `form:"include_prereleases,omitempty" json:"include_prereleases,omitempty"`
	VersionFilter      *VersionFilter      `form:"version_filter,omitempty" json:"version_filter,omitempty"`
}

// ListPluginVersionsParamsSortBy defines parameters for ListPluginVersions.
type ListPluginVersionsParamsSortBy string

// DownloadPluginAssetParams defines parameters for DownloadPluginAsset.
type DownloadPluginAssetParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// ListPluginVersionTablesParams defines parameters for ListPluginVersionTables.
type ListPluginVersionTablesParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page         *Page         `form:"page,omitempty" json:"page,omitempty"`
	PolicyStatus *PolicyStatus `form:"status,omitempty" json:"status,omitempty"`

	// Severities Filter by severities (policy matches any)
	Severities *[]PolicySeverity `form:"severities,omitempty" json:"severities,omitempty"`

	// Domain Filter by domain
	Domain *PolicyDomain `form:"domain,omitempty" json:"domain,omitempty"`

	// PolicyGroupIds Filter by policy groups (policy matches any)
	PolicyGroupIds *[]PolicyGroupID `form:"policy_group_ids,omitempty" json:"policy_group_ids,omitempty"`

	// Search Search in policy name and description
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// SortBy Field to sort by
	SortBy *ListPoliciesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDir Sort direction
	SortDir *ListPoliciesParamsSortDir `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListPoliciesParamsSortBy defines parameters for ListPolicies.
type ListPoliciesParamsSortBy string

// ListPoliciesParamsSortDir defines parameters for ListPolicies.
type ListPoliciesParamsSortDir string

// GetPolicyMetricsParams defines parameters for GetPolicyMetrics.
type GetPolicyMetricsParams struct {
	// Severities Filter by severities (policy matches any)
	Severities *[]PolicySeverity `form:"severities,omitempty" json:"severities,omitempty"`

	// Domain Filter by domain
	Domain *PolicyDomain `form:"domain,omitempty" json:"domain,omitempty"`

	// PolicyGroupIds Filter by policy groups (policy matches any)
	PolicyGroupIds *[]PolicyGroupID `form:"policy_group_ids,omitempty" json:"policy_group_ids,omitempty"`
}

// GetViolationsByDomainParams defines parameters for GetViolationsByDomain.
type GetViolationsByDomainParams struct {
	// Severities Filter by severities (policy matches any)
	Severities *[]PolicySeverity `form:"severities,omitempty" json:"severities,omitempty"`

	// Domain Filter by domain
	Domain *PolicyDomain `form:"domain,omitempty" json:"domain,omitempty"`

	// PolicyGroupIds Filter by policy groups (policy matches any)
	PolicyGroupIds *[]PolicyGroupID `form:"policy_group_ids,omitempty" json:"policy_group_ids,omitempty"`
}

// GetViolationsHistoryParams defines parameters for GetViolationsHistory.
type GetViolationsHistoryParams struct {
	// StartDate Start date for the query range (YYYY-MM-DD)
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate End date for the query range (YYYY-MM-DD)
	EndDate *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`

	// Severities Filter by severities (policy matches any)
	Severities *[]PolicySeverity `form:"severities,omitempty" json:"severities,omitempty"`

	// Domain Filter by domain
	Domain *PolicyDomain `form:"domain,omitempty" json:"domain,omitempty"`

	// PolicyGroupIds Filter by policy groups (policy matches any)
	PolicyGroupIds *[]PolicyGroupID `form:"policy_group_ids,omitempty" json:"policy_group_ids,omitempty"`
}

// GetPolicyViolationsParams defines parameters for GetPolicyViolations.
type GetPolicyViolationsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Search Text search term to filter violations by resource_type_label, name, account_name, cloud, or region
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// GetPolicyViolationsHistoryParams defines parameters for GetPolicyViolationsHistory.
type GetPolicyViolationsHistoryParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page      *Page      `form:"page,omitempty" json:"page,omitempty"`
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime   *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// ListPolicyGroupsParams defines parameters for ListPolicyGroups.
type ListPolicyGroupsParams struct {
	// Search Search in policy group name and description
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Severities Filter to policy groups that contain at least one policy with any of these severities
	Severities *[]PolicySeverity `form:"severities,omitempty" json:"severities,omitempty"`
}

// ListPoliciesInGroupParams defines parameters for ListPoliciesInGroup.
type ListPoliciesInGroupParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SortBy Field to sort by
	SortBy *ListPoliciesInGroupParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDir Sort direction
	SortDir *ListPoliciesInGroupParamsSortDir `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListPoliciesInGroupParamsSortBy defines parameters for ListPoliciesInGroup.
type ListPoliciesInGroupParamsSortBy string

// ListPoliciesInGroupParamsSortDir defines parameters for ListPoliciesInGroup.
type ListPoliciesInGroupParamsSortDir string

// ListAllQueriesParams defines parameters for ListAllQueries.
type ListAllQueriesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// QueryTags Query tags
	QueryTags   QueryTags        `form:"tag,omitempty" json:"tag,omitempty"`
	NameFilter  *QueryNameFilter `form:"name_filter,omitempty" json:"name_filter,omitempty"`
	QueryFilter *QueryFilter     `form:"query_filter,omitempty" json:"query_filter,omitempty"`

	// AlertConfigured Alert configured
	AlertConfigured    *AlertConfigured    `form:"alert_configured,omitempty" json:"alert_configured,omitempty"`
	AlertMessageFilter *AlertMessageFilter `form:"alert_message_filter,omitempty" json:"alert_message_filter,omitempty"`

	// AlertEnabled Alert enabled
	AlertEnabled *AlertEnabled `form:"alert_enabled,omitempty" json:"alert_enabled,omitempty"`
}

// ExecuteAdHocQueryJSONBody defines parameters for ExecuteAdHocQuery.
type ExecuteAdHocQueryJSONBody struct {
	Query string `json:"query"`
}

// ExecuteAdHocQueryParams defines parameters for ExecuteAdHocQuery.
type ExecuteAdHocQueryParams struct {
	// Selects Table selects. This filters the columns that are returned in the result set.
	Selects Selects `form:"select,omitempty" json:"select,omitempty"`

	// FilterMode Table filter mode.
	//
	// Smart mode switches between column and search mode based on the filtered table and
	//
	// Search mode allows searching deeply nested data but is not available on all tables as it requires a separate indexing step.
	// Search mode is only available on resource tables or queries derived from resource tables results that contain _cq_id and _cq_source_id.
	// Search mode may also be used against cloud_assets but it will only return results from resource tables.
	//
	// Column mode searches purely using the columns in the table.
	// It will work on all table results but it is not optimized for arbitrary substring searches and so may be slow on larger tables.
	FilterMode *ExecuteAdHocQueryParamsFilterMode `form:"filter_mode,omitempty" json:"filter_mode,omitempty"`

	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// FilterIDs Table filter IDs. These should be valid Saved Filter IDs. These filters
	// will be applied to the query results before returning them.
	FilterIDs FilterIDs `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// SortBys Table sort by options. This sorts the rows that are returned in the result set.
	SortBys SortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirections Table sort direction options. This sorts the rows that are returned in the result set.
	SortDirections SortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`

	// GroupBys Table group by options. This groups the rows that are returned in the result set by the given columns.
	GroupBys GroupBys `form:"group_by,omitempty" json:"group_by,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ExecuteAdHocQueryParamsFilterMode defines parameters for ExecuteAdHocQuery.
type ExecuteAdHocQueryParamsFilterMode string

// ListQueryTagsParams defines parameters for ListQueryTags.
type ListQueryTagsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ExecuteSavedQueryParams defines parameters for ExecuteSavedQuery.
type ExecuteSavedQueryParams struct {
	// Selects Table selects. This filters the columns that are returned in the result set.
	Selects Selects `form:"select,omitempty" json:"select,omitempty"`

	// FilterMode Table filter mode.
	//
	// Smart mode switches between column and search mode based on the filtered table and
	//
	// Search mode allows searching deeply nested data but is not available on all tables as it requires a separate indexing step.
	// Search mode is only available on resource tables or queries derived from resource tables results that contain _cq_id and _cq_source_id.
	// Search mode may also be used against cloud_assets but it will only return results from resource tables.
	//
	// Column mode searches purely using the columns in the table.
	// It will work on all table results but it is not optimized for arbitrary substring searches and so may be slow on larger tables.
	FilterMode *ExecuteSavedQueryParamsFilterMode `form:"filter_mode,omitempty" json:"filter_mode,omitempty"`

	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// FilterIDs Table filter IDs. These should be valid Saved Filter IDs. These filters
	// will be applied to the query results before returning them.
	FilterIDs FilterIDs `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// SortBys Table sort by options. This sorts the rows that are returned in the result set.
	SortBys SortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirections Table sort direction options. This sorts the rows that are returned in the result set.
	SortDirections SortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`

	// GroupBys Table group by options. This groups the rows that are returned in the result set by the given columns.
	GroupBys GroupBys `form:"group_by,omitempty" json:"group_by,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ExecuteSavedQueryParamsFilterMode defines parameters for ExecuteSavedQuery.
type ExecuteSavedQueryParamsFilterMode string

// QueryListFiltersParams defines parameters for QueryListFilters.
type QueryListFiltersParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// FilterTags Filter tags
	FilterTags *FilterTags `form:"tag,omitempty" json:"tag,omitempty"`
}

// QueryListFilterTagsParams defines parameters for QueryListFilterTags.
type QueryListFilterTagsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListAllRBACPermissionsParams defines parameters for ListAllRBACPermissions.
type ListAllRBACPermissionsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// RBACPermissionSortBys Sort by options
	RBACPermissionSortBys RBACPermissionSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// RBACPermissionSortDirections Sort direction options
	RBACPermissionSortDirections RBACPermissionSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`

	// SearchTerm Filter permissions by name or description.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
}

// ListAllRBACRolesParams defines parameters for ListAllRBACRoles.
type ListAllRBACRolesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// RBACRoleSortBys Sort by options
	RBACRoleSortBys RBACRoleSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// RBACRoleSortDirections Sort direction options
	RBACRoleSortDirections RBACRoleSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`

	// SearchTerm Filter roles by name or description.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// Type Filter roles by type.
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// ListReportsParams defines parameters for ListReports.
type ListReportsParams struct {
	// SearchTerm Filter reports by title or description.
	SearchTerm *string                      `form:"search_term,omitempty" json:"search_term,omitempty"`
	Visibility *ListReportsParamsVisibility `form:"visibility,omitempty" json:"visibility,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// ReportSortBys Sort by options
	ReportSortBys ReportSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// ReportSortDirections Report sort direction options
	ReportSortDirections ReportSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListReportsParamsVisibility defines parameters for ListReports.
type ListReportsParamsVisibility string

// ListReportTemplatesParams defines parameters for ListReportTemplates.
type ListReportTemplatesParams struct {
	// SearchTerm Filter report templates by name.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// ReportTemplateSortBys Sort by options
	ReportTemplateSortBys ReportTemplateSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// ReportTemplateSortDirections Report template sort direction options
	ReportTemplateSortDirections ReportTemplateSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListSlackChannelsParams defines parameters for ListSlackChannels.
type ListSlackChannelsParams struct {
	// Name Filter channels by name (case-insensitive partial match)
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// UpdateSyncTestConnectionForSyncDestinationJSONBody defines parameters for UpdateSyncTestConnectionForSyncDestination.
type UpdateSyncTestConnectionForSyncDestinationJSONBody struct {
	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// GetSyncDestinationTestConnectionLogsLiveParams defines parameters for GetSyncDestinationTestConnectionLogsLive.
type GetSyncDestinationTestConnectionLogsLiveParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// GetSyncDestinationTestConnectionLogsQueryParams defines parameters for GetSyncDestinationTestConnectionLogsQuery.
type GetSyncDestinationTestConnectionLogsQueryParams struct {
	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Download Whether to generate a downloadable file for the response.
	Download *DownloadFile `form:"download,omitempty" json:"download,omitempty"`
	Accept   *string       `json:"Accept,omitempty"`
}

// ListSyncDestinationsParams defines parameters for ListSyncDestinations.
type ListSyncDestinationsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page   *Page           `form:"page,omitempty" json:"page,omitempty"`
	Filter *SyncNameFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SyncGenericSortBys Sort by options
	SyncGenericSortBys SyncGenericSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListSyncDestinationSyncsParams defines parameters for ListSyncDestinationSyncs.
type ListSyncDestinationSyncsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SyncSortBys Sort by options
	SyncSortBys SyncSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
	Filter             *SyncNameFilter    `form:"filter,omitempty" json:"filter,omitempty"`
	MigrationFilter    *MigrationFilter   `form:"migration_filter,omitempty" json:"migration_filter,omitempty"`
}

// UpdateSyncTestConnectionForSyncSourceJSONBody defines parameters for UpdateSyncTestConnectionForSyncSource.
type UpdateSyncTestConnectionForSyncSourceJSONBody struct {
	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// GetSyncSourceTestConnectionLogsLiveParams defines parameters for GetSyncSourceTestConnectionLogsLive.
type GetSyncSourceTestConnectionLogsLiveParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// GetSyncSourceTestConnectionLogsQueryParams defines parameters for GetSyncSourceTestConnectionLogsQuery.
type GetSyncSourceTestConnectionLogsQueryParams struct {
	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Download Whether to generate a downloadable file for the response.
	Download *DownloadFile `form:"download,omitempty" json:"download,omitempty"`
	Accept   *string       `json:"Accept,omitempty"`
}

// ListSyncSourcesParams defines parameters for ListSyncSources.
type ListSyncSourcesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page   *Page           `form:"page,omitempty" json:"page,omitempty"`
	Filter *SyncNameFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SyncGenericSortBys Sort by options
	SyncGenericSortBys SyncGenericSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListSyncSourceSyncsParams defines parameters for ListSyncSourceSyncs.
type ListSyncSourceSyncsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SyncSortBys Sort by options
	SyncSortBys SyncSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
	Filter             *SyncNameFilter    `form:"filter,omitempty" json:"filter,omitempty"`
	MigrationFilter    *MigrationFilter   `form:"migration_filter,omitempty" json:"migration_filter,omitempty"`
}

// ListSyncTransformersParams defines parameters for ListSyncTransformers.
type ListSyncTransformersParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page   *Page           `form:"page,omitempty" json:"page,omitempty"`
	Filter *SyncNameFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SyncGenericSortBys Sort by options
	SyncGenericSortBys SyncGenericSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListSyncTransformerSyncDestinationsParams defines parameters for ListSyncTransformerSyncDestinations.
type ListSyncTransformerSyncDestinationsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListSyncTransformerSyncsParams defines parameters for ListSyncTransformerSyncs.
type ListSyncTransformerSyncsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListSyncUpgradesParams defines parameters for ListSyncUpgrades.
type ListSyncUpgradesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SyncUpgradesSortBys Sort by options
	SyncUpgradesSortBys SyncUpgradesSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections                 `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
	Path               *SyncUpgradesPathFilter            `form:"path,omitempty" json:"path,omitempty"`
	Kind               *SyncUpgradesKindFilter            `form:"kind,omitempty" json:"kind,omitempty"`
	PlatformVersion    *SyncUpgradesPlatformVersionFilter `form:"platform_version,omitempty" json:"platform_version,omitempty"`
}

// ListSyncUpgradesParamsSortBy defines parameters for ListSyncUpgrades.
type ListSyncUpgradesParamsSortBy string

// ListSyncsParams defines parameters for ListSyncs.
type ListSyncsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SyncSortBys Sort by options
	SyncSortBys SyncSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
	Filter             *SyncNameFilter    `form:"filter,omitempty" json:"filter,omitempty"`
	MigrationFilter    *MigrationFilter   `form:"migration_filter,omitempty" json:"migration_filter,omitempty"`
}

// ListSyncRunsParams defines parameters for ListSyncRuns.
type ListSyncRunsParams struct {
	MigrationFilter *MigrationFilter `form:"migration_filter,omitempty" json:"migration_filter,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// UpdateSyncRunJSONBody defines parameters for UpdateSyncRun.
type UpdateSyncRunJSONBody struct {
	// Status The status of the sync run
	Status *SyncRunStatus `json:"status,omitempty"`

	// StatusReason The reason for the status
	StatusReason *SyncRunStatusReason `json:"status_reason,omitempty"`
}

// GetSyncRunLogsLiveParams defines parameters for GetSyncRunLogsLive.
type GetSyncRunLogsLiveParams struct {
	Table  *string `form:"table,omitempty" json:"table,omitempty"`
	Accept *string `json:"Accept,omitempty"`
}

// GetSyncRunLogsQueryParams defines parameters for GetSyncRunLogsQuery.
type GetSyncRunLogsQueryParams struct {
	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Download Whether to generate a downloadable file for the response.
	Download *DownloadFile `form:"download,omitempty" json:"download,omitempty"`
	Accept   *string       `json:"Accept,omitempty"`
}

// CreateSyncRunProgressJSONBody defines parameters for CreateSyncRunProgress.
type CreateSyncRunProgressJSONBody struct {
	// Errors Number of errors encountered so far
	Errors int64 `json:"errors"`

	// Rows Number of rows synced so far
	Rows int64 `json:"rows"`

	// ShardNum The shard number that this progress update is for
	ShardNum *int32 `json:"shard_num,omitempty"`

	// ShardTotal The total number of shards for this sync run
	ShardTotal *int32 `json:"shard_total,omitempty"`

	// Status The status of the sync run
	Status *SyncRunStatus `json:"status,omitempty"`

	// TableProgress Table-specific progress information for a sync run
	TableProgress *SyncRunTableProgress `json:"table_progress,omitempty"`

	// Warnings Number of warnings encountered so far
	Warnings int64 `json:"warnings"`
}

// GetSyncRunTablesParams defines parameters for GetSyncRunTables.
type GetSyncRunTablesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SyncRunTableSortBys Sync run table sort by options. This sorts the rows that are returned in the result set.
	SyncRunTableSortBys SyncRunTableSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirections Table sort direction options. This sorts the rows that are returned in the result set.
	SortDirections SortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetTablesDataParams defines parameters for GetTablesData.
type GetTablesDataParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// BatchTableSchemasParams defines parameters for BatchTableSchemas.
type BatchTableSchemasParams struct {
	// Tables A list of table names to retrieve schemas for
	Tables []string `form:"tables" json:"tables"`
}

// TableListColumnsParams defines parameters for TableListColumns.
type TableListColumnsParams struct {
	// FilterMode Table filter mode.
	//
	// Smart mode switches between column and search mode based on the filtered table and
	//
	// Search mode allows searching deeply nested data but is not available on all tables as it requires a separate indexing step.
	// Search mode is only available on resource tables or queries derived from resource tables results that contain _cq_id and _cq_source_id.
	// Search mode may also be used against cloud_assets but it will only return results from resource tables.
	//
	// Column mode searches purely using the columns in the table.
	// It will work on all table results but it is not optimized for arbitrary substring searches and so may be slow on larger tables.
	FilterMode *TableListColumnsParamsFilterMode `form:"filter_mode,omitempty" json:"filter_mode,omitempty"`
	Filter     *TableColumnNameFilter            `form:"filter,omitempty" json:"filter,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// TableListColumnsParamsFilterMode defines parameters for TableListColumns.
type TableListColumnsParamsFilterMode string

// TableColumnListValuesParams defines parameters for TableColumnListValues.
type TableColumnListValuesParams struct {
	// FilterMode Table filter mode.
	//
	// Smart mode switches between column and search mode based on the filtered table and
	//
	// Search mode allows searching deeply nested data but is not available on all tables as it requires a separate indexing step.
	// Search mode is only available on resource tables or queries derived from resource tables results that contain _cq_id and _cq_source_id.
	// Search mode may also be used against cloud_assets but it will only return results from resource tables.
	//
	// Column mode searches purely using the columns in the table.
	// It will work on all table results but it is not optimized for arbitrary substring searches and so may be slow on larger tables.
	FilterMode *TableColumnListValuesParamsFilterMode `form:"filter_mode,omitempty" json:"filter_mode,omitempty"`
	Filter     *TableColumnValueFilter                `form:"filter,omitempty" json:"filter,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// TableColumnListValuesParamsFilterMode defines parameters for TableColumnListValues.
type TableColumnListValuesParamsFilterMode string

// TableListRowsParams defines parameters for TableListRows.
type TableListRowsParams struct {
	// Selects Table selects. This filters the columns that are returned in the result set.
	Selects Selects `form:"select,omitempty" json:"select,omitempty"`

	// FilterMode Table filter mode.
	//
	// Smart mode switches between column and search mode based on the filtered table and
	//
	// Search mode allows searching deeply nested data but is not available on all tables as it requires a separate indexing step.
	// Search mode is only available on resource tables or queries derived from resource tables results that contain _cq_id and _cq_source_id.
	// Search mode may also be used against cloud_assets but it will only return results from resource tables.
	//
	// Column mode searches purely using the columns in the table.
	// It will work on all table results but it is not optimized for arbitrary substring searches and so may be slow on larger tables.
	FilterMode *TableListRowsParamsFilterMode `form:"filter_mode,omitempty" json:"filter_mode,omitempty"`

	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// FilterIDs Table filter IDs. These should be valid Saved Filter IDs. These filters
	// will be applied to the query results before returning them.
	FilterIDs FilterIDs `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// SortBys Table sort by options. This sorts the rows that are returned in the result set.
	SortBys SortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirections Table sort direction options. This sorts the rows that are returned in the result set.
	SortDirections SortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`

	// GroupBys Table group by options. This groups the rows that are returned in the result set by the given columns.
	GroupBys GroupBys `form:"group_by,omitempty" json:"group_by,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// TableListRowsParamsFilterMode defines parameters for TableListRows.
type TableListRowsParamsFilterMode string

// TableRowByIdParams defines parameters for TableRowById.
type TableRowByIdParams struct {
	// FilterMode Table filter mode.
	//
	// Smart mode switches between column and search mode based on the filtered table and
	//
	// Search mode allows searching deeply nested data but is not available on all tables as it requires a separate indexing step.
	// Search mode is only available on resource tables or queries derived from resource tables results that contain _cq_id and _cq_source_id.
	// Search mode may also be used against cloud_assets but it will only return results from resource tables.
	//
	// Column mode searches purely using the columns in the table.
	// It will work on all table results but it is not optimized for arbitrary substring searches and so may be slow on larger tables.
	FilterMode *TableRowByIdParamsFilterMode `form:"filter_mode,omitempty" json:"filter_mode,omitempty"`

	// Filters Table filters. This filters the rows that are returned in the result set.
	Filters Filters `form:"filter,omitempty" json:"filter,omitempty"`

	// FilterIDs Table filter IDs. These should be valid Saved Filter IDs. These filters
	// will be applied to the query results before returning them.
	FilterIDs FilterIDs `form:"filter_id,omitempty" json:"filter_id,omitempty"`
}

// TableRowByIdParamsFilterMode defines parameters for TableRowById.
type TableRowByIdParamsFilterMode string

// TableListFiltersParams defines parameters for TableListFilters.
type TableListFiltersParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// FilterTags Filter tags
	FilterTags *FilterTags `form:"tag,omitempty" json:"tag,omitempty"`
}

// TableListFilterTagsParams defines parameters for TableListFilterTags.
type TableListFilterTagsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListTeamsParams defines parameters for ListTeams.
type ListTeamsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// DownloadPluginAssetByTeamParams defines parameters for DownloadPluginAssetByTeam.
type DownloadPluginAssetByTeamParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// UpdateSyncTestConnectionForSyncDestinationTeamJSONBody defines parameters for UpdateSyncTestConnectionForSyncDestinationTeam.
type UpdateSyncTestConnectionForSyncDestinationTeamJSONBody struct {
	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// UpdateSyncTestConnectionForSyncSourceTeamJSONBody defines parameters for UpdateSyncTestConnectionForSyncSourceTeam.
type UpdateSyncTestConnectionForSyncSourceTeamJSONBody struct {
	// FailureCode Code for failure
	FailureCode *string `json:"failure_code,omitempty"`

	// FailureReason Reason for failure
	FailureReason *string `json:"failure_reason,omitempty"`

	// Status The status of the sync run
	Status SyncTestConnectionStatus `json:"status"`
}

// CreateSyncRunProgressTeamJSONBody defines parameters for CreateSyncRunProgressTeam.
type CreateSyncRunProgressTeamJSONBody struct {
	// Errors Number of errors encountered so far
	Errors int64 `json:"errors"`

	// Rows Number of rows synced so far
	Rows int64 `json:"rows"`

	// ShardNum The shard number that this progress update is for
	ShardNum *int32 `json:"shard_num,omitempty"`

	// ShardTotal The total number of shards for this sync run
	ShardTotal *int32 `json:"shard_total,omitempty"`

	// Status The status of the sync run
	Status *SyncRunStatus `json:"status,omitempty"`

	// TableProgress Table-specific progress information for a sync run
	TableProgress *SyncRunTableProgress `json:"table_progress,omitempty"`

	// Warnings Number of warnings encountered so far
	Warnings int64 `json:"warnings"`
}

// GetTeamUsageSummaryParams defines parameters for GetTeamUsageSummary.
type GetTeamUsageSummaryParams struct {
	Metrics *[]GetTeamUsageSummaryParamsMetrics `form:"metrics,omitempty" json:"metrics,omitempty"`
	Start   *time.Time                          `form:"start,omitempty" json:"start,omitempty"`
	End     *time.Time                          `form:"end,omitempty" json:"end,omitempty"`

	// AggregationPeriod An aggregation period to sum data over. In other words, data will be returned at this granularity. Currently only supports day and month.
	AggregationPeriod *GetTeamUsageSummaryParamsAggregationPeriod `form:"aggregation_period,omitempty" json:"aggregation_period,omitempty"`
}

// GetTeamUsageSummaryParamsMetrics defines parameters for GetTeamUsageSummary.
type GetTeamUsageSummaryParamsMetrics string

// GetTeamUsageSummaryParamsAggregationPeriod defines parameters for GetTeamUsageSummary.
type GetTeamUsageSummaryParamsAggregationPeriod string

// GetGroupedTeamUsageSummaryParams defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParams struct {
	Metrics *[]GetGroupedTeamUsageSummaryParamsMetrics `form:"metrics,omitempty" json:"metrics,omitempty"`
	Start   *time.Time                                 `form:"start,omitempty" json:"start,omitempty"`
	End     *time.Time                                 `form:"end,omitempty" json:"end,omitempty"`

	// AggregationPeriod An aggregation period to sum data over. In other words, data will be returned at this granularity. Currently only supports day and month.
	AggregationPeriod *GetGroupedTeamUsageSummaryParamsAggregationPeriod `form:"aggregation_period,omitempty" json:"aggregation_period,omitempty"`
}

// GetGroupedTeamUsageSummaryParamsMetrics defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParamsMetrics string

// GetGroupedTeamUsageSummaryParamsAggregationPeriod defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParamsAggregationPeriod string

// GetGroupedTeamUsageSummaryParamsGroupBy defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParamsGroupBy string

// UpdateCurrentUserJSONBody defines parameters for UpdateCurrentUser.
type UpdateCurrentUserJSONBody struct {
	// Name The unique name for the user.
	Name *UserName `json:"name,omitempty"`

	// TrackingOptIn Whether to opt in or out of anonymous user tracking
	TrackingOptIn *bool `json:"tracking_opt_in,omitempty"`
}

// SendAnonymousEventJSONBody defines parameters for SendAnonymousEvent.
type SendAnonymousEventJSONBody struct {
	// AnonymousID Anonymous ID identifying the user
	AnonymousID string `json:"anonymous_id"`

	// Name Name of event
	Name string `json:"name"`

	// Properties Properties of event, keys should be of string type
	Properties *map[string]interface{} `json:"properties,omitempty"`
}

// AuthenticateUserJSONBody defines parameters for AuthenticateUser.
type AuthenticateUserJSONBody struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// ChangeUserPasswordJSONBody defines parameters for ChangeUserPassword.
type ChangeUserPasswordJSONBody struct {
	Email       string `json:"email"`
	NewPassword string `json:"new_password"`
	OldPassword string `json:"old_password"`
}

// UpdateCustomerJSONBody defines parameters for UpdateCustomer.
type UpdateCustomerJSONBody struct {
	CompanyName             *string `json:"company_name,omitempty"`
	FirstName               string  `json:"first_name"`
	LastName                string  `json:"last_name"`
	LearnedAboutCqFrom      *string `json:"learned_about_cq_from,omitempty"`
	LearnedAboutCqFromOther *string `json:"learned_about_cq_from_other,omitempty"`
	Phone                   *string `json:"phone,omitempty"`
}

// SendUserEventJSONBody defines parameters for SendUserEvent.
type SendUserEventJSONBody struct {
	// Name Name of event
	Name string `json:"name"`

	// Properties Properties of event, keys should be of string type
	Properties *map[string]interface{} `json:"properties,omitempty"`
}

// LoginUserJSONBody defines parameters for LoginUser.
type LoginUserJSONBody struct {
	IDToken string `json:"id_token"`
}

// UserTOTPVerifyJSONBody defines parameters for UserTOTPVerify.
type UserTOTPVerifyJSONBody struct {
	OTP string `json:"otp"`
}

// UserTOTPVerifyParams defines parameters for UserTOTPVerify.
type UserTOTPVerifyParams struct {
	CqpSess *string `form:"__cqp_sess,omitempty" json:"__cqp_sess,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// UserSearch Search by user name or email
	UserSearch *string `form:"user_search,omitempty" json:"user_search,omitempty"`

	// RoleId Search by user role ID
	RoleId *RoleID `form:"role_id,omitempty" json:"role_id,omitempty"`
}

// AddUserJSONBody defines parameters for AddUser.
type AddUserJSONBody struct {
	Email    string  `json:"email"`
	Name     string  `json:"name"`
	Password *string `json:"password,omitempty"`

	// Roles Roles for the user
	Roles []RoleID `json:"roles"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Enabled  *bool   `json:"enabled,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password *string `json:"password,omitempty"`

	// Roles Roles for the user
	Roles *[]RoleID `json:"roles,omitempty"`
}

// GetV2SyncDestinationsParams defines parameters for GetV2SyncDestinations.
type GetV2SyncDestinationsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page   *Page           `form:"page,omitempty" json:"page,omitempty"`
	Filter *SyncNameFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SyncGenericSortBys Sort by options
	SyncGenericSortBys SyncGenericSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
}

// ListV2SyncIntegrationsParams defines parameters for ListV2SyncIntegrations.
type ListV2SyncIntegrationsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// SyncSortBys Sort by options
	SyncSortBys SyncSortBys `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncSortDirections Sync sort direction options
	SyncSortDirections SyncSortDirections `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
	Filter             *SyncNameFilter    `form:"filter,omitempty" json:"filter,omitempty"`
}

// DeleteV2SyncIntegrationParams defines parameters for DeleteV2SyncIntegration.
type DeleteV2SyncIntegrationParams struct {
	// DeleteData If true, also delete data associated with this integration from the relevant destinations.
	DeleteData *bool `form:"delete_data,omitempty" json:"delete_data,omitempty"`
}

// TestUnsavedAlertJSONRequestBody defines body for TestUnsavedAlert for application/json ContentType.
type TestUnsavedAlertJSONRequestBody = AlertCreate

// CreateAPIKeyJSONRequestBody defines body for CreateAPIKey for application/json ContentType.
type CreateAPIKeyJSONRequestBody CreateAPIKeyJSONBody

// UpdateSAMLJSONRequestBody defines body for UpdateSAML for application/json ContentType.
type UpdateSAMLJSONRequestBody = SAMLConfigUpdate

// CreateConversationJSONRequestBody defines body for CreateConversation for application/json ContentType.
type CreateConversationJSONRequestBody = ConversationCreate

// SendMessageJSONRequestBody defines body for SendMessage for application/json ContentType.
type SendMessageJSONRequestBody = ConversationSendMessage

// SaveCustomColumnJSONRequestBody defines body for SaveCustomColumn for application/json ContentType.
type SaveCustomColumnJSONRequestBody = CustomColumnCreateOrUpdate

// UpdateCustomColumnJSONRequestBody defines body for UpdateCustomColumn for application/json ContentType.
type UpdateCustomColumnJSONRequestBody = CustomColumnCreateOrUpdate

// UpdateFilterJSONRequestBody defines body for UpdateFilter for application/json ContentType.
type UpdateFilterJSONRequestBody = FilterUpdate

// UpdateNotificationDestinationJSONRequestBody defines body for UpdateNotificationDestination for application/json ContentType.
type UpdateNotificationDestinationJSONRequestBody = NotificationDestinationUpdate

// CreateNotificationDestinationJSONRequestBody defines body for CreateNotificationDestination for application/json ContentType.
type CreateNotificationDestinationJSONRequestBody = NotificationDestinationCreate

// TestUnsavedNotificationDestinationJSONRequestBody defines body for TestUnsavedNotificationDestination for application/json ContentType.
type TestUnsavedNotificationDestinationJSONRequestBody = NotificationDestinationData

// CreateAWSOnboardingJSONRequestBody defines body for CreateAWSOnboarding for application/json ContentType.
type CreateAWSOnboardingJSONRequestBody CreateAWSOnboardingJSONBody

// ProvisionOnboardingConfigurationJSONRequestBody defines body for ProvisionOnboardingConfiguration for application/json ContentType.
type ProvisionOnboardingConfigurationJSONRequestBody = OnboardingAWSProvision

// NotifyOnboardingJSONRequestBody defines body for NotifyOnboarding for application/json ContentType.
type NotifyOnboardingJSONRequestBody = OnboardingAWSNotification

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = PolicyCreate

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = PolicyUpdate

// CreatePolicyGroupJSONRequestBody defines body for CreatePolicyGroup for application/json ContentType.
type CreatePolicyGroupJSONRequestBody = PolicyGroupCreate

// UpdatePolicyGroupJSONRequestBody defines body for UpdatePolicyGroup for application/json ContentType.
type UpdatePolicyGroupJSONRequestBody = PolicyGroupUpdate

// ExecuteAdHocQueryJSONRequestBody defines body for ExecuteAdHocQuery for application/json ContentType.
type ExecuteAdHocQueryJSONRequestBody ExecuteAdHocQueryJSONBody

// SaveQueryJSONRequestBody defines body for SaveQuery for application/json ContentType.
type SaveQueryJSONRequestBody = QueryCreate

// UpdateQueryJSONRequestBody defines body for UpdateQuery for application/json ContentType.
type UpdateQueryJSONRequestBody = QueryUpdate

// QuerySaveFilterJSONRequestBody defines body for QuerySaveFilter for application/json ContentType.
type QuerySaveFilterJSONRequestBody = FilterCreate

// CreateRBACPermissionJSONRequestBody defines body for CreateRBACPermission for application/json ContentType.
type CreateRBACPermissionJSONRequestBody = RBACPermissionCreate

// UpdateRBACPermissionJSONRequestBody defines body for UpdateRBACPermission for application/json ContentType.
type UpdateRBACPermissionJSONRequestBody = RBACPermissionUpdate

// CreateRBACRoleJSONRequestBody defines body for CreateRBACRole for application/json ContentType.
type CreateRBACRoleJSONRequestBody = RBACRoleCreate

// UpdateRBACRoleJSONRequestBody defines body for UpdateRBACRole for application/json ContentType.
type UpdateRBACRoleJSONRequestBody = RBACRoleUpdate

// CreateReportJSONRequestBody defines body for CreateReport for application/json ContentType.
type CreateReportJSONRequestBody = ReportCreate

// CreateReportTemplateJSONRequestBody defines body for CreateReportTemplate for application/json ContentType.
type CreateReportTemplateJSONRequestBody = ReportTemplateCreateOrUpdate

// UpdateReportTemplateJSONRequestBody defines body for UpdateReportTemplate for application/json ContentType.
type UpdateReportTemplateJSONRequestBody = ReportTemplateCreateOrUpdate

// UpdateReportJSONRequestBody defines body for UpdateReport for application/json ContentType.
type UpdateReportJSONRequestBody = ReportUpdate

// UpdateSettingsJSONRequestBody defines body for UpdateSettings for application/json ContentType.
type UpdateSettingsJSONRequestBody = PlatformSettingsUpdate

// UpdateDataSettingsJSONRequestBody defines body for UpdateDataSettings for application/json ContentType.
type UpdateDataSettingsJSONRequestBody = PlatformDataSettingsUpdate

// CreateSlackConnectionJSONRequestBody defines body for CreateSlackConnection for application/json ContentType.
type CreateSlackConnectionJSONRequestBody = SlackConnectionCreate

// CreateSyncDestinationTestConnectionJSONRequestBody defines body for CreateSyncDestinationTestConnection for application/json ContentType.
type CreateSyncDestinationTestConnectionJSONRequestBody = SyncDestinationTestConnectionCreate

// UpdateSyncTestConnectionForSyncDestinationJSONRequestBody defines body for UpdateSyncTestConnectionForSyncDestination for application/json ContentType.
type UpdateSyncTestConnectionForSyncDestinationJSONRequestBody UpdateSyncTestConnectionForSyncDestinationJSONBody

// PromoteSyncDestinationTestConnectionJSONRequestBody defines body for PromoteSyncDestinationTestConnection for application/json ContentType.
type PromoteSyncDestinationTestConnectionJSONRequestBody = PromoteSyncDestinationTestConnection

// UpdateSyncDestinationJSONRequestBody defines body for UpdateSyncDestination for application/json ContentType.
type UpdateSyncDestinationJSONRequestBody = SyncDestinationUpdate

// CreateSyncSourceTestConnectionJSONRequestBody defines body for CreateSyncSourceTestConnection for application/json ContentType.
type CreateSyncSourceTestConnectionJSONRequestBody = SyncSourceTestConnectionCreate

// UpdateSyncTestConnectionForSyncSourceJSONRequestBody defines body for UpdateSyncTestConnectionForSyncSource for application/json ContentType.
type UpdateSyncTestConnectionForSyncSourceJSONRequestBody UpdateSyncTestConnectionForSyncSourceJSONBody

// PromoteSyncSourceTestConnectionJSONRequestBody defines body for PromoteSyncSourceTestConnection for application/json ContentType.
type PromoteSyncSourceTestConnectionJSONRequestBody = PromoteSyncSourceTestConnection

// UpdateSyncSourceJSONRequestBody defines body for UpdateSyncSource for application/json ContentType.
type UpdateSyncSourceJSONRequestBody = SyncSourceUpdate

// UpdateSyncTransformerJSONRequestBody defines body for UpdateSyncTransformer for application/json ContentType.
type UpdateSyncTransformerJSONRequestBody = SyncTransformerUpdate

// CreateSyncJSONRequestBody defines body for CreateSync for application/json ContentType.
type CreateSyncJSONRequestBody = SyncCreate

// UpdateSyncJSONRequestBody defines body for UpdateSync for application/json ContentType.
type UpdateSyncJSONRequestBody = SyncUpdate

// UpdateSyncRunJSONRequestBody defines body for UpdateSyncRun for application/json ContentType.
type UpdateSyncRunJSONRequestBody UpdateSyncRunJSONBody

// CreateSyncRunProgressJSONRequestBody defines body for CreateSyncRunProgress for application/json ContentType.
type CreateSyncRunProgressJSONRequestBody CreateSyncRunProgressJSONBody

// TablesDataActionJSONRequestBody defines body for TablesDataAction for application/json ContentType.
type TablesDataActionJSONRequestBody = TableDataAction

// TableSaveFilterJSONRequestBody defines body for TableSaveFilter for application/json ContentType.
type TableSaveFilterJSONRequestBody = FilterCreate

// UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody defines body for UpdateSyncTestConnectionForSyncDestinationTeam for application/json ContentType.
type UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody UpdateSyncTestConnectionForSyncDestinationTeamJSONBody

// UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody defines body for UpdateSyncTestConnectionForSyncSourceTeam for application/json ContentType.
type UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody UpdateSyncTestConnectionForSyncSourceTeamJSONBody

// CreateSyncRunProgressTeamJSONRequestBody defines body for CreateSyncRunProgressTeam for application/json ContentType.
type CreateSyncRunProgressTeamJSONRequestBody CreateSyncRunProgressTeamJSONBody

// UpdateCurrentUserJSONRequestBody defines body for UpdateCurrentUser for application/json ContentType.
type UpdateCurrentUserJSONRequestBody UpdateCurrentUserJSONBody

// SendAnonymousEventJSONRequestBody defines body for SendAnonymousEvent for application/json ContentType.
type SendAnonymousEventJSONRequestBody SendAnonymousEventJSONBody

// AuthenticateUserJSONRequestBody defines body for AuthenticateUser for application/json ContentType.
type AuthenticateUserJSONRequestBody AuthenticateUserJSONBody

// ChangeUserPasswordJSONRequestBody defines body for ChangeUserPassword for application/json ContentType.
type ChangeUserPasswordJSONRequestBody ChangeUserPasswordJSONBody

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdateCustomerJSONBody

// SendUserEventJSONRequestBody defines body for SendUserEvent for application/json ContentType.
type SendUserEventJSONRequestBody SendUserEventJSONBody

// LoginUserJSONRequestBody defines body for LoginUser for application/json ContentType.
type LoginUserJSONRequestBody LoginUserJSONBody

// UserTOTPVerifyJSONRequestBody defines body for UserTOTPVerify for application/json ContentType.
type UserTOTPVerifyJSONRequestBody UserTOTPVerifyJSONBody

// AddUserJSONRequestBody defines body for AddUser for application/json ContentType.
type AddUserJSONRequestBody AddUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// CreateV2SyncDestinationTestConnectionJSONRequestBody defines body for CreateV2SyncDestinationTestConnection for application/json ContentType.
type CreateV2SyncDestinationTestConnectionJSONRequestBody = CreateSyncDestinationTestConnectionV2

// CreateV2SyncDestinationJSONRequestBody defines body for CreateV2SyncDestination for application/json ContentType.
type CreateV2SyncDestinationJSONRequestBody = CreateSyncDestinationV2

// PatchV2SyncDestinationJSONRequestBody defines body for PatchV2SyncDestination for application/json ContentType.
type PatchV2SyncDestinationJSONRequestBody = SyncDestinationUpdateV2

// CreateV2SyncIntegrationTestConnectionJSONRequestBody defines body for CreateV2SyncIntegrationTestConnection for application/json ContentType.
type CreateV2SyncIntegrationTestConnectionJSONRequestBody = SyncIntegrationTestConnectionCreateV2

// CreateV2SyncIntegrationJSONRequestBody defines body for CreateV2SyncIntegration for application/json ContentType.
type CreateV2SyncIntegrationJSONRequestBody = SyncIntegrationCreateV2

// UpdateV2SyncIntegrationJSONRequestBody defines body for UpdateV2SyncIntegration for application/json ContentType.
type UpdateV2SyncIntegrationJSONRequestBody = SyncIntegrationUpdateV2

// AsStartedNotification returns the union data inside the OnboardingAWSNotification as a StartedNotification
func (t OnboardingAWSNotification) AsStartedNotification() (StartedNotification, error) {
	var body StartedNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStartedNotification overwrites any union data inside the OnboardingAWSNotification as the provided StartedNotification
func (t *OnboardingAWSNotification) FromStartedNotification(v StartedNotification) error {
	v.Status = "started"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStartedNotification performs a merge with any union data inside the OnboardingAWSNotification, using the provided StartedNotification
func (t *OnboardingAWSNotification) MergeStartedNotification(v StartedNotification) error {
	v.Status = "started"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevokedNotification returns the union data inside the OnboardingAWSNotification as a RevokedNotification
func (t OnboardingAWSNotification) AsRevokedNotification() (RevokedNotification, error) {
	var body RevokedNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevokedNotification overwrites any union data inside the OnboardingAWSNotification as the provided RevokedNotification
func (t *OnboardingAWSNotification) FromRevokedNotification(v RevokedNotification) error {
	v.Status = "revoked"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevokedNotification performs a merge with any union data inside the OnboardingAWSNotification, using the provided RevokedNotification
func (t *OnboardingAWSNotification) MergeRevokedNotification(v RevokedNotification) error {
	v.Status = "revoked"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFailedNotification returns the union data inside the OnboardingAWSNotification as a FailedNotification
func (t OnboardingAWSNotification) AsFailedNotification() (FailedNotification, error) {
	var body FailedNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedNotification overwrites any union data inside the OnboardingAWSNotification as the provided FailedNotification
func (t *OnboardingAWSNotification) FromFailedNotification(v FailedNotification) error {
	v.Status = "failed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedNotification performs a merge with any union data inside the OnboardingAWSNotification, using the provided FailedNotification
func (t *OnboardingAWSNotification) MergeFailedNotification(v FailedNotification) error {
	v.Status = "failed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeployedNotification returns the union data inside the OnboardingAWSNotification as a DeployedNotification
func (t OnboardingAWSNotification) AsDeployedNotification() (DeployedNotification, error) {
	var body DeployedNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeployedNotification overwrites any union data inside the OnboardingAWSNotification as the provided DeployedNotification
func (t *OnboardingAWSNotification) FromDeployedNotification(v DeployedNotification) error {
	v.Status = "deployed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeployedNotification performs a merge with any union data inside the OnboardingAWSNotification, using the provided DeployedNotification
func (t *OnboardingAWSNotification) MergeDeployedNotification(v DeployedNotification) error {
	v.Status = "deployed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletedNotification returns the union data inside the OnboardingAWSNotification as a CompletedNotification
func (t OnboardingAWSNotification) AsCompletedNotification() (CompletedNotification, error) {
	var body CompletedNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletedNotification overwrites any union data inside the OnboardingAWSNotification as the provided CompletedNotification
func (t *OnboardingAWSNotification) FromCompletedNotification(v CompletedNotification) error {
	v.Status = "completed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletedNotification performs a merge with any union data inside the OnboardingAWSNotification, using the provided CompletedNotification
func (t *OnboardingAWSNotification) MergeCompletedNotification(v CompletedNotification) error {
	v.Status = "completed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletedSingleAccountNotification returns the union data inside the OnboardingAWSNotification as a CompletedSingleAccountNotification
func (t OnboardingAWSNotification) AsCompletedSingleAccountNotification() (CompletedSingleAccountNotification, error) {
	var body CompletedSingleAccountNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletedSingleAccountNotification overwrites any union data inside the OnboardingAWSNotification as the provided CompletedSingleAccountNotification
func (t *OnboardingAWSNotification) FromCompletedSingleAccountNotification(v CompletedSingleAccountNotification) error {
	v.Status = "completed_account"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletedSingleAccountNotification performs a merge with any union data inside the OnboardingAWSNotification, using the provided CompletedSingleAccountNotification
func (t *OnboardingAWSNotification) MergeCompletedSingleAccountNotification(v CompletedSingleAccountNotification) error {
	v.Status = "completed_account"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OnboardingAWSNotification) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OnboardingAWSNotification) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "completed":
		return t.AsCompletedNotification()
	case "completed_account":
		return t.AsCompletedSingleAccountNotification()
	case "deployed":
		return t.AsDeployedNotification()
	case "failed":
		return t.AsFailedNotification()
	case "revoked":
		return t.AsRevokedNotification()
	case "started":
		return t.AsStartedNotification()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OnboardingAWSNotification) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OnboardingAWSNotification) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	retryClient := retryablehttp.NewClient()
	retryClient.Logger = nil
	opts = append([]ClientOption{WithHTTPClient(retryClient.StandardClient())}, opts...)
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Index request
	Index(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllAlerts request
	ListAllAlerts(ctx context.Context, params *ListAllAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestUnsavedAlertWithBody request with any body
	TestUnsavedAlertWithBody(ctx context.Context, params *TestUnsavedAlertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestUnsavedAlert(ctx context.Context, params *TestUnsavedAlertParams, body TestUnsavedAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAPIKeys request
	ListAPIKeys(ctx context.Context, params *ListAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAPIKeyWithBody request with any body
	CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAPIKey request
	DeleteAPIKey(ctx context.Context, apiKeyID APIKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLog request
	GetAuditLog(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSAML request
	GetSAML(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSAMLWithBody request with any body
	UpdateSAMLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSAML(ctx context.Context, body UpdateSAMLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConversationWithBody request with any body
	CreateConversationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConversation(ctx context.Context, body CreateConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConversation request
	GetConversation(ctx context.Context, conversationID ConversationID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMessageWithBody request with any body
	SendMessageWithBody(ctx context.Context, conversationID ConversationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessage(ctx context.Context, conversationID ConversationID, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllCustomColumns request
	ListAllCustomColumns(ctx context.Context, params *ListAllCustomColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveCustomColumnWithBody request with any body
	SaveCustomColumnWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveCustomColumn(ctx context.Context, body SaveCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomColumn request
	DeleteCustomColumn(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomColumn request
	GetCustomColumn(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomColumnWithBody request with any body
	UpdateCustomColumnWithBody(ctx context.Context, customColumnID CustomColumnID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomColumn(ctx context.Context, customColumnID CustomColumnID, body UpdateCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFilters request
	ListFilters(ctx context.Context, params *ListFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFilterTags request
	ListFilterTags(ctx context.Context, params *ListFilterTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilter request
	DeleteFilter(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterByID request
	GetFilterByID(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFilterWithBody request with any body
	UpdateFilterWithBody(ctx context.Context, filterID FilterID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFilter(ctx context.Context, filterID FilterID, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheckHead request
	HealthCheckHead(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotifications request
	ListNotifications(ctx context.Context, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationDestination request
	DeleteNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationDestination request
	GetNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationDestinationWithBody request with any body
	UpdateNotificationDestinationWithBody(ctx context.Context, notificationDestinationId NotificationDestinationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, body UpdateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationDestinationAlerts request
	GetNotificationDestinationAlerts(ctx context.Context, notificationDestinationId NotificationDestinationId, params *GetNotificationDestinationAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestNotificationDestination request
	TestNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllNotificationDestinations request
	ListAllNotificationDestinations(ctx context.Context, params *ListAllNotificationDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationDestinationWithBody request with any body
	CreateNotificationDestinationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationDestination(ctx context.Context, body CreateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestUnsavedNotificationDestinationWithBody request with any body
	TestUnsavedNotificationDestinationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestUnsavedNotificationDestination(ctx context.Context, body TestUnsavedNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAWSOnboardingWithBody request with any body
	CreateAWSOnboardingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAWSOnboarding(ctx context.Context, body CreateAWSOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSOnboarding request
	GetAWSOnboarding(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSAccountsInRoot request
	GetAWSAccountsInRoot(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisionOnboardingConfigurationWithBody request with any body
	ProvisionOnboardingConfigurationWithBody(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProvisionOnboardingConfiguration(ctx context.Context, onboardingID OnboardingID, body ProvisionOnboardingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSAccountsInParent request
	GetAWSAccountsInParent(ctx context.Context, onboardingID OnboardingID, organizationalUnitID OrganizationalUnitID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifyOnboardingWithBody request with any body
	NotifyOnboardingWithBody(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotifyOnboarding(ctx context.Context, onboardingID OnboardingID, body NotifyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenAPIJSON request
	GetOpenAPIJSON(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformInfo request
	GetPlatformInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlatformVersions request
	ListPlatformVersions(ctx context.Context, params *ListPlatformVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlugins request
	ListPlugins(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlugin request
	GetPlugin(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersions request
	ListPluginVersions(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginVersion request
	GetPluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPluginAsset request
	DownloadPluginAsset(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersionTables request
	ListPluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginVersionTable request
	GetPluginVersionTable(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicyMetrics request
	GetPolicyMetrics(ctx context.Context, params *GetPolicyMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetViolationsByDomain request
	GetViolationsByDomain(ctx context.Context, params *GetViolationsByDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetViolationsHistory request
	GetViolationsHistory(ctx context.Context, params *GetViolationsHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyID PolicyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyID PolicyID, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TogglePolicy request
	TogglePolicy(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicyViolations request
	GetPolicyViolations(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicyViolationsHistory request
	GetPolicyViolationsHistory(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicyGroups request
	ListPolicyGroups(ctx context.Context, params *ListPolicyGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyGroupWithBody request with any body
	CreatePolicyGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicyGroup(ctx context.Context, body CreatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicyGroup request
	DeletePolicyGroup(ctx context.Context, policyGroupID PolicyGroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPoliciesInGroup request
	ListPoliciesInGroup(ctx context.Context, policyGroupID PolicyGroupID, params *ListPoliciesInGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyGroupWithBody request with any body
	UpdatePolicyGroupWithBody(ctx context.Context, policyGroupID PolicyGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicyGroup(ctx context.Context, policyGroupID PolicyGroupID, body UpdatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllQueries request
	ListAllQueries(ctx context.Context, params *ListAllQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteAdHocQueryWithBody request with any body
	ExecuteAdHocQueryWithBody(ctx context.Context, params *ExecuteAdHocQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteAdHocQuery(ctx context.Context, params *ExecuteAdHocQueryParams, body ExecuteAdHocQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveQueryWithBody request with any body
	SaveQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveQuery(ctx context.Context, body SaveQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQueryTags request
	ListQueryTags(ctx context.Context, params *ListQueryTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQuery request
	DeleteSavedQuery(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSavedQuery request
	GetSavedQuery(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateQueryWithBody request with any body
	UpdateQueryWithBody(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateQuery(ctx context.Context, queryID QueryID, body UpdateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlert request
	DeleteAlert(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteSavedQuery request
	ExecuteSavedQuery(ctx context.Context, queryID QueryID, params *ExecuteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryListFilters request
	QueryListFilters(ctx context.Context, queryID QueryID, params *QueryListFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QuerySaveFilterWithBody request with any body
	QuerySaveFilterWithBody(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QuerySaveFilter(ctx context.Context, queryID QueryID, body QuerySaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryListFilterTags request
	QueryListFilterTags(ctx context.Context, queryID QueryID, params *QueryListFilterTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllRBACPermissions request
	ListAllRBACPermissions(ctx context.Context, params *ListAllRBACPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRBACPermissionWithBody request with any body
	CreateRBACPermissionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRBACPermission(ctx context.Context, body CreateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRBACPermission request
	DeleteRBACPermission(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRBACPermission request
	GetRBACPermission(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRBACPermissionWithBody request with any body
	UpdateRBACPermissionWithBody(ctx context.Context, rbacPermissionID RBACPermissionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRBACPermission(ctx context.Context, rbacPermissionID RBACPermissionID, body UpdateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllRBACRoles request
	ListAllRBACRoles(ctx context.Context, params *ListAllRBACRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRBACRoleWithBody request with any body
	CreateRBACRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRBACRole(ctx context.Context, body CreateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRBACRole request
	DeleteRBACRole(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRBACRole request
	GetRBACRole(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRBACRoleWithBody request with any body
	UpdateRBACRoleWithBody(ctx context.Context, roleID RoleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRBACRole(ctx context.Context, roleID RoleID, body UpdateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReports request
	ListReports(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReportWithBody request with any body
	CreateReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReport(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportTemplates request
	ListReportTemplates(ctx context.Context, params *ListReportTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReportTemplateWithBody request with any body
	CreateReportTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReportTemplate(ctx context.Context, body CreateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReportTemplate request
	DeleteReportTemplate(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportTemplate request
	GetReportTemplate(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateReportTemplateWithBody request with any body
	UpdateReportTemplateWithBody(ctx context.Context, templateId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateReportTemplate(ctx context.Context, templateId openapi_types.UUID, body UpdateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReport request
	DeleteReport(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReport request
	GetReport(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateReportWithBody request with any body
	UpdateReportWithBody(ctx context.Context, reportId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateReport(ctx context.Context, reportId openapi_types.UUID, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSettingsWithBody request with any body
	UpdateSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettings(ctx context.Context, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataSettings request
	GetDataSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataSettingsWithBody request with any body
	UpdateDataSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataSettings(ctx context.Context, body UpdateDataSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSlackConnectionWithBody request with any body
	CreateSlackConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSlackConnection(ctx context.Context, body CreateSlackConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSlackChannels request
	ListSlackChannels(ctx context.Context, id openapi_types.UUID, params *ListSlackChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncDestinationTestConnectionWithBody request with any body
	CreateSyncDestinationTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncDestinationTestConnection(ctx context.Context, body CreateSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncDestinationTestConnection request
	GetSyncDestinationTestConnection(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncTestConnectionForSyncDestinationWithBody request with any body
	UpdateSyncTestConnectionForSyncDestinationWithBody(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncTestConnectionForSyncDestination(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncDestinationTestConnectionLogsLive request
	GetSyncDestinationTestConnectionLogsLive(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncDestinationTestConnectionLogsQuery request
	GetSyncDestinationTestConnectionLogsQuery(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromoteSyncDestinationTestConnectionWithBody request with any body
	PromoteSyncDestinationTestConnectionWithBody(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromoteSyncDestinationTestConnection(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body PromoteSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncDestinations request
	ListSyncDestinations(ctx context.Context, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSyncDestination request
	DeleteSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncDestination request
	GetSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncDestinationWithBody request with any body
	UpdateSyncDestinationWithBody(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncDestinationSyncs request
	ListSyncDestinationSyncs(ctx context.Context, syncDestinationName SyncDestinationName, params *ListSyncDestinationSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestConnectionForSyncDestination request
	GetTestConnectionForSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncSourceTestConnectionWithBody request with any body
	CreateSyncSourceTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncSourceTestConnection(ctx context.Context, body CreateSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncSourceTestConnection request
	GetSyncSourceTestConnection(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncTestConnectionForSyncSourceWithBody request with any body
	UpdateSyncTestConnectionForSyncSourceWithBody(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncTestConnectionForSyncSource(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncSourceTestConnectionLogsLive request
	GetSyncSourceTestConnectionLogsLive(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncSourceTestConnectionLogsQuery request
	GetSyncSourceTestConnectionLogsQuery(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromoteSyncSourceTestConnectionWithBody request with any body
	PromoteSyncSourceTestConnectionWithBody(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromoteSyncSourceTestConnection(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body PromoteSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncSources request
	ListSyncSources(ctx context.Context, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSyncSource request
	DeleteSyncSource(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncSource request
	GetSyncSource(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncSourceWithBody request with any body
	UpdateSyncSourceWithBody(ctx context.Context, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncSource(ctx context.Context, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncSourceSyncs request
	ListSyncSourceSyncs(ctx context.Context, syncSourceName SyncSourceName, params *ListSyncSourceSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestConnectionForSyncSource request
	GetTestConnectionForSyncSource(ctx context.Context, syncSourceName SyncSourceName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncTransformers request
	ListSyncTransformers(ctx context.Context, params *ListSyncTransformersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSyncTransformer request
	DeleteSyncTransformer(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncTransformer request
	GetSyncTransformer(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncTransformerWithBody request with any body
	UpdateSyncTransformerWithBody(ctx context.Context, syncTransformerName SyncTransformerName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncTransformer(ctx context.Context, syncTransformerName SyncTransformerName, body UpdateSyncTransformerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncTransformerSyncDestinations request
	ListSyncTransformerSyncDestinations(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncTransformerSyncs request
	ListSyncTransformerSyncs(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncUpgrades request
	ListSyncUpgrades(ctx context.Context, params *ListSyncUpgradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncs request
	ListSyncs(ctx context.Context, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncWithBody request with any body
	CreateSyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSync(ctx context.Context, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSync request
	DeleteSync(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSync request
	GetSync(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncWithBody request with any body
	UpdateSyncWithBody(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSync(ctx context.Context, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncRuns request
	ListSyncRuns(ctx context.Context, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncRun request
	CreateSyncRun(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRun request
	GetSyncRun(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncRunWithBody request with any body
	UpdateSyncRunWithBody(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncRun(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRunLogsLive request
	GetSyncRunLogsLive(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsLiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRunLogsQuery request
	GetSyncRunLogsQuery(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncRunProgressWithBody request with any body
	CreateSyncRunProgressWithBody(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncRunProgress(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRunStats request
	GetSyncRunStats(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRunTables request
	GetSyncRunTables(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTablesData request
	GetTablesData(ctx context.Context, params *GetTablesDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TablesDataActionWithBody request with any body
	TablesDataActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TablesDataAction(ctx context.Context, body TablesDataActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BatchTableSchemas request
	BatchTableSchemas(ctx context.Context, params *BatchTableSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableListColumns request
	TableListColumns(ctx context.Context, tableName TableName, params *TableListColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableColumnListValues request
	TableColumnListValues(ctx context.Context, tableName TableName, columnName ColumnName, params *TableColumnListValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableListRows request
	TableListRows(ctx context.Context, tableName TableName, params *TableListRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableRowById request
	TableRowById(ctx context.Context, tableName TableName, tableRowId TableRowId, params *TableRowByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableListFilters request
	TableListFilters(ctx context.Context, tableName TableName, params *TableListFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableSaveFilterWithBody request with any body
	TableSaveFilterWithBody(ctx context.Context, tableName TableName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TableSaveFilter(ctx context.Context, tableName TableName, body TableSaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableListFilterTags request
	TableListFilterTags(ctx context.Context, tableName TableName, params *TableListFilterTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableSchema request
	TableSchema(ctx context.Context, tableName TableName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPluginAssetByTeam request
	DownloadPluginAssetByTeam(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncTestConnectionForSyncDestinationTeamWithBody request with any body
	UpdateSyncTestConnectionForSyncDestinationTeamWithBody(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncTestConnectionForSyncDestinationTeam(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncTestConnectionForSyncSourceTeamWithBody request with any body
	UpdateSyncTestConnectionForSyncSourceTeamWithBody(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncTestConnectionForSyncSourceTeam(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncRunProgressTeamWithBody request with any body
	CreateSyncRunProgressTeamWithBody(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncRunProgressTeam(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamUsageSummary request
	GetTeamUsageSummary(ctx context.Context, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupedTeamUsageSummary request
	GetGroupedTeamUsageSummary(ctx context.Context, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCurrentUserWithBody request with any body
	UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendAnonymousEventWithBody request with any body
	SendAnonymousEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendAnonymousEvent(ctx context.Context, body SendAnonymousEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateUserWithBody request with any body
	AuthenticateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateUser(ctx context.Context, body AuthenticateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeUserPasswordWithBody request with any body
	ChangeUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeUserPassword(ctx context.Context, body ChangeUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomerWithBody request with any body
	UpdateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomer(ctx context.Context, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendUserEventWithBody request with any body
	SendUserEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendUserEvent(ctx context.Context, body SendUserEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutUser request
	LogoutUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginUserWithBody request with any body
	LoginUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginUser(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserTOTPDelete request
	UserTOTPDelete(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserTOTPSetup request
	UserTOTPSetup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserTOTPVerifyWithBody request with any body
	UserTOTPVerifyWithBody(ctx context.Context, params *UserTOTPVerifyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserTOTPVerify(ctx context.Context, params *UserTOTPVerifyParams, body UserTOTPVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserWithBody request with any body
	AddUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUser(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserTOTP request
	DeleteUserTOTP(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateV2SyncDestinationTestConnectionWithBody request with any body
	CreateV2SyncDestinationTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateV2SyncDestinationTestConnection(ctx context.Context, body CreateV2SyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2SyncDestinations request
	GetV2SyncDestinations(ctx context.Context, params *GetV2SyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateV2SyncDestinationWithBody request with any body
	CreateV2SyncDestinationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateV2SyncDestination(ctx context.Context, body CreateV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2SyncDestination request
	DeleteV2SyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2SyncDestination request
	GetV2SyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2SyncDestinationWithBody request with any body
	PatchV2SyncDestinationWithBody(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2SyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, body PatchV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateV2SyncIntegrationTestConnectionWithBody request with any body
	CreateV2SyncIntegrationTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateV2SyncIntegrationTestConnection(ctx context.Context, body CreateV2SyncIntegrationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListV2SyncIntegrations request
	ListV2SyncIntegrations(ctx context.Context, params *ListV2SyncIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateV2SyncIntegrationWithBody request with any body
	CreateV2SyncIntegrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateV2SyncIntegration(ctx context.Context, body CreateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2SyncIntegration request
	DeleteV2SyncIntegration(ctx context.Context, syncName SyncName, params *DeleteV2SyncIntegrationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2SyncIntegration request
	GetV2SyncIntegration(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateV2SyncIntegrationWithBody request with any body
	UpdateV2SyncIntegrationWithBody(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateV2SyncIntegration(ctx context.Context, syncName SyncName, body UpdateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Index(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIndexRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllAlerts(ctx context.Context, params *ListAllAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllAlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestUnsavedAlertWithBody(ctx context.Context, params *TestUnsavedAlertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUnsavedAlertRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestUnsavedAlert(ctx context.Context, params *TestUnsavedAlertParams, body TestUnsavedAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUnsavedAlertRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAPIKeys(ctx context.Context, params *ListAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAPIKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAPIKey(ctx context.Context, apiKeyID APIKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAPIKeyRequest(c.Server, apiKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLog(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSAML(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSAMLRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAMLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAMLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAML(ctx context.Context, body UpdateSAMLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAMLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConversationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConversationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConversation(ctx context.Context, body CreateConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConversationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConversation(ctx context.Context, conversationID ConversationID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConversationRequest(c.Server, conversationID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageWithBody(ctx context.Context, conversationID ConversationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageRequestWithBody(c.Server, conversationID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessage(ctx context.Context, conversationID ConversationID, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageRequest(c.Server, conversationID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllCustomColumns(ctx context.Context, params *ListAllCustomColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllCustomColumnsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveCustomColumnWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveCustomColumnRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveCustomColumn(ctx context.Context, body SaveCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveCustomColumnRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomColumn(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomColumnRequest(c.Server, customColumnID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomColumn(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomColumnRequest(c.Server, customColumnID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomColumnWithBody(ctx context.Context, customColumnID CustomColumnID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomColumnRequestWithBody(c.Server, customColumnID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomColumn(ctx context.Context, customColumnID CustomColumnID, body UpdateCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomColumnRequest(c.Server, customColumnID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFilters(ctx context.Context, params *ListFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFilterTags(ctx context.Context, params *ListFilterTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFilterTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilter(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterRequest(c.Server, filterID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterByID(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterByIDRequest(c.Server, filterID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFilterWithBody(ctx context.Context, filterID FilterID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFilterRequestWithBody(c.Server, filterID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFilter(ctx context.Context, filterID FilterID, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFilterRequest(c.Server, filterID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheckHead(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckHeadRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotifications(ctx context.Context, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationDestinationRequest(c.Server, notificationDestinationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationDestinationRequest(c.Server, notificationDestinationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationDestinationWithBody(ctx context.Context, notificationDestinationId NotificationDestinationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationDestinationRequestWithBody(c.Server, notificationDestinationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, body UpdateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationDestinationRequest(c.Server, notificationDestinationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationDestinationAlerts(ctx context.Context, notificationDestinationId NotificationDestinationId, params *GetNotificationDestinationAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationDestinationAlertsRequest(c.Server, notificationDestinationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestNotificationDestination(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestNotificationDestinationRequest(c.Server, notificationDestinationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllNotificationDestinations(ctx context.Context, params *ListAllNotificationDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllNotificationDestinationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationDestinationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationDestinationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationDestination(ctx context.Context, body CreateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationDestinationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestUnsavedNotificationDestinationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUnsavedNotificationDestinationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestUnsavedNotificationDestination(ctx context.Context, body TestUnsavedNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUnsavedNotificationDestinationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSOnboardingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSOnboardingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSOnboarding(ctx context.Context, body CreateAWSOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSOnboardingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSOnboarding(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSOnboardingRequest(c.Server, onboardingID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSAccountsInRoot(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSAccountsInRootRequest(c.Server, onboardingID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisionOnboardingConfigurationWithBody(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisionOnboardingConfigurationRequestWithBody(c.Server, onboardingID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisionOnboardingConfiguration(ctx context.Context, onboardingID OnboardingID, body ProvisionOnboardingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisionOnboardingConfigurationRequest(c.Server, onboardingID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSAccountsInParent(ctx context.Context, onboardingID OnboardingID, organizationalUnitID OrganizationalUnitID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSAccountsInParentRequest(c.Server, onboardingID, organizationalUnitID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyOnboardingWithBody(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyOnboardingRequestWithBody(c.Server, onboardingID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyOnboarding(ctx context.Context, onboardingID OnboardingID, body NotifyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyOnboardingRequest(c.Server, onboardingID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenAPIJSON(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenAPIJSONRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlatformVersions(ctx context.Context, params *ListPlatformVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlatformVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlugins(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlugin(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginRequest(c.Server, teamName, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersions(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionsRequest(c.Server, teamName, pluginKind, pluginName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginVersionRequest(c.Server, teamName, pluginKind, pluginName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPluginAsset(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPluginAssetRequest(c.Server, teamName, pluginKind, pluginName, versionName, targetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionTablesRequest(c.Server, teamName, pluginKind, pluginName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginVersionTable(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginVersionTableRequest(c.Server, teamName, pluginKind, pluginName, versionName, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicyMetrics(ctx context.Context, params *GetPolicyMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetViolationsByDomain(ctx context.Context, params *GetViolationsByDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetViolationsByDomainRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetViolationsHistory(ctx context.Context, params *GetViolationsHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetViolationsHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyID PolicyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyID PolicyID, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TogglePolicy(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTogglePolicyRequest(c.Server, policyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicyViolations(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyViolationsRequest(c.Server, policyID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicyViolationsHistory(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyViolationsHistoryRequest(c.Server, policyID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicyGroups(ctx context.Context, params *ListPolicyGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPolicyGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyGroup(ctx context.Context, body CreatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicyGroup(ctx context.Context, policyGroupID PolicyGroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyGroupRequest(c.Server, policyGroupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPoliciesInGroup(ctx context.Context, policyGroupID PolicyGroupID, params *ListPoliciesInGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesInGroupRequest(c.Server, policyGroupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyGroupWithBody(ctx context.Context, policyGroupID PolicyGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyGroupRequestWithBody(c.Server, policyGroupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyGroup(ctx context.Context, policyGroupID PolicyGroupID, body UpdatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyGroupRequest(c.Server, policyGroupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllQueries(ctx context.Context, params *ListAllQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllQueriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteAdHocQueryWithBody(ctx context.Context, params *ExecuteAdHocQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteAdHocQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteAdHocQuery(ctx context.Context, params *ExecuteAdHocQueryParams, body ExecuteAdHocQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteAdHocQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveQuery(ctx context.Context, body SaveQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQueryTags(ctx context.Context, params *ListQueryTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQueryTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQuery(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryRequest(c.Server, queryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSavedQuery(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSavedQueryRequest(c.Server, queryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQueryWithBody(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQueryRequestWithBody(c.Server, queryID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQuery(ctx context.Context, queryID QueryID, body UpdateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQueryRequest(c.Server, queryID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlert(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAlertRequest(c.Server, queryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteSavedQuery(ctx context.Context, queryID QueryID, params *ExecuteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteSavedQueryRequest(c.Server, queryID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryListFilters(ctx context.Context, queryID QueryID, params *QueryListFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryListFiltersRequest(c.Server, queryID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuerySaveFilterWithBody(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerySaveFilterRequestWithBody(c.Server, queryID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuerySaveFilter(ctx context.Context, queryID QueryID, body QuerySaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerySaveFilterRequest(c.Server, queryID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryListFilterTags(ctx context.Context, queryID QueryID, params *QueryListFilterTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryListFilterTagsRequest(c.Server, queryID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllRBACPermissions(ctx context.Context, params *ListAllRBACPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllRBACPermissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRBACPermissionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRBACPermissionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRBACPermission(ctx context.Context, body CreateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRBACPermissionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRBACPermission(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRBACPermissionRequest(c.Server, rbacPermissionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRBACPermission(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRBACPermissionRequest(c.Server, rbacPermissionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRBACPermissionWithBody(ctx context.Context, rbacPermissionID RBACPermissionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRBACPermissionRequestWithBody(c.Server, rbacPermissionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRBACPermission(ctx context.Context, rbacPermissionID RBACPermissionID, body UpdateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRBACPermissionRequest(c.Server, rbacPermissionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllRBACRoles(ctx context.Context, params *ListAllRBACRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllRBACRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRBACRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRBACRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRBACRole(ctx context.Context, body CreateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRBACRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRBACRole(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRBACRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRBACRole(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRBACRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRBACRoleWithBody(ctx context.Context, roleID RoleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRBACRoleRequestWithBody(c.Server, roleID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRBACRole(ctx context.Context, roleID RoleID, body UpdateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRBACRoleRequest(c.Server, roleID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReports(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReport(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportTemplates(ctx context.Context, params *ListReportTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReportTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReportTemplate(ctx context.Context, body CreateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReportTemplate(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReportTemplateRequest(c.Server, templateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportTemplate(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportTemplateRequest(c.Server, templateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReportTemplateWithBody(ctx context.Context, templateId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReportTemplateRequestWithBody(c.Server, templateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReportTemplate(ctx context.Context, templateId openapi_types.UUID, body UpdateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReportTemplateRequest(c.Server, templateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReport(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReportRequest(c.Server, reportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReport(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportRequest(c.Server, reportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReportWithBody(ctx context.Context, reportId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReportRequestWithBody(c.Server, reportId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReport(ctx context.Context, reportId openapi_types.UUID, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReportRequest(c.Server, reportId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettings(ctx context.Context, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataSettings(ctx context.Context, body UpdateDataSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSlackConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSlackConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSlackConnection(ctx context.Context, body CreateSlackConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSlackConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSlackChannels(ctx context.Context, id openapi_types.UUID, params *ListSlackChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSlackChannelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncDestinationTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncDestinationTestConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncDestinationTestConnection(ctx context.Context, body CreateSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncDestinationTestConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncDestinationTestConnection(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncDestinationTestConnectionRequest(c.Server, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncDestinationWithBody(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncDestinationRequestWithBody(c.Server, syncDestinationTestConnectionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncDestination(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncDestinationRequest(c.Server, syncDestinationTestConnectionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncDestinationTestConnectionLogsLive(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncDestinationTestConnectionLogsLiveRequest(c.Server, syncDestinationTestConnectionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncDestinationTestConnectionLogsQuery(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncDestinationTestConnectionLogsQueryRequest(c.Server, syncDestinationTestConnectionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteSyncDestinationTestConnectionWithBody(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteSyncDestinationTestConnectionRequestWithBody(c.Server, syncDestinationTestConnectionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteSyncDestinationTestConnection(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body PromoteSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteSyncDestinationTestConnectionRequest(c.Server, syncDestinationTestConnectionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncDestinations(ctx context.Context, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncDestinationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncDestinationRequest(c.Server, syncDestinationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncDestinationRequest(c.Server, syncDestinationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncDestinationWithBody(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncDestinationRequestWithBody(c.Server, syncDestinationName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncDestinationRequest(c.Server, syncDestinationName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncDestinationSyncs(ctx context.Context, syncDestinationName SyncDestinationName, params *ListSyncDestinationSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncDestinationSyncsRequest(c.Server, syncDestinationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestConnectionForSyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestConnectionForSyncDestinationRequest(c.Server, syncDestinationName, syncTestConnectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncSourceTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncSourceTestConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncSourceTestConnection(ctx context.Context, body CreateSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncSourceTestConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncSourceTestConnection(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncSourceTestConnectionRequest(c.Server, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncSourceWithBody(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncSourceRequestWithBody(c.Server, syncSourceTestConnectionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncSource(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncSourceRequest(c.Server, syncSourceTestConnectionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncSourceTestConnectionLogsLive(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncSourceTestConnectionLogsLiveRequest(c.Server, syncSourceTestConnectionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncSourceTestConnectionLogsQuery(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncSourceTestConnectionLogsQueryRequest(c.Server, syncSourceTestConnectionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteSyncSourceTestConnectionWithBody(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteSyncSourceTestConnectionRequestWithBody(c.Server, syncSourceTestConnectionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteSyncSourceTestConnection(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body PromoteSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteSyncSourceTestConnectionRequest(c.Server, syncSourceTestConnectionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncSources(ctx context.Context, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSyncSource(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncSourceRequest(c.Server, syncSourceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncSource(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncSourceRequest(c.Server, syncSourceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncSourceWithBody(ctx context.Context, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncSourceRequestWithBody(c.Server, syncSourceName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncSource(ctx context.Context, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncSourceRequest(c.Server, syncSourceName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncSourceSyncs(ctx context.Context, syncSourceName SyncSourceName, params *ListSyncSourceSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncSourceSyncsRequest(c.Server, syncSourceName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestConnectionForSyncSource(ctx context.Context, syncSourceName SyncSourceName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestConnectionForSyncSourceRequest(c.Server, syncSourceName, syncTestConnectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncTransformers(ctx context.Context, params *ListSyncTransformersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncTransformersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSyncTransformer(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncTransformerRequest(c.Server, syncTransformerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncTransformer(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncTransformerRequest(c.Server, syncTransformerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTransformerWithBody(ctx context.Context, syncTransformerName SyncTransformerName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTransformerRequestWithBody(c.Server, syncTransformerName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTransformer(ctx context.Context, syncTransformerName SyncTransformerName, body UpdateSyncTransformerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTransformerRequest(c.Server, syncTransformerName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncTransformerSyncDestinations(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncTransformerSyncDestinationsRequest(c.Server, syncTransformerName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncTransformerSyncs(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncTransformerSyncsRequest(c.Server, syncTransformerName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncUpgrades(ctx context.Context, params *ListSyncUpgradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncUpgradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncs(ctx context.Context, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSync(ctx context.Context, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSync(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncRequest(c.Server, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSync(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRequest(c.Server, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncWithBody(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRequestWithBody(c.Server, syncName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSync(ctx context.Context, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRequest(c.Server, syncName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncRuns(ctx context.Context, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncRunsRequest(c.Server, syncName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRun(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunRequest(c.Server, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRun(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunRequest(c.Server, syncName, syncRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncRunWithBody(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRunRequestWithBody(c.Server, syncName, syncRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncRun(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRunRequest(c.Server, syncName, syncRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRunLogsLive(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsLiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunLogsLiveRequest(c.Server, syncName, syncRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRunLogsQuery(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunLogsQueryRequest(c.Server, syncName, syncRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRunProgressWithBody(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunProgressRequestWithBody(c.Server, syncName, syncRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRunProgress(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunProgressRequest(c.Server, syncName, syncRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRunStats(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunStatsRequest(c.Server, syncName, syncRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRunTables(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunTablesRequest(c.Server, syncName, syncRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTablesData(ctx context.Context, params *GetTablesDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TablesDataActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTablesDataActionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TablesDataAction(ctx context.Context, body TablesDataActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTablesDataActionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BatchTableSchemas(ctx context.Context, params *BatchTableSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBatchTableSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableListColumns(ctx context.Context, tableName TableName, params *TableListColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableListColumnsRequest(c.Server, tableName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableColumnListValues(ctx context.Context, tableName TableName, columnName ColumnName, params *TableColumnListValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableColumnListValuesRequest(c.Server, tableName, columnName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableListRows(ctx context.Context, tableName TableName, params *TableListRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableListRowsRequest(c.Server, tableName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableRowById(ctx context.Context, tableName TableName, tableRowId TableRowId, params *TableRowByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableRowByIdRequest(c.Server, tableName, tableRowId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableListFilters(ctx context.Context, tableName TableName, params *TableListFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableListFiltersRequest(c.Server, tableName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableSaveFilterWithBody(ctx context.Context, tableName TableName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableSaveFilterRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableSaveFilter(ctx context.Context, tableName TableName, body TableSaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableSaveFilterRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableListFilterTags(ctx context.Context, tableName TableName, params *TableListFilterTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableListFilterTagsRequest(c.Server, tableName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableSchema(ctx context.Context, tableName TableName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableSchemaRequest(c.Server, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPluginAssetByTeam(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPluginAssetByTeamRequest(c.Server, teamName, pluginTeam, pluginKind, pluginName, versionName, targetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncDestinationTeamWithBody(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncDestinationTeamRequestWithBody(c.Server, teamName, syncDestinationTestConnectionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncDestinationTeam(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncDestinationTeamRequest(c.Server, teamName, syncDestinationTestConnectionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncSourceTeamWithBody(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncSourceTeamRequestWithBody(c.Server, teamName, syncSourceTestConnectionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionForSyncSourceTeam(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionForSyncSourceTeamRequest(c.Server, teamName, syncSourceTestConnectionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRunProgressTeamWithBody(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunProgressTeamRequestWithBody(c.Server, teamName, syncName, syncRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRunProgressTeam(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunProgressTeamRequest(c.Server, teamName, syncName, syncRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamUsageSummary(ctx context.Context, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamUsageSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupedTeamUsageSummary(ctx context.Context, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupedTeamUsageSummaryRequest(c.Server, groupBy, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendAnonymousEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendAnonymousEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendAnonymousEvent(ctx context.Context, body SendAnonymousEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendAnonymousEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateUser(ctx context.Context, body AuthenticateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeUserPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeUserPassword(ctx context.Context, body ChangeUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeUserPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomer(ctx context.Context, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendUserEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendUserEvent(ctx context.Context, body SendUserEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginUser(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserTOTPDelete(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserTOTPDeleteRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserTOTPSetup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserTOTPSetupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserTOTPVerifyWithBody(ctx context.Context, params *UserTOTPVerifyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserTOTPVerifyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserTOTPVerify(ctx context.Context, params *UserTOTPVerifyParams, body UserTOTPVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserTOTPVerifyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUser(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserTOTP(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserTOTPRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncDestinationTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncDestinationTestConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncDestinationTestConnection(ctx context.Context, body CreateV2SyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncDestinationTestConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2SyncDestinations(ctx context.Context, params *GetV2SyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SyncDestinationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncDestinationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncDestinationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncDestination(ctx context.Context, body CreateV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncDestinationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2SyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2SyncDestinationRequest(c.Server, syncDestinationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2SyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SyncDestinationRequest(c.Server, syncDestinationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2SyncDestinationWithBody(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2SyncDestinationRequestWithBody(c.Server, syncDestinationName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2SyncDestination(ctx context.Context, syncDestinationName SyncDestinationName, body PatchV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2SyncDestinationRequest(c.Server, syncDestinationName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncIntegrationTestConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncIntegrationTestConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncIntegrationTestConnection(ctx context.Context, body CreateV2SyncIntegrationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncIntegrationTestConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListV2SyncIntegrations(ctx context.Context, params *ListV2SyncIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListV2SyncIntegrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncIntegrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncIntegrationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2SyncIntegration(ctx context.Context, body CreateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2SyncIntegrationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2SyncIntegration(ctx context.Context, syncName SyncName, params *DeleteV2SyncIntegrationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2SyncIntegrationRequest(c.Server, syncName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2SyncIntegration(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SyncIntegrationRequest(c.Server, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateV2SyncIntegrationWithBody(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateV2SyncIntegrationRequestWithBody(c.Server, syncName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateV2SyncIntegration(ctx context.Context, syncName SyncName, body UpdateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateV2SyncIntegrationRequest(c.Server, syncName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewIndexRequest generates requests for Index
func NewIndexRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllAlertsRequest generates requests for ListAllAlerts
func NewListAllAlertsRequest(server string, params *ListAllAlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlertStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.AlertStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Enabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enabled", runtime.ParamLocationQuery, *params.Enabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueryTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.QueryTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestUnsavedAlertRequest calls the generic TestUnsavedAlert builder with application/json body
func NewTestUnsavedAlertRequest(server string, params *TestUnsavedAlertParams, body TestUnsavedAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestUnsavedAlertRequestWithBody(server, params, "application/json", bodyReader)
}

// NewTestUnsavedAlertRequestWithBody generates requests for TestUnsavedAlert with any type of body
func NewTestUnsavedAlertRequestWithBody(server string, params *TestUnsavedAlertParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QueryID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query_id", runtime.ParamLocationQuery, *params.QueryID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAPIKeysRequest generates requests for ListAPIKeys
func NewListAPIKeysRequest(server string, params *ListAPIKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAPIKeyRequest calls the generic CreateAPIKey builder with application/json body
func NewCreateAPIKeyRequest(server string, body CreateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAPIKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAPIKeyRequestWithBody generates requests for CreateAPIKey with any type of body
func NewCreateAPIKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAPIKeyRequest generates requests for DeleteAPIKey
func NewDeleteAPIKeyRequest(server string, apiKeyID APIKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey_id", runtime.ParamLocationPath, apiKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit-logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityDisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entity_display_name", runtime.ParamLocationQuery, *params.EntityDisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserIpAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_ip_address", runtime.ParamLocationQuery, *params.UserIpAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuditLogRequest generates requests for GetAuditLog
func NewGetAuditLogRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit-logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSAMLRequest generates requests for GetSAML
func NewGetSAMLRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSAMLRequest calls the generic UpdateSAML builder with application/json body
func NewUpdateSAMLRequest(server string, body UpdateSAMLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSAMLRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateSAMLRequestWithBody generates requests for UpdateSAML with any type of body
func NewUpdateSAMLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateConversationRequest calls the generic CreateConversation builder with application/json body
func NewCreateConversationRequest(server string, body CreateConversationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConversationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConversationRequestWithBody generates requests for CreateConversation with any type of body
func NewCreateConversationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConversationRequest generates requests for GetConversation
func NewGetConversationRequest(server string, conversationID ConversationID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conversation_id", runtime.ParamLocationPath, conversationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendMessageRequest calls the generic SendMessage builder with application/json body
func NewSendMessageRequest(server string, conversationID ConversationID, body SendMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageRequestWithBody(server, conversationID, "application/json", bodyReader)
}

// NewSendMessageRequestWithBody generates requests for SendMessage with any type of body
func NewSendMessageRequestWithBody(server string, conversationID ConversationID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conversation_id", runtime.ParamLocationPath, conversationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCustomColumnsRequest generates requests for ListAllCustomColumns
func NewListAllCustomColumnsRequest(server string, params *ListAllCustomColumnsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-columns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomColumnSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.CustomColumnSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomColumnSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.CustomColumnSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveCustomColumnRequest calls the generic SaveCustomColumn builder with application/json body
func NewSaveCustomColumnRequest(server string, body SaveCustomColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveCustomColumnRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveCustomColumnRequestWithBody generates requests for SaveCustomColumn with any type of body
func NewSaveCustomColumnRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-columns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomColumnRequest generates requests for DeleteCustomColumn
func NewDeleteCustomColumnRequest(server string, customColumnID CustomColumnID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_column_id", runtime.ParamLocationPath, customColumnID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-columns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomColumnRequest generates requests for GetCustomColumn
func NewGetCustomColumnRequest(server string, customColumnID CustomColumnID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_column_id", runtime.ParamLocationPath, customColumnID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-columns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomColumnRequest calls the generic UpdateCustomColumn builder with application/json body
func NewUpdateCustomColumnRequest(server string, customColumnID CustomColumnID, body UpdateCustomColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomColumnRequestWithBody(server, customColumnID, "application/json", bodyReader)
}

// NewUpdateCustomColumnRequestWithBody generates requests for UpdateCustomColumn with any type of body
func NewUpdateCustomColumnRequestWithBody(server string, customColumnID CustomColumnID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_column_id", runtime.ParamLocationPath, customColumnID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-columns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFiltersRequest generates requests for ListFilters
func NewListFiltersRequest(server string, params *ListFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.FilterTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_filter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpressionFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expression_filter", runtime.ParamLocationQuery, *params.ExpressionFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFilterTagsRequest generates requests for ListFilterTags
func NewListFilterTagsRequest(server string, params *ListFilterTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFilterRequest generates requests for DeleteFilter
func NewDeleteFilterRequest(server string, filterID FilterID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_id", runtime.ParamLocationPath, filterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterByIDRequest generates requests for GetFilterByID
func NewGetFilterByIDRequest(server string, filterID FilterID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_id", runtime.ParamLocationPath, filterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFilterRequest calls the generic UpdateFilter builder with application/json body
func NewUpdateFilterRequest(server string, filterID FilterID, body UpdateFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFilterRequestWithBody(server, filterID, "application/json", bodyReader)
}

// NewUpdateFilterRequestWithBody generates requests for UpdateFilter with any type of body
func NewUpdateFilterRequestWithBody(server string, filterID FilterID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_id", runtime.ParamLocationPath, filterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckHeadRequest generates requests for HealthCheckHead
func NewHealthCheckHeadRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNotificationsRequest generates requests for ListNotifications
func NewListNotificationsRequest(server string, params *ListNotificationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severities", runtime.ParamLocationQuery, params.Severities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policy_group_ids", runtime.ParamLocationQuery, params.PolicyGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNotificationDestinationRequest generates requests for DeleteNotificationDestination
func NewDeleteNotificationDestinationRequest(server string, notificationDestinationId NotificationDestinationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_destination_id", runtime.ParamLocationPath, notificationDestinationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destination/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationDestinationRequest generates requests for GetNotificationDestination
func NewGetNotificationDestinationRequest(server string, notificationDestinationId NotificationDestinationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_destination_id", runtime.ParamLocationPath, notificationDestinationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destination/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationDestinationRequest calls the generic UpdateNotificationDestination builder with application/json body
func NewUpdateNotificationDestinationRequest(server string, notificationDestinationId NotificationDestinationId, body UpdateNotificationDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationDestinationRequestWithBody(server, notificationDestinationId, "application/json", bodyReader)
}

// NewUpdateNotificationDestinationRequestWithBody generates requests for UpdateNotificationDestination with any type of body
func NewUpdateNotificationDestinationRequestWithBody(server string, notificationDestinationId NotificationDestinationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_destination_id", runtime.ParamLocationPath, notificationDestinationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destination/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationDestinationAlertsRequest generates requests for GetNotificationDestinationAlerts
func NewGetNotificationDestinationAlertsRequest(server string, notificationDestinationId NotificationDestinationId, params *GetNotificationDestinationAlertsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_destination_id", runtime.ParamLocationPath, notificationDestinationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destination/%s/alerts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestNotificationDestinationRequest generates requests for TestNotificationDestination
func NewTestNotificationDestinationRequest(server string, notificationDestinationId NotificationDestinationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_destination_id", runtime.ParamLocationPath, notificationDestinationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destination/%s/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNotificationDestinationsRequest generates requests for ListAllNotificationDestinations
func NewListAllNotificationDestinationsRequest(server string, params *ListAllNotificationDestinationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destinations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationDestinationRequest calls the generic CreateNotificationDestination builder with application/json body
func NewCreateNotificationDestinationRequest(server string, body CreateNotificationDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationDestinationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationDestinationRequestWithBody generates requests for CreateNotificationDestination with any type of body
func NewCreateNotificationDestinationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destinations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestUnsavedNotificationDestinationRequest calls the generic TestUnsavedNotificationDestination builder with application/json body
func NewTestUnsavedNotificationDestinationRequest(server string, body TestUnsavedNotificationDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestUnsavedNotificationDestinationRequestWithBody(server, "application/json", bodyReader)
}

// NewTestUnsavedNotificationDestinationRequestWithBody generates requests for TestUnsavedNotificationDestination with any type of body
func NewTestUnsavedNotificationDestinationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/destinations/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAWSOnboardingRequest calls the generic CreateAWSOnboarding builder with application/json body
func NewCreateAWSOnboardingRequest(server string, body CreateAWSOnboardingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAWSOnboardingRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAWSOnboardingRequestWithBody generates requests for CreateAWSOnboarding with any type of body
func NewCreateAWSOnboardingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/onboardings/aws/oidc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAWSOnboardingRequest generates requests for GetAWSOnboarding
func NewGetAWSOnboardingRequest(server string, onboardingID OnboardingID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "onboarding_id", runtime.ParamLocationPath, onboardingID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/onboardings/aws/oidc/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSAccountsInRootRequest generates requests for GetAWSAccountsInRoot
func NewGetAWSAccountsInRootRequest(server string, onboardingID OnboardingID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "onboarding_id", runtime.ParamLocationPath, onboardingID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/onboardings/aws/oidc/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProvisionOnboardingConfigurationRequest calls the generic ProvisionOnboardingConfiguration builder with application/json body
func NewProvisionOnboardingConfigurationRequest(server string, onboardingID OnboardingID, body ProvisionOnboardingConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProvisionOnboardingConfigurationRequestWithBody(server, onboardingID, "application/json", bodyReader)
}

// NewProvisionOnboardingConfigurationRequestWithBody generates requests for ProvisionOnboardingConfiguration with any type of body
func NewProvisionOnboardingConfigurationRequestWithBody(server string, onboardingID OnboardingID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "onboarding_id", runtime.ParamLocationPath, onboardingID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/onboardings/aws/oidc/%s/accounts/provision", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAWSAccountsInParentRequest generates requests for GetAWSAccountsInParent
func NewGetAWSAccountsInParentRequest(server string, onboardingID OnboardingID, organizationalUnitID OrganizationalUnitID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "onboarding_id", runtime.ParamLocationPath, onboardingID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "aws_orgunit_id", runtime.ParamLocationPath, organizationalUnitID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/onboardings/aws/oidc/%s/accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotifyOnboardingRequest calls the generic NotifyOnboarding builder with application/json body
func NewNotifyOnboardingRequest(server string, onboardingID OnboardingID, body NotifyOnboardingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotifyOnboardingRequestWithBody(server, onboardingID, "application/json", bodyReader)
}

// NewNotifyOnboardingRequestWithBody generates requests for NotifyOnboarding with any type of body
func NewNotifyOnboardingRequestWithBody(server string, onboardingID OnboardingID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "onboarding_id", runtime.ParamLocationPath, onboardingID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/onboardings/aws/oidc/%s/notify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenAPIJSONRequest generates requests for GetOpenAPIJSON
func NewGetOpenAPIJSONRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformInfoRequest generates requests for GetPlatformInfo
func NewGetPlatformInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlatformVersionsRequest generates requests for ListPlatformVersions
func NewListPlatformVersionsRequest(server string, params *ListPlatformVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform-versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginsRequest generates requests for ListPlugins
func NewListPluginsRequest(server string, params *ListPluginsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeReleaseStages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_release_stages", runtime.ParamLocationQuery, params.IncludeReleaseStages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeReleaseStages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_release_stages", runtime.ParamLocationQuery, params.ExcludeReleaseStages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginRequest generates requests for GetPlugin
func NewGetPluginRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginVersionsRequest generates requests for ListPluginVersions
func NewListPluginVersionsRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDrafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_drafts", runtime.ParamLocationQuery, *params.IncludeDrafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFips != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fips", runtime.ParamLocationQuery, *params.IncludeFips); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePrereleases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_prereleases", runtime.ParamLocationQuery, *params.IncludePrereleases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersionFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version_filter", runtime.ParamLocationQuery, *params.VersionFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginVersionRequest generates requests for GetPluginVersion
func NewGetPluginVersionRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadPluginAssetRequest generates requests for DownloadPluginAsset
func NewDownloadPluginAssetRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewListPluginVersionTablesRequest generates requests for ListPluginVersionTables
func NewListPluginVersionTablesRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginVersionTableRequest generates requests for GetPluginVersionTable
func NewGetPluginVersionTableRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/tables/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.PolicyStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severities", runtime.ParamLocationQuery, params.Severities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policy_group_ids", runtime.ParamLocationQuery, params.PolicyGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, *params.SortDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPolicyMetricsRequest generates requests for GetPolicyMetrics
func NewGetPolicyMetricsRequest(server string, params *GetPolicyMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Severities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severities", runtime.ParamLocationQuery, params.Severities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policy_group_ids", runtime.ParamLocationQuery, params.PolicyGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetViolationsByDomainRequest generates requests for GetViolationsByDomain
func NewGetViolationsByDomainRequest(server string, params *GetViolationsByDomainParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/violations-by-domain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Severities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severities", runtime.ParamLocationQuery, params.Severities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policy_group_ids", runtime.ParamLocationQuery, params.PolicyGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetViolationsHistoryRequest generates requests for GetViolationsHistory
func NewGetViolationsHistoryRequest(server string, params *GetViolationsHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/violations-history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severities", runtime.ParamLocationQuery, params.Severities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policy_group_ids", runtime.ParamLocationQuery, params.PolicyGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyID PolicyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyID PolicyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyID PolicyID, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyID, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyID PolicyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTogglePolicyRequest generates requests for TogglePolicy
func NewTogglePolicyRequest(server string, policyID PolicyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s/toggle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyViolationsRequest generates requests for GetPolicyViolations
func NewGetPolicyViolationsRequest(server string, policyID PolicyID, params *GetPolicyViolationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s/violations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyViolationsHistoryRequest generates requests for GetPolicyViolationsHistory
func NewGetPolicyViolationsHistoryRequest(server string, policyID PolicyID, params *GetPolicyViolationsHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s/violations-history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPolicyGroupsRequest generates requests for ListPolicyGroups
func NewListPolicyGroupsRequest(server string, params *ListPolicyGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policy-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severities", runtime.ParamLocationQuery, params.Severities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyGroupRequest calls the generic CreatePolicyGroup builder with application/json body
func NewCreatePolicyGroupRequest(server string, body CreatePolicyGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyGroupRequestWithBody generates requests for CreatePolicyGroup with any type of body
func NewCreatePolicyGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policy-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyGroupRequest generates requests for DeletePolicyGroup
func NewDeletePolicyGroupRequest(server string, policyGroupID PolicyGroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_group_id", runtime.ParamLocationPath, policyGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policy-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesInGroupRequest generates requests for ListPoliciesInGroup
func NewListPoliciesInGroupRequest(server string, policyGroupID PolicyGroupID, params *ListPoliciesInGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_group_id", runtime.ParamLocationPath, policyGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policy-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, *params.SortDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyGroupRequest calls the generic UpdatePolicyGroup builder with application/json body
func NewUpdatePolicyGroupRequest(server string, policyGroupID PolicyGroupID, body UpdatePolicyGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyGroupRequestWithBody(server, policyGroupID, "application/json", bodyReader)
}

// NewUpdatePolicyGroupRequestWithBody generates requests for UpdatePolicyGroup with any type of body
func NewUpdatePolicyGroupRequestWithBody(server string, policyGroupID PolicyGroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_group_id", runtime.ParamLocationPath, policyGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policy-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllQueriesRequest generates requests for ListAllQueries
func NewListAllQueriesRequest(server string, params *ListAllQueriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueryTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.QueryTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_filter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueryFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query_filter", runtime.ParamLocationQuery, *params.QueryFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlertConfigured != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "alert_configured", runtime.ParamLocationQuery, *params.AlertConfigured); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlertMessageFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "alert_message_filter", runtime.ParamLocationQuery, *params.AlertMessageFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlertEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "alert_enabled", runtime.ParamLocationQuery, *params.AlertEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteAdHocQueryRequest calls the generic ExecuteAdHocQuery builder with application/json body
func NewExecuteAdHocQueryRequest(server string, params *ExecuteAdHocQueryParams, body ExecuteAdHocQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteAdHocQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExecuteAdHocQueryRequestWithBody generates requests for ExecuteAdHocQuery with any type of body
func NewExecuteAdHocQueryRequestWithBody(server string, params *ExecuteAdHocQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Selects != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, params.Selects); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterIDs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, params.FilterIDs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_by", runtime.ParamLocationQuery, params.GroupBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSaveQueryRequest calls the generic SaveQuery builder with application/json body
func NewSaveQueryRequest(server string, body SaveQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveQueryRequestWithBody generates requests for SaveQuery with any type of body
func NewSaveQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListQueryTagsRequest generates requests for ListQueryTags
func NewListQueryTagsRequest(server string, params *ListQueryTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSavedQueryRequest generates requests for DeleteSavedQuery
func NewDeleteSavedQueryRequest(server string, queryID QueryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSavedQueryRequest generates requests for GetSavedQuery
func NewGetSavedQueryRequest(server string, queryID QueryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateQueryRequest calls the generic UpdateQuery builder with application/json body
func NewUpdateQueryRequest(server string, queryID QueryID, body UpdateQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateQueryRequestWithBody(server, queryID, "application/json", bodyReader)
}

// NewUpdateQueryRequestWithBody generates requests for UpdateQuery with any type of body
func NewUpdateQueryRequestWithBody(server string, queryID QueryID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAlertRequest generates requests for DeleteAlert
func NewDeleteAlertRequest(server string, queryID QueryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s/alert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteSavedQueryRequest generates requests for ExecuteSavedQuery
func NewExecuteSavedQueryRequest(server string, queryID QueryID, params *ExecuteSavedQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s/execute", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Selects != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, params.Selects); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterIDs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, params.FilterIDs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_by", runtime.ParamLocationQuery, params.GroupBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryListFiltersRequest generates requests for QueryListFilters
func NewQueryListFiltersRequest(server string, queryID QueryID, params *QueryListFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.FilterTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQuerySaveFilterRequest calls the generic QuerySaveFilter builder with application/json body
func NewQuerySaveFilterRequest(server string, queryID QueryID, body QuerySaveFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQuerySaveFilterRequestWithBody(server, queryID, "application/json", bodyReader)
}

// NewQuerySaveFilterRequestWithBody generates requests for QuerySaveFilter with any type of body
func NewQuerySaveFilterRequestWithBody(server string, queryID QueryID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryListFilterTagsRequest generates requests for QueryListFilterTags
func NewQueryListFilterTagsRequest(server string, queryID QueryID, params *QueryListFilterTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries/%s/filters/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllRBACPermissionsRequest generates requests for ListAllRBACPermissions
func NewListAllRBACPermissionsRequest(server string, params *ListAllRBACPermissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RBACPermissionSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.RBACPermissionSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RBACPermissionSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.RBACPermissionSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRBACPermissionRequest calls the generic CreateRBACPermission builder with application/json body
func NewCreateRBACPermissionRequest(server string, body CreateRBACPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRBACPermissionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRBACPermissionRequestWithBody generates requests for CreateRBACPermission with any type of body
func NewCreateRBACPermissionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRBACPermissionRequest generates requests for DeleteRBACPermission
func NewDeleteRBACPermissionRequest(server string, rbacPermissionID RBACPermissionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, rbacPermissionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRBACPermissionRequest generates requests for GetRBACPermission
func NewGetRBACPermissionRequest(server string, rbacPermissionID RBACPermissionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, rbacPermissionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRBACPermissionRequest calls the generic UpdateRBACPermission builder with application/json body
func NewUpdateRBACPermissionRequest(server string, rbacPermissionID RBACPermissionID, body UpdateRBACPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRBACPermissionRequestWithBody(server, rbacPermissionID, "application/json", bodyReader)
}

// NewUpdateRBACPermissionRequestWithBody generates requests for UpdateRBACPermission with any type of body
func NewUpdateRBACPermissionRequestWithBody(server string, rbacPermissionID RBACPermissionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, rbacPermissionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllRBACRolesRequest generates requests for ListAllRBACRoles
func NewListAllRBACRolesRequest(server string, params *ListAllRBACRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RBACRoleSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.RBACRoleSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RBACRoleSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.RBACRoleSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRBACRoleRequest calls the generic CreateRBACRole builder with application/json body
func NewCreateRBACRoleRequest(server string, body CreateRBACRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRBACRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRBACRoleRequestWithBody generates requests for CreateRBACRole with any type of body
func NewCreateRBACRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRBACRoleRequest generates requests for DeleteRBACRole
func NewDeleteRBACRoleRequest(server string, roleID RoleID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRBACRoleRequest generates requests for GetRBACRole
func NewGetRBACRoleRequest(server string, roleID RoleID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRBACRoleRequest calls the generic UpdateRBACRole builder with application/json body
func NewUpdateRBACRoleRequest(server string, roleID RoleID, body UpdateRBACRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRBACRoleRequestWithBody(server, roleID, "application/json", bodyReader)
}

// NewUpdateRBACRoleRequestWithBody generates requests for UpdateRBACRole with any type of body
func NewUpdateRBACRoleRequestWithBody(server string, roleID RoleID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rbac/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReportsRequest generates requests for ListReports
func NewListReportsRequest(server string, params *ListReportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Visibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.ReportSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.ReportSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReportRequest calls the generic CreateReport builder with application/json body
func NewCreateReportRequest(server string, body CreateReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateReportRequestWithBody generates requests for CreateReport with any type of body
func NewCreateReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReportTemplatesRequest generates requests for ListReportTemplates
func NewListReportTemplatesRequest(server string, params *ListReportTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportTemplateSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.ReportTemplateSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportTemplateSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.ReportTemplateSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReportTemplateRequest calls the generic CreateReportTemplate builder with application/json body
func NewCreateReportTemplateRequest(server string, body CreateReportTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReportTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateReportTemplateRequestWithBody generates requests for CreateReportTemplate with any type of body
func NewCreateReportTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReportTemplateRequest generates requests for DeleteReportTemplate
func NewDeleteReportTemplateRequest(server string, templateId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportTemplateRequest generates requests for GetReportTemplate
func NewGetReportTemplateRequest(server string, templateId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReportTemplateRequest calls the generic UpdateReportTemplate builder with application/json body
func NewUpdateReportTemplateRequest(server string, templateId openapi_types.UUID, body UpdateReportTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReportTemplateRequestWithBody(server, templateId, "application/json", bodyReader)
}

// NewUpdateReportTemplateRequestWithBody generates requests for UpdateReportTemplate with any type of body
func NewUpdateReportTemplateRequestWithBody(server string, templateId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReportRequest generates requests for DeleteReport
func NewDeleteReportRequest(server string, reportId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportRequest generates requests for GetReport
func NewGetReportRequest(server string, reportId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReportRequest calls the generic UpdateReport builder with application/json body
func NewUpdateReportRequest(server string, reportId openapi_types.UUID, body UpdateReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReportRequestWithBody(server, reportId, "application/json", bodyReader)
}

// NewUpdateReportRequestWithBody generates requests for UpdateReport with any type of body
func NewUpdateReportRequestWithBody(server string, reportId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSettingsRequest calls the generic UpdateSettings builder with application/json body
func NewUpdateSettingsRequest(server string, body UpdateSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateSettingsRequestWithBody generates requests for UpdateSettings with any type of body
func NewUpdateSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDataSettingsRequest generates requests for GetDataSettings
func NewGetDataSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataSettingsRequest calls the generic UpdateDataSettings builder with application/json body
func NewUpdateDataSettingsRequest(server string, body UpdateDataSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateDataSettingsRequestWithBody generates requests for UpdateDataSettings with any type of body
func NewUpdateDataSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSlackConnectionRequest calls the generic CreateSlackConnection builder with application/json body
func NewCreateSlackConnectionRequest(server string, body CreateSlackConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSlackConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSlackConnectionRequestWithBody generates requests for CreateSlackConnection with any type of body
func NewCreateSlackConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSlackChannelsRequest generates requests for ListSlackChannels
func NewListSlackChannelsRequest(server string, id openapi_types.UUID, params *ListSlackChannelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slack/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncDestinationTestConnectionRequest calls the generic CreateSyncDestinationTestConnection builder with application/json body
func NewCreateSyncDestinationTestConnectionRequest(server string, body CreateSyncDestinationTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncDestinationTestConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSyncDestinationTestConnectionRequestWithBody generates requests for CreateSyncDestinationTestConnection with any type of body
func NewCreateSyncDestinationTestConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destination-test-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncDestinationTestConnectionRequest generates requests for GetSyncDestinationTestConnection
func NewGetSyncDestinationTestConnectionRequest(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_test_connection_id", runtime.ParamLocationPath, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destination-test-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncTestConnectionForSyncDestinationRequest calls the generic UpdateSyncTestConnectionForSyncDestination builder with application/json body
func NewUpdateSyncTestConnectionForSyncDestinationRequest(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncTestConnectionForSyncDestinationRequestWithBody(server, syncDestinationTestConnectionID, "application/json", bodyReader)
}

// NewUpdateSyncTestConnectionForSyncDestinationRequestWithBody generates requests for UpdateSyncTestConnectionForSyncDestination with any type of body
func NewUpdateSyncTestConnectionForSyncDestinationRequestWithBody(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_test_connection_id", runtime.ParamLocationPath, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destination-test-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncDestinationTestConnectionLogsLiveRequest generates requests for GetSyncDestinationTestConnectionLogsLive
func NewGetSyncDestinationTestConnectionLogsLiveRequest(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsLiveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_test_connection_id", runtime.ParamLocationPath, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destination-test-connections/%s/logs/live", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetSyncDestinationTestConnectionLogsQueryRequest generates requests for GetSyncDestinationTestConnectionLogsQuery
func NewGetSyncDestinationTestConnectionLogsQueryRequest(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_test_connection_id", runtime.ParamLocationPath, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destination-test-connections/%s/logs/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewPromoteSyncDestinationTestConnectionRequest calls the generic PromoteSyncDestinationTestConnection builder with application/json body
func NewPromoteSyncDestinationTestConnectionRequest(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body PromoteSyncDestinationTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromoteSyncDestinationTestConnectionRequestWithBody(server, syncDestinationTestConnectionID, "application/json", bodyReader)
}

// NewPromoteSyncDestinationTestConnectionRequestWithBody generates requests for PromoteSyncDestinationTestConnection with any type of body
func NewPromoteSyncDestinationTestConnectionRequestWithBody(server string, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_test_connection_id", runtime.ParamLocationPath, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destination-test-connections/%s/promote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncDestinationsRequest generates requests for ListSyncDestinations
func NewListSyncDestinationsRequest(server string, params *ListSyncDestinationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destinations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncGenericSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncGenericSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSyncDestinationRequest generates requests for DeleteSyncDestination
func NewDeleteSyncDestinationRequest(server string, syncDestinationName SyncDestinationName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destinations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncDestinationRequest generates requests for GetSyncDestination
func NewGetSyncDestinationRequest(server string, syncDestinationName SyncDestinationName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destinations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncDestinationRequest calls the generic UpdateSyncDestination builder with application/json body
func NewUpdateSyncDestinationRequest(server string, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncDestinationRequestWithBody(server, syncDestinationName, "application/json", bodyReader)
}

// NewUpdateSyncDestinationRequestWithBody generates requests for UpdateSyncDestination with any type of body
func NewUpdateSyncDestinationRequestWithBody(server string, syncDestinationName SyncDestinationName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destinations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncDestinationSyncsRequest generates requests for ListSyncDestinationSyncs
func NewListSyncDestinationSyncsRequest(server string, syncDestinationName SyncDestinationName, params *ListSyncDestinationSyncsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destinations/%s/syncs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MigrationFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "migration_filter", runtime.ParamLocationQuery, *params.MigrationFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestConnectionForSyncDestinationRequest generates requests for GetTestConnectionForSyncDestination
func NewGetTestConnectionForSyncDestinationRequest(server string, syncDestinationName SyncDestinationName, syncTestConnectionId SyncTestConnectionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_test_connection_id", runtime.ParamLocationPath, syncTestConnectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-destinations/%s/test-connections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncSourceTestConnectionRequest calls the generic CreateSyncSourceTestConnection builder with application/json body
func NewCreateSyncSourceTestConnectionRequest(server string, body CreateSyncSourceTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncSourceTestConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSyncSourceTestConnectionRequestWithBody generates requests for CreateSyncSourceTestConnection with any type of body
func NewCreateSyncSourceTestConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-source-test-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncSourceTestConnectionRequest generates requests for GetSyncSourceTestConnection
func NewGetSyncSourceTestConnectionRequest(server string, syncSourceTestConnectionID SyncSourceTestConnectionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_test_connection_id", runtime.ParamLocationPath, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-source-test-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncTestConnectionForSyncSourceRequest calls the generic UpdateSyncTestConnectionForSyncSource builder with application/json body
func NewUpdateSyncTestConnectionForSyncSourceRequest(server string, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncTestConnectionForSyncSourceRequestWithBody(server, syncSourceTestConnectionID, "application/json", bodyReader)
}

// NewUpdateSyncTestConnectionForSyncSourceRequestWithBody generates requests for UpdateSyncTestConnectionForSyncSource with any type of body
func NewUpdateSyncTestConnectionForSyncSourceRequestWithBody(server string, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_test_connection_id", runtime.ParamLocationPath, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-source-test-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncSourceTestConnectionLogsLiveRequest generates requests for GetSyncSourceTestConnectionLogsLive
func NewGetSyncSourceTestConnectionLogsLiveRequest(server string, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsLiveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_test_connection_id", runtime.ParamLocationPath, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-source-test-connections/%s/logs/live", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetSyncSourceTestConnectionLogsQueryRequest generates requests for GetSyncSourceTestConnectionLogsQuery
func NewGetSyncSourceTestConnectionLogsQueryRequest(server string, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_test_connection_id", runtime.ParamLocationPath, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-source-test-connections/%s/logs/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewPromoteSyncSourceTestConnectionRequest calls the generic PromoteSyncSourceTestConnection builder with application/json body
func NewPromoteSyncSourceTestConnectionRequest(server string, syncSourceTestConnectionID SyncSourceTestConnectionID, body PromoteSyncSourceTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromoteSyncSourceTestConnectionRequestWithBody(server, syncSourceTestConnectionID, "application/json", bodyReader)
}

// NewPromoteSyncSourceTestConnectionRequestWithBody generates requests for PromoteSyncSourceTestConnection with any type of body
func NewPromoteSyncSourceTestConnectionRequestWithBody(server string, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_test_connection_id", runtime.ParamLocationPath, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-source-test-connections/%s/promote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncSourcesRequest generates requests for ListSyncSources
func NewListSyncSourcesRequest(server string, params *ListSyncSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncGenericSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncGenericSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSyncSourceRequest generates requests for DeleteSyncSource
func NewDeleteSyncSourceRequest(server string, syncSourceName SyncSourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncSourceRequest generates requests for GetSyncSource
func NewGetSyncSourceRequest(server string, syncSourceName SyncSourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncSourceRequest calls the generic UpdateSyncSource builder with application/json body
func NewUpdateSyncSourceRequest(server string, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncSourceRequestWithBody(server, syncSourceName, "application/json", bodyReader)
}

// NewUpdateSyncSourceRequestWithBody generates requests for UpdateSyncSource with any type of body
func NewUpdateSyncSourceRequestWithBody(server string, syncSourceName SyncSourceName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncSourceSyncsRequest generates requests for ListSyncSourceSyncs
func NewListSyncSourceSyncsRequest(server string, syncSourceName SyncSourceName, params *ListSyncSourceSyncsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-sources/%s/syncs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MigrationFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "migration_filter", runtime.ParamLocationQuery, *params.MigrationFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestConnectionForSyncSourceRequest generates requests for GetTestConnectionForSyncSource
func NewGetTestConnectionForSyncSourceRequest(server string, syncSourceName SyncSourceName, syncTestConnectionId SyncTestConnectionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_test_connection_id", runtime.ParamLocationPath, syncTestConnectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-sources/%s/test-connections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSyncTransformersRequest generates requests for ListSyncTransformers
func NewListSyncTransformersRequest(server string, params *ListSyncTransformersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-transformers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncGenericSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncGenericSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSyncTransformerRequest generates requests for DeleteSyncTransformer
func NewDeleteSyncTransformerRequest(server string, syncTransformerName SyncTransformerName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_transformer_name", runtime.ParamLocationPath, syncTransformerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-transformers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncTransformerRequest generates requests for GetSyncTransformer
func NewGetSyncTransformerRequest(server string, syncTransformerName SyncTransformerName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_transformer_name", runtime.ParamLocationPath, syncTransformerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-transformers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncTransformerRequest calls the generic UpdateSyncTransformer builder with application/json body
func NewUpdateSyncTransformerRequest(server string, syncTransformerName SyncTransformerName, body UpdateSyncTransformerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncTransformerRequestWithBody(server, syncTransformerName, "application/json", bodyReader)
}

// NewUpdateSyncTransformerRequestWithBody generates requests for UpdateSyncTransformer with any type of body
func NewUpdateSyncTransformerRequestWithBody(server string, syncTransformerName SyncTransformerName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_transformer_name", runtime.ParamLocationPath, syncTransformerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-transformers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncTransformerSyncDestinationsRequest generates requests for ListSyncTransformerSyncDestinations
func NewListSyncTransformerSyncDestinationsRequest(server string, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncDestinationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_transformer_name", runtime.ParamLocationPath, syncTransformerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-transformers/%s/sync-destinations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSyncTransformerSyncsRequest generates requests for ListSyncTransformerSyncs
func NewListSyncTransformerSyncsRequest(server string, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_transformer_name", runtime.ParamLocationPath, syncTransformerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-transformers/%s/syncs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSyncUpgradesRequest generates requests for ListSyncUpgrades
func NewListSyncUpgradesRequest(server string, params *ListSyncUpgradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync-upgrades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncUpgradesSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncUpgradesSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform_version", runtime.ParamLocationQuery, *params.PlatformVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSyncsRequest generates requests for ListSyncs
func NewListSyncsRequest(server string, params *ListSyncsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MigrationFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "migration_filter", runtime.ParamLocationQuery, *params.MigrationFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncRequest calls the generic CreateSync builder with application/json body
func NewCreateSyncRequest(server string, body CreateSyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSyncRequestWithBody generates requests for CreateSync with any type of body
func NewCreateSyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSyncRequest generates requests for DeleteSync
func NewDeleteSyncRequest(server string, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncRequest generates requests for GetSync
func NewGetSyncRequest(server string, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncRequest calls the generic UpdateSync builder with application/json body
func NewUpdateSyncRequest(server string, syncName SyncName, body UpdateSyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncRequestWithBody(server, syncName, "application/json", bodyReader)
}

// NewUpdateSyncRequestWithBody generates requests for UpdateSync with any type of body
func NewUpdateSyncRequestWithBody(server string, syncName SyncName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncRunsRequest generates requests for ListSyncRuns
func NewListSyncRunsRequest(server string, syncName SyncName, params *ListSyncRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MigrationFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "migration_filter", runtime.ParamLocationQuery, *params.MigrationFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncRunRequest generates requests for CreateSyncRun
func NewCreateSyncRunRequest(server string, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncRunRequest generates requests for GetSyncRun
func NewGetSyncRunRequest(server string, syncName SyncName, syncRunId SyncRunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncRunRequest calls the generic UpdateSyncRun builder with application/json body
func NewUpdateSyncRunRequest(server string, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncRunRequestWithBody(server, syncName, syncRunId, "application/json", bodyReader)
}

// NewUpdateSyncRunRequestWithBody generates requests for UpdateSyncRun with any type of body
func NewUpdateSyncRunRequestWithBody(server string, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncRunLogsLiveRequest generates requests for GetSyncRunLogsLive
func NewGetSyncRunLogsLiveRequest(server string, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsLiveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s/logs/live", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Table != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table", runtime.ParamLocationQuery, *params.Table); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetSyncRunLogsQueryRequest generates requests for GetSyncRunLogsQuery
func NewGetSyncRunLogsQueryRequest(server string, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s/logs/query", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSyncRunProgressRequest calls the generic CreateSyncRunProgress builder with application/json body
func NewCreateSyncRunProgressRequest(server string, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncRunProgressRequestWithBody(server, syncName, syncRunId, "application/json", bodyReader)
}

// NewCreateSyncRunProgressRequestWithBody generates requests for CreateSyncRunProgress with any type of body
func NewCreateSyncRunProgressRequestWithBody(server string, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s/progress", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncRunStatsRequest generates requests for GetSyncRunStats
func NewGetSyncRunStatsRequest(server string, syncName SyncName, syncRunId SyncRunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s/stats", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncRunTablesRequest generates requests for GetSyncRunTables
func NewGetSyncRunTablesRequest(server string, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syncs/%s/runs/%s/tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncRunTableSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncRunTableSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, params *ListTablesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTablesDataRequest generates requests for GetTablesData
func NewGetTablesDataRequest(server string, params *GetTablesDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTablesDataActionRequest calls the generic TablesDataAction builder with application/json body
func NewTablesDataActionRequest(server string, body TablesDataActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTablesDataActionRequestWithBody(server, "application/json", bodyReader)
}

// NewTablesDataActionRequestWithBody generates requests for TablesDataAction with any type of body
func NewTablesDataActionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBatchTableSchemasRequest generates requests for BatchTableSchemas
func NewBatchTableSchemasRequest(server string, params *BatchTableSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tables", runtime.ParamLocationQuery, params.Tables); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableListColumnsRequest generates requests for TableListColumns
func NewTableListColumnsRequest(server string, tableName TableName, params *TableListColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableColumnListValuesRequest generates requests for TableColumnListValues
func NewTableColumnListValuesRequest(server string, tableName TableName, columnName ColumnName, params *TableColumnListValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "column_name", runtime.ParamLocationPath, columnName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/columns/%s/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableListRowsRequest generates requests for TableListRows
func NewTableListRowsRequest(server string, tableName TableName, params *TableListRowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Selects != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, params.Selects); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterIDs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, params.FilterIDs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_by", runtime.ParamLocationQuery, params.GroupBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableRowByIdRequest generates requests for TableRowById
func NewTableRowByIdRequest(server string, tableName TableName, tableRowId TableRowId, params *TableRowByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table_row_id", runtime.ParamLocationPath, tableRowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/data/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterIDs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, params.FilterIDs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableListFiltersRequest generates requests for TableListFilters
func NewTableListFiltersRequest(server string, tableName TableName, params *TableListFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.FilterTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableSaveFilterRequest calls the generic TableSaveFilter builder with application/json body
func NewTableSaveFilterRequest(server string, tableName TableName, body TableSaveFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTableSaveFilterRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewTableSaveFilterRequestWithBody generates requests for TableSaveFilter with any type of body
func NewTableSaveFilterRequestWithBody(server string, tableName TableName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTableListFilterTagsRequest generates requests for TableListFilterTags
func NewTableListFilterTagsRequest(server string, tableName TableName, params *TableListFilterTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/filters/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTableSchemaRequest generates requests for TableSchema
func NewTableSchemaRequest(server string, tableName TableName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/schema", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string, params *ListTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadPluginAssetByTeamRequest generates requests for DownloadPluginAssetByTeam
func NewDownloadPluginAssetByTeamRequest(server string, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_team", runtime.ParamLocationPath, pluginTeam)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/plugins/%s/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSyncTestConnectionForSyncDestinationTeamRequest calls the generic UpdateSyncTestConnectionForSyncDestinationTeam builder with application/json body
func NewUpdateSyncTestConnectionForSyncDestinationTeamRequest(server string, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncTestConnectionForSyncDestinationTeamRequestWithBody(server, teamName, syncDestinationTestConnectionID, "application/json", bodyReader)
}

// NewUpdateSyncTestConnectionForSyncDestinationTeamRequestWithBody generates requests for UpdateSyncTestConnectionForSyncDestinationTeam with any type of body
func NewUpdateSyncTestConnectionForSyncDestinationTeamRequestWithBody(server string, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_test_connection_id", runtime.ParamLocationPath, syncDestinationTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destination-test-connections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSyncTestConnectionForSyncSourceTeamRequest calls the generic UpdateSyncTestConnectionForSyncSourceTeam builder with application/json body
func NewUpdateSyncTestConnectionForSyncSourceTeamRequest(server string, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncTestConnectionForSyncSourceTeamRequestWithBody(server, teamName, syncSourceTestConnectionID, "application/json", bodyReader)
}

// NewUpdateSyncTestConnectionForSyncSourceTeamRequestWithBody generates requests for UpdateSyncTestConnectionForSyncSourceTeam with any type of body
func NewUpdateSyncTestConnectionForSyncSourceTeamRequestWithBody(server string, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_source_test_connection_id", runtime.ParamLocationPath, syncSourceTestConnectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-source-test-connections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSyncRunProgressTeamRequest calls the generic CreateSyncRunProgressTeam builder with application/json body
func NewCreateSyncRunProgressTeamRequest(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncRunProgressTeamRequestWithBody(server, teamName, syncName, syncRunId, "application/json", bodyReader)
}

// NewCreateSyncRunProgressTeamRequestWithBody generates requests for CreateSyncRunProgressTeam with any type of body
func NewCreateSyncRunProgressTeamRequestWithBody(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs/%s/progress", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamUsageSummaryRequest generates requests for GetTeamUsageSummary
func NewGetTeamUsageSummaryRequest(server string, params *GetTeamUsageSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage-summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AggregationPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aggregation_period", runtime.ParamLocationQuery, *params.AggregationPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupedTeamUsageSummaryRequest generates requests for GetGroupedTeamUsageSummary
func NewGetGroupedTeamUsageSummaryRequest(server string, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_by", runtime.ParamLocationPath, groupBy)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage-summary/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AggregationPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aggregation_period", runtime.ParamLocationQuery, *params.AggregationPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCurrentUserRequest calls the generic UpdateCurrentUser builder with application/json body
func NewUpdateCurrentUserRequest(server string, body UpdateCurrentUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCurrentUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCurrentUserRequestWithBody generates requests for UpdateCurrentUser with any type of body
func NewUpdateCurrentUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendAnonymousEventRequest calls the generic SendAnonymousEvent builder with application/json body
func NewSendAnonymousEventRequest(server string, body SendAnonymousEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendAnonymousEventRequestWithBody(server, "application/json", bodyReader)
}

// NewSendAnonymousEventRequestWithBody generates requests for SendAnonymousEvent with any type of body
func NewSendAnonymousEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/anon-event")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticateUserRequest calls the generic AuthenticateUser builder with application/json body
func NewAuthenticateUserRequest(server string, body AuthenticateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateUserRequestWithBody generates requests for AuthenticateUser with any type of body
func NewAuthenticateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/authenticate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangeUserPasswordRequest calls the generic ChangeUserPassword builder with application/json body
func NewChangeUserPasswordRequest(server string, body ChangeUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeUserPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewChangeUserPasswordRequestWithBody generates requests for ChangeUserPassword with any type of body
func NewChangeUserPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/change-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCustomerRequest calls the generic UpdateCustomer builder with application/json body
func NewUpdateCustomerRequest(server string, body UpdateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCustomerRequestWithBody generates requests for UpdateCustomer with any type of body
func NewUpdateCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/customer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendUserEventRequest calls the generic SendUserEvent builder with application/json body
func NewSendUserEventRequest(server string, body SendUserEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendUserEventRequestWithBody(server, "application/json", bodyReader)
}

// NewSendUserEventRequestWithBody generates requests for SendUserEvent with any type of body
func NewSendUserEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/event")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutUserRequest generates requests for LogoutUser
func NewLogoutUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginUserRequest calls the generic LoginUser builder with application/json body
func NewLoginUserRequest(server string, body LoginUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginUserRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginUserRequestWithBody generates requests for LoginUser with any type of body
func NewLoginUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserTOTPDeleteRequest generates requests for UserTOTPDelete
func NewUserTOTPDeleteRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/totp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserTOTPSetupRequest generates requests for UserTOTPSetup
func NewUserTOTPSetupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/totp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserTOTPVerifyRequest calls the generic UserTOTPVerify builder with application/json body
func NewUserTOTPVerifyRequest(server string, params *UserTOTPVerifyParams, body UserTOTPVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserTOTPVerifyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUserTOTPVerifyRequestWithBody generates requests for UserTOTPVerify with any type of body
func NewUserTOTPVerifyRequestWithBody(server string, params *UserTOTPVerifyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/totp/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.CqpSess != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "__cqp_sess", runtime.ParamLocationCookie, *params.CqpSess)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "__cqp_sess",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_search", runtime.ParamLocationQuery, *params.UserSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role_id", runtime.ParamLocationQuery, *params.RoleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserRequest calls the generic AddUser builder with application/json body
func NewAddUserRequest(server string, body AddUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUserRequestWithBody generates requests for AddUser with any type of body
func NewAddUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userID UserID, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserTOTPRequest generates requests for DeleteUserTOTP
func NewDeleteUserTOTPRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/totp", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateV2SyncDestinationTestConnectionRequest calls the generic CreateV2SyncDestinationTestConnection builder with application/json body
func NewCreateV2SyncDestinationTestConnectionRequest(server string, body CreateV2SyncDestinationTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateV2SyncDestinationTestConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateV2SyncDestinationTestConnectionRequestWithBody generates requests for CreateV2SyncDestinationTestConnection with any type of body
func NewCreateV2SyncDestinationTestConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-destination-test-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2SyncDestinationsRequest generates requests for GetV2SyncDestinations
func NewGetV2SyncDestinationsRequest(server string, params *GetV2SyncDestinationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-destinations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncGenericSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncGenericSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateV2SyncDestinationRequest calls the generic CreateV2SyncDestination builder with application/json body
func NewCreateV2SyncDestinationRequest(server string, body CreateV2SyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateV2SyncDestinationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateV2SyncDestinationRequestWithBody generates requests for CreateV2SyncDestination with any type of body
func NewCreateV2SyncDestinationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-destinations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteV2SyncDestinationRequest generates requests for DeleteV2SyncDestination
func NewDeleteV2SyncDestinationRequest(server string, syncDestinationName SyncDestinationName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-destinations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2SyncDestinationRequest generates requests for GetV2SyncDestination
func NewGetV2SyncDestinationRequest(server string, syncDestinationName SyncDestinationName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-destinations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchV2SyncDestinationRequest calls the generic PatchV2SyncDestination builder with application/json body
func NewPatchV2SyncDestinationRequest(server string, syncDestinationName SyncDestinationName, body PatchV2SyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2SyncDestinationRequestWithBody(server, syncDestinationName, "application/json", bodyReader)
}

// NewPatchV2SyncDestinationRequestWithBody generates requests for PatchV2SyncDestination with any type of body
func NewPatchV2SyncDestinationRequestWithBody(server string, syncDestinationName SyncDestinationName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-destinations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateV2SyncIntegrationTestConnectionRequest calls the generic CreateV2SyncIntegrationTestConnection builder with application/json body
func NewCreateV2SyncIntegrationTestConnectionRequest(server string, body CreateV2SyncIntegrationTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateV2SyncIntegrationTestConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateV2SyncIntegrationTestConnectionRequestWithBody generates requests for CreateV2SyncIntegrationTestConnection with any type of body
func NewCreateV2SyncIntegrationTestConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-integration-test-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListV2SyncIntegrationsRequest generates requests for ListV2SyncIntegrations
func NewListV2SyncIntegrationsRequest(server string, params *ListV2SyncIntegrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortBys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SyncSortBys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncSortDirections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, params.SyncSortDirections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateV2SyncIntegrationRequest calls the generic CreateV2SyncIntegration builder with application/json body
func NewCreateV2SyncIntegrationRequest(server string, body CreateV2SyncIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateV2SyncIntegrationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateV2SyncIntegrationRequestWithBody generates requests for CreateV2SyncIntegration with any type of body
func NewCreateV2SyncIntegrationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteV2SyncIntegrationRequest generates requests for DeleteV2SyncIntegration
func NewDeleteV2SyncIntegrationRequest(server string, syncName SyncName, params *DeleteV2SyncIntegrationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_data", runtime.ParamLocationQuery, *params.DeleteData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2SyncIntegrationRequest generates requests for GetV2SyncIntegration
func NewGetV2SyncIntegrationRequest(server string, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateV2SyncIntegrationRequest calls the generic UpdateV2SyncIntegration builder with application/json body
func NewUpdateV2SyncIntegrationRequest(server string, syncName SyncName, body UpdateV2SyncIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateV2SyncIntegrationRequestWithBody(server, syncName, "application/json", bodyReader)
}

// NewUpdateV2SyncIntegrationRequestWithBody generates requests for UpdateV2SyncIntegration with any type of body
func NewUpdateV2SyncIntegrationRequestWithBody(server string, syncName SyncName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sync-integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// IndexWithResponse request
	IndexWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IndexResponse, error)

	// ListAllAlertsWithResponse request
	ListAllAlertsWithResponse(ctx context.Context, params *ListAllAlertsParams, reqEditors ...RequestEditorFn) (*ListAllAlertsResponse, error)

	// TestUnsavedAlertWithBodyWithResponse request with any body
	TestUnsavedAlertWithBodyWithResponse(ctx context.Context, params *TestUnsavedAlertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUnsavedAlertResponse, error)

	TestUnsavedAlertWithResponse(ctx context.Context, params *TestUnsavedAlertParams, body TestUnsavedAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUnsavedAlertResponse, error)

	// ListAPIKeysWithResponse request
	ListAPIKeysWithResponse(ctx context.Context, params *ListAPIKeysParams, reqEditors ...RequestEditorFn) (*ListAPIKeysResponse, error)

	// CreateAPIKeyWithBodyWithResponse request with any body
	CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error)

	CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error)

	// DeleteAPIKeyWithResponse request
	DeleteAPIKeyWithResponse(ctx context.Context, apiKeyID APIKeyID, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResponse, error)

	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetAuditLogWithResponse request
	GetAuditLogWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error)

	// GetSAMLWithResponse request
	GetSAMLWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSAMLResponse, error)

	// UpdateSAMLWithBodyWithResponse request with any body
	UpdateSAMLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAMLResponse, error)

	UpdateSAMLWithResponse(ctx context.Context, body UpdateSAMLJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAMLResponse, error)

	// CreateConversationWithBodyWithResponse request with any body
	CreateConversationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConversationResponse, error)

	CreateConversationWithResponse(ctx context.Context, body CreateConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConversationResponse, error)

	// GetConversationWithResponse request
	GetConversationWithResponse(ctx context.Context, conversationID ConversationID, reqEditors ...RequestEditorFn) (*GetConversationResponse, error)

	// SendMessageWithBodyWithResponse request with any body
	SendMessageWithBodyWithResponse(ctx context.Context, conversationID ConversationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageResponse, error)

	SendMessageWithResponse(ctx context.Context, conversationID ConversationID, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageResponse, error)

	// ListAllCustomColumnsWithResponse request
	ListAllCustomColumnsWithResponse(ctx context.Context, params *ListAllCustomColumnsParams, reqEditors ...RequestEditorFn) (*ListAllCustomColumnsResponse, error)

	// SaveCustomColumnWithBodyWithResponse request with any body
	SaveCustomColumnWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveCustomColumnResponse, error)

	SaveCustomColumnWithResponse(ctx context.Context, body SaveCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveCustomColumnResponse, error)

	// DeleteCustomColumnWithResponse request
	DeleteCustomColumnWithResponse(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*DeleteCustomColumnResponse, error)

	// GetCustomColumnWithResponse request
	GetCustomColumnWithResponse(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*GetCustomColumnResponse, error)

	// UpdateCustomColumnWithBodyWithResponse request with any body
	UpdateCustomColumnWithBodyWithResponse(ctx context.Context, customColumnID CustomColumnID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomColumnResponse, error)

	UpdateCustomColumnWithResponse(ctx context.Context, customColumnID CustomColumnID, body UpdateCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomColumnResponse, error)

	// ListFiltersWithResponse request
	ListFiltersWithResponse(ctx context.Context, params *ListFiltersParams, reqEditors ...RequestEditorFn) (*ListFiltersResponse, error)

	// ListFilterTagsWithResponse request
	ListFilterTagsWithResponse(ctx context.Context, params *ListFilterTagsParams, reqEditors ...RequestEditorFn) (*ListFilterTagsResponse, error)

	// DeleteFilterWithResponse request
	DeleteFilterWithResponse(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*DeleteFilterResponse, error)

	// GetFilterByIDWithResponse request
	GetFilterByIDWithResponse(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*GetFilterByIDResponse, error)

	// UpdateFilterWithBodyWithResponse request with any body
	UpdateFilterWithBodyWithResponse(ctx context.Context, filterID FilterID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error)

	UpdateFilterWithResponse(ctx context.Context, filterID FilterID, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// HealthCheckHeadWithResponse request
	HealthCheckHeadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckHeadResponse, error)

	// ListNotificationsWithResponse request
	ListNotificationsWithResponse(ctx context.Context, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*ListNotificationsResponse, error)

	// DeleteNotificationDestinationWithResponse request
	DeleteNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*DeleteNotificationDestinationResponse, error)

	// GetNotificationDestinationWithResponse request
	GetNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*GetNotificationDestinationResponse, error)

	// UpdateNotificationDestinationWithBodyWithResponse request with any body
	UpdateNotificationDestinationWithBodyWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationDestinationResponse, error)

	UpdateNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, body UpdateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationDestinationResponse, error)

	// GetNotificationDestinationAlertsWithResponse request
	GetNotificationDestinationAlertsWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, params *GetNotificationDestinationAlertsParams, reqEditors ...RequestEditorFn) (*GetNotificationDestinationAlertsResponse, error)

	// TestNotificationDestinationWithResponse request
	TestNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*TestNotificationDestinationResponse, error)

	// ListAllNotificationDestinationsWithResponse request
	ListAllNotificationDestinationsWithResponse(ctx context.Context, params *ListAllNotificationDestinationsParams, reqEditors ...RequestEditorFn) (*ListAllNotificationDestinationsResponse, error)

	// CreateNotificationDestinationWithBodyWithResponse request with any body
	CreateNotificationDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationDestinationResponse, error)

	CreateNotificationDestinationWithResponse(ctx context.Context, body CreateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationDestinationResponse, error)

	// TestUnsavedNotificationDestinationWithBodyWithResponse request with any body
	TestUnsavedNotificationDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUnsavedNotificationDestinationResponse, error)

	TestUnsavedNotificationDestinationWithResponse(ctx context.Context, body TestUnsavedNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUnsavedNotificationDestinationResponse, error)

	// CreateAWSOnboardingWithBodyWithResponse request with any body
	CreateAWSOnboardingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSOnboardingResponse, error)

	CreateAWSOnboardingWithResponse(ctx context.Context, body CreateAWSOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSOnboardingResponse, error)

	// GetAWSOnboardingWithResponse request
	GetAWSOnboardingWithResponse(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*GetAWSOnboardingResponse, error)

	// GetAWSAccountsInRootWithResponse request
	GetAWSAccountsInRootWithResponse(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*GetAWSAccountsInRootResponse, error)

	// ProvisionOnboardingConfigurationWithBodyWithResponse request with any body
	ProvisionOnboardingConfigurationWithBodyWithResponse(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProvisionOnboardingConfigurationResponse, error)

	ProvisionOnboardingConfigurationWithResponse(ctx context.Context, onboardingID OnboardingID, body ProvisionOnboardingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*ProvisionOnboardingConfigurationResponse, error)

	// GetAWSAccountsInParentWithResponse request
	GetAWSAccountsInParentWithResponse(ctx context.Context, onboardingID OnboardingID, organizationalUnitID OrganizationalUnitID, reqEditors ...RequestEditorFn) (*GetAWSAccountsInParentResponse, error)

	// NotifyOnboardingWithBodyWithResponse request with any body
	NotifyOnboardingWithBodyWithResponse(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotifyOnboardingResponse, error)

	NotifyOnboardingWithResponse(ctx context.Context, onboardingID OnboardingID, body NotifyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*NotifyOnboardingResponse, error)

	// GetOpenAPIJSONWithResponse request
	GetOpenAPIJSONWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenAPIJSONResponse, error)

	// GetPlatformInfoWithResponse request
	GetPlatformInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlatformInfoResponse, error)

	// ListPlatformVersionsWithResponse request
	ListPlatformVersionsWithResponse(ctx context.Context, params *ListPlatformVersionsParams, reqEditors ...RequestEditorFn) (*ListPlatformVersionsResponse, error)

	// ListPluginsWithResponse request
	ListPluginsWithResponse(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*ListPluginsResponse, error)

	// GetPluginWithResponse request
	GetPluginWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginResponse, error)

	// ListPluginVersionsWithResponse request
	ListPluginVersionsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionsResponse, error)

	// GetPluginVersionWithResponse request
	GetPluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetPluginVersionResponse, error)

	// DownloadPluginAssetWithResponse request
	DownloadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetResponse, error)

	// ListPluginVersionTablesWithResponse request
	ListPluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*ListPluginVersionTablesResponse, error)

	// GetPluginVersionTableWithResponse request
	GetPluginVersionTableWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*GetPluginVersionTableResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// GetPolicyMetricsWithResponse request
	GetPolicyMetricsWithResponse(ctx context.Context, params *GetPolicyMetricsParams, reqEditors ...RequestEditorFn) (*GetPolicyMetricsResponse, error)

	// GetViolationsByDomainWithResponse request
	GetViolationsByDomainWithResponse(ctx context.Context, params *GetViolationsByDomainParams, reqEditors ...RequestEditorFn) (*GetViolationsByDomainResponse, error)

	// GetViolationsHistoryWithResponse request
	GetViolationsHistoryWithResponse(ctx context.Context, params *GetViolationsHistoryParams, reqEditors ...RequestEditorFn) (*GetViolationsHistoryResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyWithResponse request
	GetPolicyWithResponse(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyID PolicyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyID PolicyID, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// TogglePolicyWithResponse request
	TogglePolicyWithResponse(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*TogglePolicyResponse, error)

	// GetPolicyViolationsWithResponse request
	GetPolicyViolationsWithResponse(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsParams, reqEditors ...RequestEditorFn) (*GetPolicyViolationsResponse, error)

	// GetPolicyViolationsHistoryWithResponse request
	GetPolicyViolationsHistoryWithResponse(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsHistoryParams, reqEditors ...RequestEditorFn) (*GetPolicyViolationsHistoryResponse, error)

	// ListPolicyGroupsWithResponse request
	ListPolicyGroupsWithResponse(ctx context.Context, params *ListPolicyGroupsParams, reqEditors ...RequestEditorFn) (*ListPolicyGroupsResponse, error)

	// CreatePolicyGroupWithBodyWithResponse request with any body
	CreatePolicyGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyGroupResponse, error)

	CreatePolicyGroupWithResponse(ctx context.Context, body CreatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyGroupResponse, error)

	// DeletePolicyGroupWithResponse request
	DeletePolicyGroupWithResponse(ctx context.Context, policyGroupID PolicyGroupID, reqEditors ...RequestEditorFn) (*DeletePolicyGroupResponse, error)

	// ListPoliciesInGroupWithResponse request
	ListPoliciesInGroupWithResponse(ctx context.Context, policyGroupID PolicyGroupID, params *ListPoliciesInGroupParams, reqEditors ...RequestEditorFn) (*ListPoliciesInGroupResponse, error)

	// UpdatePolicyGroupWithBodyWithResponse request with any body
	UpdatePolicyGroupWithBodyWithResponse(ctx context.Context, policyGroupID PolicyGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyGroupResponse, error)

	UpdatePolicyGroupWithResponse(ctx context.Context, policyGroupID PolicyGroupID, body UpdatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyGroupResponse, error)

	// ListAllQueriesWithResponse request
	ListAllQueriesWithResponse(ctx context.Context, params *ListAllQueriesParams, reqEditors ...RequestEditorFn) (*ListAllQueriesResponse, error)

	// ExecuteAdHocQueryWithBodyWithResponse request with any body
	ExecuteAdHocQueryWithBodyWithResponse(ctx context.Context, params *ExecuteAdHocQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteAdHocQueryResponse, error)

	ExecuteAdHocQueryWithResponse(ctx context.Context, params *ExecuteAdHocQueryParams, body ExecuteAdHocQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteAdHocQueryResponse, error)

	// SaveQueryWithBodyWithResponse request with any body
	SaveQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveQueryResponse, error)

	SaveQueryWithResponse(ctx context.Context, body SaveQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveQueryResponse, error)

	// ListQueryTagsWithResponse request
	ListQueryTagsWithResponse(ctx context.Context, params *ListQueryTagsParams, reqEditors ...RequestEditorFn) (*ListQueryTagsResponse, error)

	// DeleteSavedQueryWithResponse request
	DeleteSavedQueryWithResponse(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error)

	// GetSavedQueryWithResponse request
	GetSavedQueryWithResponse(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*GetSavedQueryResponse, error)

	// UpdateQueryWithBodyWithResponse request with any body
	UpdateQueryWithBodyWithResponse(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateQueryResponse, error)

	UpdateQueryWithResponse(ctx context.Context, queryID QueryID, body UpdateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateQueryResponse, error)

	// DeleteAlertWithResponse request
	DeleteAlertWithResponse(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*DeleteAlertResponse, error)

	// ExecuteSavedQueryWithResponse request
	ExecuteSavedQueryWithResponse(ctx context.Context, queryID QueryID, params *ExecuteSavedQueryParams, reqEditors ...RequestEditorFn) (*ExecuteSavedQueryResponse, error)

	// QueryListFiltersWithResponse request
	QueryListFiltersWithResponse(ctx context.Context, queryID QueryID, params *QueryListFiltersParams, reqEditors ...RequestEditorFn) (*QueryListFiltersResponse, error)

	// QuerySaveFilterWithBodyWithResponse request with any body
	QuerySaveFilterWithBodyWithResponse(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QuerySaveFilterResponse, error)

	QuerySaveFilterWithResponse(ctx context.Context, queryID QueryID, body QuerySaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*QuerySaveFilterResponse, error)

	// QueryListFilterTagsWithResponse request
	QueryListFilterTagsWithResponse(ctx context.Context, queryID QueryID, params *QueryListFilterTagsParams, reqEditors ...RequestEditorFn) (*QueryListFilterTagsResponse, error)

	// ListAllRBACPermissionsWithResponse request
	ListAllRBACPermissionsWithResponse(ctx context.Context, params *ListAllRBACPermissionsParams, reqEditors ...RequestEditorFn) (*ListAllRBACPermissionsResponse, error)

	// CreateRBACPermissionWithBodyWithResponse request with any body
	CreateRBACPermissionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRBACPermissionResponse, error)

	CreateRBACPermissionWithResponse(ctx context.Context, body CreateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRBACPermissionResponse, error)

	// DeleteRBACPermissionWithResponse request
	DeleteRBACPermissionWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*DeleteRBACPermissionResponse, error)

	// GetRBACPermissionWithResponse request
	GetRBACPermissionWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*GetRBACPermissionResponse, error)

	// UpdateRBACPermissionWithBodyWithResponse request with any body
	UpdateRBACPermissionWithBodyWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRBACPermissionResponse, error)

	UpdateRBACPermissionWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, body UpdateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRBACPermissionResponse, error)

	// ListAllRBACRolesWithResponse request
	ListAllRBACRolesWithResponse(ctx context.Context, params *ListAllRBACRolesParams, reqEditors ...RequestEditorFn) (*ListAllRBACRolesResponse, error)

	// CreateRBACRoleWithBodyWithResponse request with any body
	CreateRBACRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRBACRoleResponse, error)

	CreateRBACRoleWithResponse(ctx context.Context, body CreateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRBACRoleResponse, error)

	// DeleteRBACRoleWithResponse request
	DeleteRBACRoleWithResponse(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*DeleteRBACRoleResponse, error)

	// GetRBACRoleWithResponse request
	GetRBACRoleWithResponse(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*GetRBACRoleResponse, error)

	// UpdateRBACRoleWithBodyWithResponse request with any body
	UpdateRBACRoleWithBodyWithResponse(ctx context.Context, roleID RoleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRBACRoleResponse, error)

	UpdateRBACRoleWithResponse(ctx context.Context, roleID RoleID, body UpdateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRBACRoleResponse, error)

	// ListReportsWithResponse request
	ListReportsWithResponse(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResponse, error)

	// CreateReportWithBodyWithResponse request with any body
	CreateReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportResponse, error)

	CreateReportWithResponse(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportResponse, error)

	// ListReportTemplatesWithResponse request
	ListReportTemplatesWithResponse(ctx context.Context, params *ListReportTemplatesParams, reqEditors ...RequestEditorFn) (*ListReportTemplatesResponse, error)

	// CreateReportTemplateWithBodyWithResponse request with any body
	CreateReportTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportTemplateResponse, error)

	CreateReportTemplateWithResponse(ctx context.Context, body CreateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportTemplateResponse, error)

	// DeleteReportTemplateWithResponse request
	DeleteReportTemplateWithResponse(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteReportTemplateResponse, error)

	// GetReportTemplateWithResponse request
	GetReportTemplateWithResponse(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetReportTemplateResponse, error)

	// UpdateReportTemplateWithBodyWithResponse request with any body
	UpdateReportTemplateWithBodyWithResponse(ctx context.Context, templateId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReportTemplateResponse, error)

	UpdateReportTemplateWithResponse(ctx context.Context, templateId openapi_types.UUID, body UpdateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReportTemplateResponse, error)

	// DeleteReportWithResponse request
	DeleteReportWithResponse(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteReportResponse, error)

	// GetReportWithResponse request
	GetReportWithResponse(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetReportResponse, error)

	// UpdateReportWithBodyWithResponse request with any body
	UpdateReportWithBodyWithResponse(ctx context.Context, reportId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReportResponse, error)

	UpdateReportWithResponse(ctx context.Context, reportId openapi_types.UUID, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReportResponse, error)

	// GetSettingsWithResponse request
	GetSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error)

	// UpdateSettingsWithBodyWithResponse request with any body
	UpdateSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error)

	UpdateSettingsWithResponse(ctx context.Context, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error)

	// GetDataSettingsWithResponse request
	GetDataSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataSettingsResponse, error)

	// UpdateDataSettingsWithBodyWithResponse request with any body
	UpdateDataSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataSettingsResponse, error)

	UpdateDataSettingsWithResponse(ctx context.Context, body UpdateDataSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataSettingsResponse, error)

	// CreateSlackConnectionWithBodyWithResponse request with any body
	CreateSlackConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSlackConnectionResponse, error)

	CreateSlackConnectionWithResponse(ctx context.Context, body CreateSlackConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSlackConnectionResponse, error)

	// ListSlackChannelsWithResponse request
	ListSlackChannelsWithResponse(ctx context.Context, id openapi_types.UUID, params *ListSlackChannelsParams, reqEditors ...RequestEditorFn) (*ListSlackChannelsResponse, error)

	// CreateSyncDestinationTestConnectionWithBodyWithResponse request with any body
	CreateSyncDestinationTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncDestinationTestConnectionResponse, error)

	CreateSyncDestinationTestConnectionWithResponse(ctx context.Context, body CreateSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncDestinationTestConnectionResponse, error)

	// GetSyncDestinationTestConnectionWithResponse request
	GetSyncDestinationTestConnectionWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, reqEditors ...RequestEditorFn) (*GetSyncDestinationTestConnectionResponse, error)

	// UpdateSyncTestConnectionForSyncDestinationWithBodyWithResponse request with any body
	UpdateSyncTestConnectionForSyncDestinationWithBodyWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationResponse, error)

	UpdateSyncTestConnectionForSyncDestinationWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationResponse, error)

	// GetSyncDestinationTestConnectionLogsLiveWithResponse request
	GetSyncDestinationTestConnectionLogsLiveWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*GetSyncDestinationTestConnectionLogsLiveResponse, error)

	// GetSyncDestinationTestConnectionLogsQueryWithResponse request
	GetSyncDestinationTestConnectionLogsQueryWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*GetSyncDestinationTestConnectionLogsQueryResponse, error)

	// PromoteSyncDestinationTestConnectionWithBodyWithResponse request with any body
	PromoteSyncDestinationTestConnectionWithBodyWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromoteSyncDestinationTestConnectionResponse, error)

	PromoteSyncDestinationTestConnectionWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body PromoteSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PromoteSyncDestinationTestConnectionResponse, error)

	// ListSyncDestinationsWithResponse request
	ListSyncDestinationsWithResponse(ctx context.Context, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*ListSyncDestinationsResponse, error)

	// DeleteSyncDestinationWithResponse request
	DeleteSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*DeleteSyncDestinationResponse, error)

	// GetSyncDestinationWithResponse request
	GetSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*GetSyncDestinationResponse, error)

	// UpdateSyncDestinationWithBodyWithResponse request with any body
	UpdateSyncDestinationWithBodyWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error)

	UpdateSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error)

	// ListSyncDestinationSyncsWithResponse request
	ListSyncDestinationSyncsWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, params *ListSyncDestinationSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncDestinationSyncsResponse, error)

	// GetTestConnectionForSyncDestinationWithResponse request
	GetTestConnectionForSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*GetTestConnectionForSyncDestinationResponse, error)

	// CreateSyncSourceTestConnectionWithBodyWithResponse request with any body
	CreateSyncSourceTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncSourceTestConnectionResponse, error)

	CreateSyncSourceTestConnectionWithResponse(ctx context.Context, body CreateSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncSourceTestConnectionResponse, error)

	// GetSyncSourceTestConnectionWithResponse request
	GetSyncSourceTestConnectionWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, reqEditors ...RequestEditorFn) (*GetSyncSourceTestConnectionResponse, error)

	// UpdateSyncTestConnectionForSyncSourceWithBodyWithResponse request with any body
	UpdateSyncTestConnectionForSyncSourceWithBodyWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceResponse, error)

	UpdateSyncTestConnectionForSyncSourceWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceResponse, error)

	// GetSyncSourceTestConnectionLogsLiveWithResponse request
	GetSyncSourceTestConnectionLogsLiveWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*GetSyncSourceTestConnectionLogsLiveResponse, error)

	// GetSyncSourceTestConnectionLogsQueryWithResponse request
	GetSyncSourceTestConnectionLogsQueryWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*GetSyncSourceTestConnectionLogsQueryResponse, error)

	// PromoteSyncSourceTestConnectionWithBodyWithResponse request with any body
	PromoteSyncSourceTestConnectionWithBodyWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromoteSyncSourceTestConnectionResponse, error)

	PromoteSyncSourceTestConnectionWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body PromoteSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PromoteSyncSourceTestConnectionResponse, error)

	// ListSyncSourcesWithResponse request
	ListSyncSourcesWithResponse(ctx context.Context, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*ListSyncSourcesResponse, error)

	// DeleteSyncSourceWithResponse request
	DeleteSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*DeleteSyncSourceResponse, error)

	// GetSyncSourceWithResponse request
	GetSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*GetSyncSourceResponse, error)

	// UpdateSyncSourceWithBodyWithResponse request with any body
	UpdateSyncSourceWithBodyWithResponse(ctx context.Context, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error)

	UpdateSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error)

	// ListSyncSourceSyncsWithResponse request
	ListSyncSourceSyncsWithResponse(ctx context.Context, syncSourceName SyncSourceName, params *ListSyncSourceSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncSourceSyncsResponse, error)

	// GetTestConnectionForSyncSourceWithResponse request
	GetTestConnectionForSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*GetTestConnectionForSyncSourceResponse, error)

	// ListSyncTransformersWithResponse request
	ListSyncTransformersWithResponse(ctx context.Context, params *ListSyncTransformersParams, reqEditors ...RequestEditorFn) (*ListSyncTransformersResponse, error)

	// DeleteSyncTransformerWithResponse request
	DeleteSyncTransformerWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*DeleteSyncTransformerResponse, error)

	// GetSyncTransformerWithResponse request
	GetSyncTransformerWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*GetSyncTransformerResponse, error)

	// UpdateSyncTransformerWithBodyWithResponse request with any body
	UpdateSyncTransformerWithBodyWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTransformerResponse, error)

	UpdateSyncTransformerWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, body UpdateSyncTransformerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTransformerResponse, error)

	// ListSyncTransformerSyncDestinationsWithResponse request
	ListSyncTransformerSyncDestinationsWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncDestinationsParams, reqEditors ...RequestEditorFn) (*ListSyncTransformerSyncDestinationsResponse, error)

	// ListSyncTransformerSyncsWithResponse request
	ListSyncTransformerSyncsWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncTransformerSyncsResponse, error)

	// ListSyncUpgradesWithResponse request
	ListSyncUpgradesWithResponse(ctx context.Context, params *ListSyncUpgradesParams, reqEditors ...RequestEditorFn) (*ListSyncUpgradesResponse, error)

	// ListSyncsWithResponse request
	ListSyncsWithResponse(ctx context.Context, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncsResponse, error)

	// CreateSyncWithBodyWithResponse request with any body
	CreateSyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error)

	CreateSyncWithResponse(ctx context.Context, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error)

	// DeleteSyncWithResponse request
	DeleteSyncWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*DeleteSyncResponse, error)

	// GetSyncWithResponse request
	GetSyncWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*GetSyncResponse, error)

	// UpdateSyncWithBodyWithResponse request with any body
	UpdateSyncWithBodyWithResponse(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error)

	UpdateSyncWithResponse(ctx context.Context, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error)

	// ListSyncRunsWithResponse request
	ListSyncRunsWithResponse(ctx context.Context, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*ListSyncRunsResponse, error)

	// CreateSyncRunWithResponse request
	CreateSyncRunWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*CreateSyncRunResponse, error)

	// GetSyncRunWithResponse request
	GetSyncRunWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*GetSyncRunResponse, error)

	// UpdateSyncRunWithBodyWithResponse request with any body
	UpdateSyncRunWithBodyWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error)

	UpdateSyncRunWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error)

	// GetSyncRunLogsLiveWithResponse request
	GetSyncRunLogsLiveWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsLiveParams, reqEditors ...RequestEditorFn) (*GetSyncRunLogsLiveResponse, error)

	// GetSyncRunLogsQueryWithResponse request
	GetSyncRunLogsQueryWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsQueryParams, reqEditors ...RequestEditorFn) (*GetSyncRunLogsQueryResponse, error)

	// CreateSyncRunProgressWithBodyWithResponse request with any body
	CreateSyncRunProgressWithBodyWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error)

	CreateSyncRunProgressWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error)

	// GetSyncRunStatsWithResponse request
	GetSyncRunStatsWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*GetSyncRunStatsResponse, error)

	// GetSyncRunTablesWithResponse request
	GetSyncRunTablesWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunTablesParams, reqEditors ...RequestEditorFn) (*GetSyncRunTablesResponse, error)

	// ListTablesWithResponse request
	ListTablesWithResponse(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error)

	// GetTablesDataWithResponse request
	GetTablesDataWithResponse(ctx context.Context, params *GetTablesDataParams, reqEditors ...RequestEditorFn) (*GetTablesDataResponse, error)

	// TablesDataActionWithBodyWithResponse request with any body
	TablesDataActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TablesDataActionResponse, error)

	TablesDataActionWithResponse(ctx context.Context, body TablesDataActionJSONRequestBody, reqEditors ...RequestEditorFn) (*TablesDataActionResponse, error)

	// BatchTableSchemasWithResponse request
	BatchTableSchemasWithResponse(ctx context.Context, params *BatchTableSchemasParams, reqEditors ...RequestEditorFn) (*BatchTableSchemasResponse, error)

	// TableListColumnsWithResponse request
	TableListColumnsWithResponse(ctx context.Context, tableName TableName, params *TableListColumnsParams, reqEditors ...RequestEditorFn) (*TableListColumnsResponse, error)

	// TableColumnListValuesWithResponse request
	TableColumnListValuesWithResponse(ctx context.Context, tableName TableName, columnName ColumnName, params *TableColumnListValuesParams, reqEditors ...RequestEditorFn) (*TableColumnListValuesResponse, error)

	// TableListRowsWithResponse request
	TableListRowsWithResponse(ctx context.Context, tableName TableName, params *TableListRowsParams, reqEditors ...RequestEditorFn) (*TableListRowsResponse, error)

	// TableRowByIdWithResponse request
	TableRowByIdWithResponse(ctx context.Context, tableName TableName, tableRowId TableRowId, params *TableRowByIdParams, reqEditors ...RequestEditorFn) (*TableRowByIdResponse, error)

	// TableListFiltersWithResponse request
	TableListFiltersWithResponse(ctx context.Context, tableName TableName, params *TableListFiltersParams, reqEditors ...RequestEditorFn) (*TableListFiltersResponse, error)

	// TableSaveFilterWithBodyWithResponse request with any body
	TableSaveFilterWithBodyWithResponse(ctx context.Context, tableName TableName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TableSaveFilterResponse, error)

	TableSaveFilterWithResponse(ctx context.Context, tableName TableName, body TableSaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*TableSaveFilterResponse, error)

	// TableListFilterTagsWithResponse request
	TableListFilterTagsWithResponse(ctx context.Context, tableName TableName, params *TableListFilterTagsParams, reqEditors ...RequestEditorFn) (*TableListFilterTagsResponse, error)

	// TableSchemaWithResponse request
	TableSchemaWithResponse(ctx context.Context, tableName TableName, reqEditors ...RequestEditorFn) (*TableSchemaResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// DownloadPluginAssetByTeamWithResponse request
	DownloadPluginAssetByTeamWithResponse(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetByTeamResponse, error)

	// UpdateSyncTestConnectionForSyncDestinationTeamWithBodyWithResponse request with any body
	UpdateSyncTestConnectionForSyncDestinationTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationTeamResponse, error)

	UpdateSyncTestConnectionForSyncDestinationTeamWithResponse(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationTeamResponse, error)

	// UpdateSyncTestConnectionForSyncSourceTeamWithBodyWithResponse request with any body
	UpdateSyncTestConnectionForSyncSourceTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceTeamResponse, error)

	UpdateSyncTestConnectionForSyncSourceTeamWithResponse(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceTeamResponse, error)

	// CreateSyncRunProgressTeamWithBodyWithResponse request with any body
	CreateSyncRunProgressTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressTeamResponse, error)

	CreateSyncRunProgressTeamWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressTeamResponse, error)

	// GetTeamUsageSummaryWithResponse request
	GetTeamUsageSummaryWithResponse(ctx context.Context, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetTeamUsageSummaryResponse, error)

	// GetGroupedTeamUsageSummaryWithResponse request
	GetGroupedTeamUsageSummaryWithResponse(ctx context.Context, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetGroupedTeamUsageSummaryResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// UpdateCurrentUserWithBodyWithResponse request with any body
	UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	// SendAnonymousEventWithBodyWithResponse request with any body
	SendAnonymousEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendAnonymousEventResponse, error)

	SendAnonymousEventWithResponse(ctx context.Context, body SendAnonymousEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SendAnonymousEventResponse, error)

	// AuthenticateUserWithBodyWithResponse request with any body
	AuthenticateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateUserResponse, error)

	AuthenticateUserWithResponse(ctx context.Context, body AuthenticateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateUserResponse, error)

	// ChangeUserPasswordWithBodyWithResponse request with any body
	ChangeUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeUserPasswordResponse, error)

	ChangeUserPasswordWithResponse(ctx context.Context, body ChangeUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeUserPasswordResponse, error)

	// UpdateCustomerWithBodyWithResponse request with any body
	UpdateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	UpdateCustomerWithResponse(ctx context.Context, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	// SendUserEventWithBodyWithResponse request with any body
	SendUserEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserEventResponse, error)

	SendUserEventWithResponse(ctx context.Context, body SendUserEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserEventResponse, error)

	// LogoutUserWithResponse request
	LogoutUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutUserResponse, error)

	// LoginUserWithBodyWithResponse request with any body
	LoginUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginUserResponse, error)

	LoginUserWithResponse(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginUserResponse, error)

	// UserTOTPDeleteWithResponse request
	UserTOTPDeleteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserTOTPDeleteResponse, error)

	// UserTOTPSetupWithResponse request
	UserTOTPSetupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserTOTPSetupResponse, error)

	// UserTOTPVerifyWithBodyWithResponse request with any body
	UserTOTPVerifyWithBodyWithResponse(ctx context.Context, params *UserTOTPVerifyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserTOTPVerifyResponse, error)

	UserTOTPVerifyWithResponse(ctx context.Context, params *UserTOTPVerifyParams, body UserTOTPVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*UserTOTPVerifyResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// AddUserWithBodyWithResponse request with any body
	AddUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	AddUserWithResponse(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// DeleteUserTOTPWithResponse request
	DeleteUserTOTPWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserTOTPResponse, error)

	// CreateV2SyncDestinationTestConnectionWithBodyWithResponse request with any body
	CreateV2SyncDestinationTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationTestConnectionResponse, error)

	CreateV2SyncDestinationTestConnectionWithResponse(ctx context.Context, body CreateV2SyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationTestConnectionResponse, error)

	// GetV2SyncDestinationsWithResponse request
	GetV2SyncDestinationsWithResponse(ctx context.Context, params *GetV2SyncDestinationsParams, reqEditors ...RequestEditorFn) (*GetV2SyncDestinationsResponse, error)

	// CreateV2SyncDestinationWithBodyWithResponse request with any body
	CreateV2SyncDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationResponse, error)

	CreateV2SyncDestinationWithResponse(ctx context.Context, body CreateV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationResponse, error)

	// DeleteV2SyncDestinationWithResponse request
	DeleteV2SyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*DeleteV2SyncDestinationResponse, error)

	// GetV2SyncDestinationWithResponse request
	GetV2SyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*GetV2SyncDestinationResponse, error)

	// PatchV2SyncDestinationWithBodyWithResponse request with any body
	PatchV2SyncDestinationWithBodyWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2SyncDestinationResponse, error)

	PatchV2SyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, body PatchV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2SyncDestinationResponse, error)

	// CreateV2SyncIntegrationTestConnectionWithBodyWithResponse request with any body
	CreateV2SyncIntegrationTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationTestConnectionResponse, error)

	CreateV2SyncIntegrationTestConnectionWithResponse(ctx context.Context, body CreateV2SyncIntegrationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationTestConnectionResponse, error)

	// ListV2SyncIntegrationsWithResponse request
	ListV2SyncIntegrationsWithResponse(ctx context.Context, params *ListV2SyncIntegrationsParams, reqEditors ...RequestEditorFn) (*ListV2SyncIntegrationsResponse, error)

	// CreateV2SyncIntegrationWithBodyWithResponse request with any body
	CreateV2SyncIntegrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationResponse, error)

	CreateV2SyncIntegrationWithResponse(ctx context.Context, body CreateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationResponse, error)

	// DeleteV2SyncIntegrationWithResponse request
	DeleteV2SyncIntegrationWithResponse(ctx context.Context, syncName SyncName, params *DeleteV2SyncIntegrationParams, reqEditors ...RequestEditorFn) (*DeleteV2SyncIntegrationResponse, error)

	// GetV2SyncIntegrationWithResponse request
	GetV2SyncIntegrationWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*GetV2SyncIntegrationResponse, error)

	// UpdateV2SyncIntegrationWithBodyWithResponse request with any body
	UpdateV2SyncIntegrationWithBodyWithResponse(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateV2SyncIntegrationResponse, error)

	UpdateV2SyncIntegrationWithResponse(ctx context.Context, syncName SyncName, body UpdateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateV2SyncIntegrationResponse, error)
}

type IndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors      *[]string          `json:"errors,omitempty"`
		FieldErrors *map[string]string `json:"field_errors,omitempty"`
		Message     string             `json:"message"`
		Status      int                `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r IndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []AlertDetail `json:"items"`
		Metadata ListMetadata  `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAllAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestUnsavedAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Results Notification results for the test alert
		Results []AlertTestResponse `json:"results"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TestUnsavedAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestUnsavedAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAPIKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AllowedRoles List of allowed roles when creating a new API key
		AllowedRoles []Role       `json:"allowed_roles"`
		Items        []APIKey     `json:"items"`
		Metadata     ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAPIKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAPIKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *APIKey
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []AuditLogEvent `json:"items"`
		Metadata ListMetadata    `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditLogEvent
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSAMLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLConfig
	JSON400      *BadRequest
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSAMLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSAMLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSAMLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLConfig
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSAMLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSAMLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Conversation
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Conversation
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationMessage
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SendMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllCustomColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []CustomColumn `json:"items"`
		Metadata ListMetadata   `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAllCustomColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllCustomColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveCustomColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomColumn
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SaveCustomColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveCustomColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteCustomColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomColumn
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetCustomColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomColumn
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateCustomColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Filter     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFilterTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []FilterTag  `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListFilterTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFilterTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetFilterByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckHeadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r HealthCheckHeadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckHeadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []NotificationDetail `json:"items"`
		Metadata ListMetadata         `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationDestination
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetNotificationDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationDestinationAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []AlertDetail `json:"items"`
		Metadata ListMetadata  `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetNotificationDestinationAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationDestinationAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestNotificationDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationDestinationTestResponse
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TestNotificationDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestNotificationDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllNotificationDestinationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []NotificationDestinationListItem `json:"items"`
		Metadata ListMetadata                      `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAllNotificationDestinationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllNotificationDestinationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NotificationDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateNotificationDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestUnsavedNotificationDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationDestinationTestResponse
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TestUnsavedNotificationDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestUnsavedNotificationDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAWSOnboardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OnboardingAWSCreateResponse
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateAWSOnboardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAWSOnboardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSOnboardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnboardingAWS
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAWSOnboardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSOnboardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSAccountsInRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnboardingAWSAccounts
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAWSAccountsInRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSAccountsInRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisionOnboardingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProvisionOnboardingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisionOnboardingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSAccountsInParentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnboardingAWSAccounts
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAWSAccountsInParentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSAccountsInParentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifyOnboardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r NotifyOnboardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifyOnboardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenAPIJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r GetOpenAPIJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenAPIJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// PublicIPs List of public IPs for the platform
		PublicIPs *[]string `json:"public_ips,omitempty"`

		// Version Version of the platform
		Version string `json:"version"`
	}
	JSON401 *RequiresAuthentication
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPlatformInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlatformVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PlatformVersion `json:"items"`
		Metadata ListMetadata      `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPlatformVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlatformVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    ListPlugins  `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPlugin
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PluginVersionList `json:"items"`
		Metadata ListMetadata        `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersionDetails
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPluginAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginAsset
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadPluginAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPluginAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PluginTable `json:"items"`
		Metadata ListMetadata  `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginVersionTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginTableDetails
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginVersionTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginVersionTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Policy     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMetrics
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPolicyMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetViolationsByDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ViolationsByDomain
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetViolationsByDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetViolationsByDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetViolationsHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ViolationsHistory
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetViolationsHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetViolationsHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TogglePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TogglePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TogglePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyViolationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PolicyViolation `json:"items"`
		Metadata *ListMetadata     `json:"metadata,omitempty"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPolicyViolationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyViolationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyViolationsHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PolicyEvaluationLog `json:"items"`
		Metadata ListMetadata          `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPolicyViolationsHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyViolationsHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPolicyGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []PolicyGroupWithCounts `json:"items"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPolicyGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPolicyGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PolicyGroup
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePolicyGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePolicyGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesInGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Policy     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPoliciesInGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesInGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyGroup
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllQueriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Query      `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAllQueriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllQueriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteAdHocQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     TableData    `json:"data"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ExecuteAdHocQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteAdHocQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *QueryDetail
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SaveQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQueryTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []QueryTag   `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListQueryTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueryTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryDetail
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryDetail
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     TableData    `json:"data"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ExecuteSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryListFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Filter     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r QueryListFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryListFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QuerySaveFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON201      *Filter
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r QuerySaveFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuerySaveFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryListFilterTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []FilterTag  `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r QueryListFilterTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryListFilterTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllRBACPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []RBACPermission `json:"items"`
		Metadata ListMetadata     `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAllRBACPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllRBACPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRBACPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RBACPermission
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateRBACPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRBACPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRBACPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteRBACPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRBACPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRBACPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RBACPermission
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetRBACPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRBACPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRBACPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RBACPermission
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateRBACPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRBACPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllRBACRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Role       `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAllRBACRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllRBACRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRBACRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Role
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateRBACRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRBACRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRBACRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteRBACRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRBACRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRBACRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetRBACRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRBACRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRBACRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateRBACRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRBACRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata ListMetadata `json:"metadata"`
		Reports  []Report     `json:"reports"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ListReportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data Report `json:"data"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata  ListMetadata     `json:"metadata"`
		Templates []ReportTemplate `json:"templates"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ListReportTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReportTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data ReportTemplate `json:"data"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateReportTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReportTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReportTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteReportTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReportTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data ReportTemplate `json:"data"`
	}
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetReportTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReportTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data ReportTemplate `json:"data"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateReportTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReportTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Report `json:"data"`
	}
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Report `json:"data"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformSettings
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformSettings
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformDataSettings
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetDataSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformDataSettings
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateDataSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSlackConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SlackConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSlackConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSlackConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSlackChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []SlackChannel `json:"items"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSlackChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSlackChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncDestinationTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncDestinationTestConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncDestinationTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncDestinationTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncDestinationTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestinationTestConnection
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncDestinationTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncDestinationTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncTestConnectionForSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestinationTestConnection
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncTestConnectionForSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncTestConnectionForSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncDestinationTestConnectionLogsLiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncDestinationTestConnectionLogsLiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncDestinationTestConnectionLogsLiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncDestinationTestConnectionLogsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     TableData    `json:"data"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncDestinationTestConnectionLogsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncDestinationTestConnectionLogsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromoteSyncDestinationTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestination
	JSON201      *SyncDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PromoteSyncDestinationTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromoteSyncDestinationTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncDestinationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncDestination `json:"items"`
		Metadata ListMetadata      `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncDestinationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncDestinationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestination
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncDestinationSyncsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []ListSync   `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncDestinationSyncsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncDestinationSyncsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestConnectionForSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTestConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTestConnectionForSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestConnectionForSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncSourceTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncSourceTestConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncSourceTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncSourceTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncSourceTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSourceTestConnection
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncSourceTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncSourceTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncTestConnectionForSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSourceTestConnection
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncTestConnectionForSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncTestConnectionForSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncSourceTestConnectionLogsLiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncSourceTestConnectionLogsLiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncSourceTestConnectionLogsLiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncSourceTestConnectionLogsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     TableData    `json:"data"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncSourceTestConnectionLogsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncSourceTestConnectionLogsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromoteSyncSourceTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSource
	JSON201      *SyncSource
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PromoteSyncSourceTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromoteSyncSourceTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncSource `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSource
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSource
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncSourceSyncsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []ListSync   `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncSourceSyncsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncSourceSyncsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestConnectionForSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTestConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTestConnectionForSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestConnectionForSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncTransformersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncTransformer `json:"items"`
		Metadata ListMetadata      `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncTransformersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncTransformersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncTransformerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncTransformerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncTransformerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncTransformerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTransformer
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncTransformerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncTransformerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncTransformerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTransformer
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncTransformerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncTransformerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncTransformerSyncDestinationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncDestination `json:"items"`
		Metadata ListMetadata      `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncTransformerSyncDestinationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncTransformerSyncDestinationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncTransformerSyncsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Sync       `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncTransformerSyncsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncTransformerSyncsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncUpgradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncUpgrade `json:"items"`
		Metadata ListMetadata  `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncUpgradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncUpgradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []ListSync   `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sync
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sync
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sync
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncRun    `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncRun
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncRunDetails
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncRun
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunLogsLiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunLogsLiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunLogsLiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunLogsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     TableData    `json:"data"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunLogsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunLogsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncRunProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncRunProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncRunProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncRunStats
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncRunTableStat `json:"items"`
		Metadata ListMetadata       `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []TableListItem `json:"items"`
		Metadata ListMetadata    `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata ListMetadata        `json:"metadata"`
		Syncs    []TableDataListItem `json:"syncs"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTablesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TablesDataActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TablesDataActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TablesDataActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BatchTableSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []BatchTableSchemaItem `json:"items"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r BatchTableSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BatchTableSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableListColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []TableColumnListItem `json:"items"`
		Metadata ListMetadata          `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableListColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableListColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableColumnListValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []TableColumnValueListItem `json:"items"`
		Metadata ListMetadata               `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableColumnListValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableColumnListValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableListRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     TableData    `json:"data"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableListRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableListRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableRowByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data    TableRow             `json:"data"`
		Matches []TableRowFieldMatch `json:"matches"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableRowByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableRowByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableListFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Filter     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableListFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableListFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableSaveFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON201      *Filter
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TableSaveFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableSaveFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableListFilterTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []FilterTag  `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableListFilterTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableListFilterTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DefaultColumns []string    `json:"default_columns"`
		Schema         TableSchema `json:"schema"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r TableSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Team       `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPluginAssetByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginAsset
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadPluginAssetByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPluginAssetByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncTestConnectionForSyncDestinationTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestinationTestConnection
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncTestConnectionForSyncDestinationTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncTestConnectionForSyncDestinationTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncTestConnectionForSyncSourceTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSourceTestConnection
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncTestConnectionForSyncSourceTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncTestConnectionForSyncSourceTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncRunProgressTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncRunProgressTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncRunProgressTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamUsageSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageSummary
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamUsageSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamUsageSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupedTeamUsageSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageSummary
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetGroupedTeamUsageSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupedTeamUsageSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedAt *time.Time `json:"created_at,omitempty"`
		Email     string     `json:"email"`

		// Enabled Whether the user is enabled
		Enabled          bool                    `json:"enabled"`
		EventIdentifiers *map[string]interface{} `json:"event_identifiers,omitempty"`
		GroupIdentifier  *string                 `json:"group_identifier,omitempty"`

		// ID ID of the User
		ID          openapi_types.UUID `json:"id"`
		LastLoginAt *time.Time         `json:"last_login_at,omitempty"`

		// MFAConfigured Whether the user has MFA configured
		MFAConfigured bool `json:"mfa_configured"`

		// Name The unique name for the user.
		Name *UserName `json:"name,omitempty"`

		// ProfileImageURL Profile image URL of user
		ProfileImageURL *string      `json:"profile_image_url,omitempty"`
		Provider        UserProvider `json:"provider"`

		// RegisteredTeamInternal Whether the team is internal or not
		RegisteredTeamInternal *bool `json:"registered_team_internal,omitempty"`

		// RegisteredTeamName The name of the team that the platform is registered with
		RegisteredTeamName *string `json:"registered_team_name,omitempty"`
		Roles              []Role  `json:"roles"`

		// TrackingOptedIn Whether anonymous user tracking was opted into
		TrackingOptedIn *bool      `json:"tracking_opted_in,omitempty"`
		UpdatedAt       *time.Time `json:"updated_at,omitempty"`
	}
	JSON401 *struct {
		Message string `json:"message"`

		// PasswordResetRequired Whether the user needs to reset their password
		PasswordResetRequired *bool `json:"password_reset_required,omitempty"`
		Status                int   `json:"status"`
	}
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendAnonymousEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SendAnonymousEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendAnonymousEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IDToken string `json:"id_token"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON422 *UnprocessableEntity
	JSON429 *TooManyRequests
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r AuthenticateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ChangeUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendUserEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SendUserEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendUserEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r LogoutUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r LoginUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserTOTPDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UserTOTPDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserTOTPDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserTOTPSetupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secret string `json:"secret"`
		Url    string `json:"url"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON405 *MethodNotAllowed
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r UserTOTPSetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserTOTPSetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserTOTPVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UserTOTPVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserTOTPVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []User       `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r AddUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserTOTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteUserTOTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserTOTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateV2SyncDestinationTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncDestinationTestConnectionV2
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateV2SyncDestinationTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateV2SyncDestinationTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SyncDestinationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncDestinationV2 `json:"items"`
		Metadata ListMetadata        `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetV2SyncDestinationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SyncDestinationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateV2SyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestinationV2
	JSON201      *SyncDestinationV2
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateV2SyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateV2SyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2SyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteV2SyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2SyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestinationV2
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetV2SyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2SyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PatchV2SyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2SyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateV2SyncIntegrationTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncIntegrationTestConnectionV2
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateV2SyncIntegrationTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateV2SyncIntegrationTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListV2SyncIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []SyncIntegrationExpandedV2 `json:"items"`
		Metadata ListMetadata                `json:"metadata"`
	}
	JSON400 *BadRequest
	JSON401 *RequiresAuthentication
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListV2SyncIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListV2SyncIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateV2SyncIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncIntegrationV2
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateV2SyncIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateV2SyncIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2SyncIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteV2SyncIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2SyncIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SyncIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncIntegrationExpandedV2
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetV2SyncIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SyncIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateV2SyncIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncIntegrationV2
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateV2SyncIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateV2SyncIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// IndexWithResponse request returning *IndexResponse
func (c *ClientWithResponses) IndexWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IndexResponse, error) {
	rsp, err := c.Index(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIndexResponse(rsp)
}

// ListAllAlertsWithResponse request returning *ListAllAlertsResponse
func (c *ClientWithResponses) ListAllAlertsWithResponse(ctx context.Context, params *ListAllAlertsParams, reqEditors ...RequestEditorFn) (*ListAllAlertsResponse, error) {
	rsp, err := c.ListAllAlerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllAlertsResponse(rsp)
}

// TestUnsavedAlertWithBodyWithResponse request with arbitrary body returning *TestUnsavedAlertResponse
func (c *ClientWithResponses) TestUnsavedAlertWithBodyWithResponse(ctx context.Context, params *TestUnsavedAlertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUnsavedAlertResponse, error) {
	rsp, err := c.TestUnsavedAlertWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUnsavedAlertResponse(rsp)
}

func (c *ClientWithResponses) TestUnsavedAlertWithResponse(ctx context.Context, params *TestUnsavedAlertParams, body TestUnsavedAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUnsavedAlertResponse, error) {
	rsp, err := c.TestUnsavedAlert(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUnsavedAlertResponse(rsp)
}

// ListAPIKeysWithResponse request returning *ListAPIKeysResponse
func (c *ClientWithResponses) ListAPIKeysWithResponse(ctx context.Context, params *ListAPIKeysParams, reqEditors ...RequestEditorFn) (*ListAPIKeysResponse, error) {
	rsp, err := c.ListAPIKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAPIKeysResponse(rsp)
}

// CreateAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateAPIKeyResponse
func (c *ClientWithResponses) CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error) {
	rsp, err := c.CreateAPIKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error) {
	rsp, err := c.CreateAPIKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResponse(rsp)
}

// DeleteAPIKeyWithResponse request returning *DeleteAPIKeyResponse
func (c *ClientWithResponses) DeleteAPIKeyWithResponse(ctx context.Context, apiKeyID APIKeyID, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResponse, error) {
	rsp, err := c.DeleteAPIKey(ctx, apiKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAPIKeyResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetAuditLogWithResponse request returning *GetAuditLogResponse
func (c *ClientWithResponses) GetAuditLogWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error) {
	rsp, err := c.GetAuditLog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogResponse(rsp)
}

// GetSAMLWithResponse request returning *GetSAMLResponse
func (c *ClientWithResponses) GetSAMLWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSAMLResponse, error) {
	rsp, err := c.GetSAML(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSAMLResponse(rsp)
}

// UpdateSAMLWithBodyWithResponse request with arbitrary body returning *UpdateSAMLResponse
func (c *ClientWithResponses) UpdateSAMLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAMLResponse, error) {
	rsp, err := c.UpdateSAMLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSAMLResponse(rsp)
}

func (c *ClientWithResponses) UpdateSAMLWithResponse(ctx context.Context, body UpdateSAMLJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAMLResponse, error) {
	rsp, err := c.UpdateSAML(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSAMLResponse(rsp)
}

// CreateConversationWithBodyWithResponse request with arbitrary body returning *CreateConversationResponse
func (c *ClientWithResponses) CreateConversationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConversationResponse, error) {
	rsp, err := c.CreateConversationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConversationResponse(rsp)
}

func (c *ClientWithResponses) CreateConversationWithResponse(ctx context.Context, body CreateConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConversationResponse, error) {
	rsp, err := c.CreateConversation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConversationResponse(rsp)
}

// GetConversationWithResponse request returning *GetConversationResponse
func (c *ClientWithResponses) GetConversationWithResponse(ctx context.Context, conversationID ConversationID, reqEditors ...RequestEditorFn) (*GetConversationResponse, error) {
	rsp, err := c.GetConversation(ctx, conversationID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConversationResponse(rsp)
}

// SendMessageWithBodyWithResponse request with arbitrary body returning *SendMessageResponse
func (c *ClientWithResponses) SendMessageWithBodyWithResponse(ctx context.Context, conversationID ConversationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageResponse, error) {
	rsp, err := c.SendMessageWithBody(ctx, conversationID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageResponse(rsp)
}

func (c *ClientWithResponses) SendMessageWithResponse(ctx context.Context, conversationID ConversationID, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageResponse, error) {
	rsp, err := c.SendMessage(ctx, conversationID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageResponse(rsp)
}

// ListAllCustomColumnsWithResponse request returning *ListAllCustomColumnsResponse
func (c *ClientWithResponses) ListAllCustomColumnsWithResponse(ctx context.Context, params *ListAllCustomColumnsParams, reqEditors ...RequestEditorFn) (*ListAllCustomColumnsResponse, error) {
	rsp, err := c.ListAllCustomColumns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllCustomColumnsResponse(rsp)
}

// SaveCustomColumnWithBodyWithResponse request with arbitrary body returning *SaveCustomColumnResponse
func (c *ClientWithResponses) SaveCustomColumnWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveCustomColumnResponse, error) {
	rsp, err := c.SaveCustomColumnWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveCustomColumnResponse(rsp)
}

func (c *ClientWithResponses) SaveCustomColumnWithResponse(ctx context.Context, body SaveCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveCustomColumnResponse, error) {
	rsp, err := c.SaveCustomColumn(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveCustomColumnResponse(rsp)
}

// DeleteCustomColumnWithResponse request returning *DeleteCustomColumnResponse
func (c *ClientWithResponses) DeleteCustomColumnWithResponse(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*DeleteCustomColumnResponse, error) {
	rsp, err := c.DeleteCustomColumn(ctx, customColumnID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomColumnResponse(rsp)
}

// GetCustomColumnWithResponse request returning *GetCustomColumnResponse
func (c *ClientWithResponses) GetCustomColumnWithResponse(ctx context.Context, customColumnID CustomColumnID, reqEditors ...RequestEditorFn) (*GetCustomColumnResponse, error) {
	rsp, err := c.GetCustomColumn(ctx, customColumnID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomColumnResponse(rsp)
}

// UpdateCustomColumnWithBodyWithResponse request with arbitrary body returning *UpdateCustomColumnResponse
func (c *ClientWithResponses) UpdateCustomColumnWithBodyWithResponse(ctx context.Context, customColumnID CustomColumnID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomColumnResponse, error) {
	rsp, err := c.UpdateCustomColumnWithBody(ctx, customColumnID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomColumnResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomColumnWithResponse(ctx context.Context, customColumnID CustomColumnID, body UpdateCustomColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomColumnResponse, error) {
	rsp, err := c.UpdateCustomColumn(ctx, customColumnID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomColumnResponse(rsp)
}

// ListFiltersWithResponse request returning *ListFiltersResponse
func (c *ClientWithResponses) ListFiltersWithResponse(ctx context.Context, params *ListFiltersParams, reqEditors ...RequestEditorFn) (*ListFiltersResponse, error) {
	rsp, err := c.ListFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFiltersResponse(rsp)
}

// ListFilterTagsWithResponse request returning *ListFilterTagsResponse
func (c *ClientWithResponses) ListFilterTagsWithResponse(ctx context.Context, params *ListFilterTagsParams, reqEditors ...RequestEditorFn) (*ListFilterTagsResponse, error) {
	rsp, err := c.ListFilterTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFilterTagsResponse(rsp)
}

// DeleteFilterWithResponse request returning *DeleteFilterResponse
func (c *ClientWithResponses) DeleteFilterWithResponse(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*DeleteFilterResponse, error) {
	rsp, err := c.DeleteFilter(ctx, filterID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterResponse(rsp)
}

// GetFilterByIDWithResponse request returning *GetFilterByIDResponse
func (c *ClientWithResponses) GetFilterByIDWithResponse(ctx context.Context, filterID FilterID, reqEditors ...RequestEditorFn) (*GetFilterByIDResponse, error) {
	rsp, err := c.GetFilterByID(ctx, filterID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterByIDResponse(rsp)
}

// UpdateFilterWithBodyWithResponse request with arbitrary body returning *UpdateFilterResponse
func (c *ClientWithResponses) UpdateFilterWithBodyWithResponse(ctx context.Context, filterID FilterID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error) {
	rsp, err := c.UpdateFilterWithBody(ctx, filterID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFilterResponse(rsp)
}

func (c *ClientWithResponses) UpdateFilterWithResponse(ctx context.Context, filterID FilterID, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error) {
	rsp, err := c.UpdateFilter(ctx, filterID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFilterResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// HealthCheckHeadWithResponse request returning *HealthCheckHeadResponse
func (c *ClientWithResponses) HealthCheckHeadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckHeadResponse, error) {
	rsp, err := c.HealthCheckHead(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckHeadResponse(rsp)
}

// ListNotificationsWithResponse request returning *ListNotificationsResponse
func (c *ClientWithResponses) ListNotificationsWithResponse(ctx context.Context, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*ListNotificationsResponse, error) {
	rsp, err := c.ListNotifications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationsResponse(rsp)
}

// DeleteNotificationDestinationWithResponse request returning *DeleteNotificationDestinationResponse
func (c *ClientWithResponses) DeleteNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*DeleteNotificationDestinationResponse, error) {
	rsp, err := c.DeleteNotificationDestination(ctx, notificationDestinationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationDestinationResponse(rsp)
}

// GetNotificationDestinationWithResponse request returning *GetNotificationDestinationResponse
func (c *ClientWithResponses) GetNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*GetNotificationDestinationResponse, error) {
	rsp, err := c.GetNotificationDestination(ctx, notificationDestinationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationDestinationResponse(rsp)
}

// UpdateNotificationDestinationWithBodyWithResponse request with arbitrary body returning *UpdateNotificationDestinationResponse
func (c *ClientWithResponses) UpdateNotificationDestinationWithBodyWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationDestinationResponse, error) {
	rsp, err := c.UpdateNotificationDestinationWithBody(ctx, notificationDestinationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationDestinationResponse(rsp)
}

func (c *ClientWithResponses) UpdateNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, body UpdateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationDestinationResponse, error) {
	rsp, err := c.UpdateNotificationDestination(ctx, notificationDestinationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationDestinationResponse(rsp)
}

// GetNotificationDestinationAlertsWithResponse request returning *GetNotificationDestinationAlertsResponse
func (c *ClientWithResponses) GetNotificationDestinationAlertsWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, params *GetNotificationDestinationAlertsParams, reqEditors ...RequestEditorFn) (*GetNotificationDestinationAlertsResponse, error) {
	rsp, err := c.GetNotificationDestinationAlerts(ctx, notificationDestinationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationDestinationAlertsResponse(rsp)
}

// TestNotificationDestinationWithResponse request returning *TestNotificationDestinationResponse
func (c *ClientWithResponses) TestNotificationDestinationWithResponse(ctx context.Context, notificationDestinationId NotificationDestinationId, reqEditors ...RequestEditorFn) (*TestNotificationDestinationResponse, error) {
	rsp, err := c.TestNotificationDestination(ctx, notificationDestinationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestNotificationDestinationResponse(rsp)
}

// ListAllNotificationDestinationsWithResponse request returning *ListAllNotificationDestinationsResponse
func (c *ClientWithResponses) ListAllNotificationDestinationsWithResponse(ctx context.Context, params *ListAllNotificationDestinationsParams, reqEditors ...RequestEditorFn) (*ListAllNotificationDestinationsResponse, error) {
	rsp, err := c.ListAllNotificationDestinations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllNotificationDestinationsResponse(rsp)
}

// CreateNotificationDestinationWithBodyWithResponse request with arbitrary body returning *CreateNotificationDestinationResponse
func (c *ClientWithResponses) CreateNotificationDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationDestinationResponse, error) {
	rsp, err := c.CreateNotificationDestinationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationDestinationResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationDestinationWithResponse(ctx context.Context, body CreateNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationDestinationResponse, error) {
	rsp, err := c.CreateNotificationDestination(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationDestinationResponse(rsp)
}

// TestUnsavedNotificationDestinationWithBodyWithResponse request with arbitrary body returning *TestUnsavedNotificationDestinationResponse
func (c *ClientWithResponses) TestUnsavedNotificationDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUnsavedNotificationDestinationResponse, error) {
	rsp, err := c.TestUnsavedNotificationDestinationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUnsavedNotificationDestinationResponse(rsp)
}

func (c *ClientWithResponses) TestUnsavedNotificationDestinationWithResponse(ctx context.Context, body TestUnsavedNotificationDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUnsavedNotificationDestinationResponse, error) {
	rsp, err := c.TestUnsavedNotificationDestination(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUnsavedNotificationDestinationResponse(rsp)
}

// CreateAWSOnboardingWithBodyWithResponse request with arbitrary body returning *CreateAWSOnboardingResponse
func (c *ClientWithResponses) CreateAWSOnboardingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSOnboardingResponse, error) {
	rsp, err := c.CreateAWSOnboardingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSOnboardingResponse(rsp)
}

func (c *ClientWithResponses) CreateAWSOnboardingWithResponse(ctx context.Context, body CreateAWSOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSOnboardingResponse, error) {
	rsp, err := c.CreateAWSOnboarding(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSOnboardingResponse(rsp)
}

// GetAWSOnboardingWithResponse request returning *GetAWSOnboardingResponse
func (c *ClientWithResponses) GetAWSOnboardingWithResponse(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*GetAWSOnboardingResponse, error) {
	rsp, err := c.GetAWSOnboarding(ctx, onboardingID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSOnboardingResponse(rsp)
}

// GetAWSAccountsInRootWithResponse request returning *GetAWSAccountsInRootResponse
func (c *ClientWithResponses) GetAWSAccountsInRootWithResponse(ctx context.Context, onboardingID OnboardingID, reqEditors ...RequestEditorFn) (*GetAWSAccountsInRootResponse, error) {
	rsp, err := c.GetAWSAccountsInRoot(ctx, onboardingID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSAccountsInRootResponse(rsp)
}

// ProvisionOnboardingConfigurationWithBodyWithResponse request with arbitrary body returning *ProvisionOnboardingConfigurationResponse
func (c *ClientWithResponses) ProvisionOnboardingConfigurationWithBodyWithResponse(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProvisionOnboardingConfigurationResponse, error) {
	rsp, err := c.ProvisionOnboardingConfigurationWithBody(ctx, onboardingID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisionOnboardingConfigurationResponse(rsp)
}

func (c *ClientWithResponses) ProvisionOnboardingConfigurationWithResponse(ctx context.Context, onboardingID OnboardingID, body ProvisionOnboardingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*ProvisionOnboardingConfigurationResponse, error) {
	rsp, err := c.ProvisionOnboardingConfiguration(ctx, onboardingID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisionOnboardingConfigurationResponse(rsp)
}

// GetAWSAccountsInParentWithResponse request returning *GetAWSAccountsInParentResponse
func (c *ClientWithResponses) GetAWSAccountsInParentWithResponse(ctx context.Context, onboardingID OnboardingID, organizationalUnitID OrganizationalUnitID, reqEditors ...RequestEditorFn) (*GetAWSAccountsInParentResponse, error) {
	rsp, err := c.GetAWSAccountsInParent(ctx, onboardingID, organizationalUnitID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSAccountsInParentResponse(rsp)
}

// NotifyOnboardingWithBodyWithResponse request with arbitrary body returning *NotifyOnboardingResponse
func (c *ClientWithResponses) NotifyOnboardingWithBodyWithResponse(ctx context.Context, onboardingID OnboardingID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotifyOnboardingResponse, error) {
	rsp, err := c.NotifyOnboardingWithBody(ctx, onboardingID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyOnboardingResponse(rsp)
}

func (c *ClientWithResponses) NotifyOnboardingWithResponse(ctx context.Context, onboardingID OnboardingID, body NotifyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*NotifyOnboardingResponse, error) {
	rsp, err := c.NotifyOnboarding(ctx, onboardingID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyOnboardingResponse(rsp)
}

// GetOpenAPIJSONWithResponse request returning *GetOpenAPIJSONResponse
func (c *ClientWithResponses) GetOpenAPIJSONWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenAPIJSONResponse, error) {
	rsp, err := c.GetOpenAPIJSON(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenAPIJSONResponse(rsp)
}

// GetPlatformInfoWithResponse request returning *GetPlatformInfoResponse
func (c *ClientWithResponses) GetPlatformInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlatformInfoResponse, error) {
	rsp, err := c.GetPlatformInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformInfoResponse(rsp)
}

// ListPlatformVersionsWithResponse request returning *ListPlatformVersionsResponse
func (c *ClientWithResponses) ListPlatformVersionsWithResponse(ctx context.Context, params *ListPlatformVersionsParams, reqEditors ...RequestEditorFn) (*ListPlatformVersionsResponse, error) {
	rsp, err := c.ListPlatformVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlatformVersionsResponse(rsp)
}

// ListPluginsWithResponse request returning *ListPluginsResponse
func (c *ClientWithResponses) ListPluginsWithResponse(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*ListPluginsResponse, error) {
	rsp, err := c.ListPlugins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsResponse(rsp)
}

// GetPluginWithResponse request returning *GetPluginResponse
func (c *ClientWithResponses) GetPluginWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginResponse, error) {
	rsp, err := c.GetPlugin(ctx, teamName, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginResponse(rsp)
}

// ListPluginVersionsWithResponse request returning *ListPluginVersionsResponse
func (c *ClientWithResponses) ListPluginVersionsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionsResponse, error) {
	rsp, err := c.ListPluginVersions(ctx, teamName, pluginKind, pluginName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionsResponse(rsp)
}

// GetPluginVersionWithResponse request returning *GetPluginVersionResponse
func (c *ClientWithResponses) GetPluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetPluginVersionResponse, error) {
	rsp, err := c.GetPluginVersion(ctx, teamName, pluginKind, pluginName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginVersionResponse(rsp)
}

// DownloadPluginAssetWithResponse request returning *DownloadPluginAssetResponse
func (c *ClientWithResponses) DownloadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetResponse, error) {
	rsp, err := c.DownloadPluginAsset(ctx, teamName, pluginKind, pluginName, versionName, targetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPluginAssetResponse(rsp)
}

// ListPluginVersionTablesWithResponse request returning *ListPluginVersionTablesResponse
func (c *ClientWithResponses) ListPluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*ListPluginVersionTablesResponse, error) {
	rsp, err := c.ListPluginVersionTables(ctx, teamName, pluginKind, pluginName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionTablesResponse(rsp)
}

// GetPluginVersionTableWithResponse request returning *GetPluginVersionTableResponse
func (c *ClientWithResponses) GetPluginVersionTableWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*GetPluginVersionTableResponse, error) {
	rsp, err := c.GetPluginVersionTable(ctx, teamName, pluginKind, pluginName, versionName, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginVersionTableResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// GetPolicyMetricsWithResponse request returning *GetPolicyMetricsResponse
func (c *ClientWithResponses) GetPolicyMetricsWithResponse(ctx context.Context, params *GetPolicyMetricsParams, reqEditors ...RequestEditorFn) (*GetPolicyMetricsResponse, error) {
	rsp, err := c.GetPolicyMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyMetricsResponse(rsp)
}

// GetViolationsByDomainWithResponse request returning *GetViolationsByDomainResponse
func (c *ClientWithResponses) GetViolationsByDomainWithResponse(ctx context.Context, params *GetViolationsByDomainParams, reqEditors ...RequestEditorFn) (*GetViolationsByDomainResponse, error) {
	rsp, err := c.GetViolationsByDomain(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetViolationsByDomainResponse(rsp)
}

// GetViolationsHistoryWithResponse request returning *GetViolationsHistoryResponse
func (c *ClientWithResponses) GetViolationsHistoryWithResponse(ctx context.Context, params *GetViolationsHistoryParams, reqEditors ...RequestEditorFn) (*GetViolationsHistoryResponse, error) {
	rsp, err := c.GetViolationsHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetViolationsHistoryResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyID PolicyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyID PolicyID, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// TogglePolicyWithResponse request returning *TogglePolicyResponse
func (c *ClientWithResponses) TogglePolicyWithResponse(ctx context.Context, policyID PolicyID, reqEditors ...RequestEditorFn) (*TogglePolicyResponse, error) {
	rsp, err := c.TogglePolicy(ctx, policyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTogglePolicyResponse(rsp)
}

// GetPolicyViolationsWithResponse request returning *GetPolicyViolationsResponse
func (c *ClientWithResponses) GetPolicyViolationsWithResponse(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsParams, reqEditors ...RequestEditorFn) (*GetPolicyViolationsResponse, error) {
	rsp, err := c.GetPolicyViolations(ctx, policyID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyViolationsResponse(rsp)
}

// GetPolicyViolationsHistoryWithResponse request returning *GetPolicyViolationsHistoryResponse
func (c *ClientWithResponses) GetPolicyViolationsHistoryWithResponse(ctx context.Context, policyID PolicyID, params *GetPolicyViolationsHistoryParams, reqEditors ...RequestEditorFn) (*GetPolicyViolationsHistoryResponse, error) {
	rsp, err := c.GetPolicyViolationsHistory(ctx, policyID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyViolationsHistoryResponse(rsp)
}

// ListPolicyGroupsWithResponse request returning *ListPolicyGroupsResponse
func (c *ClientWithResponses) ListPolicyGroupsWithResponse(ctx context.Context, params *ListPolicyGroupsParams, reqEditors ...RequestEditorFn) (*ListPolicyGroupsResponse, error) {
	rsp, err := c.ListPolicyGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPolicyGroupsResponse(rsp)
}

// CreatePolicyGroupWithBodyWithResponse request with arbitrary body returning *CreatePolicyGroupResponse
func (c *ClientWithResponses) CreatePolicyGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyGroupResponse, error) {
	rsp, err := c.CreatePolicyGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyGroupResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyGroupWithResponse(ctx context.Context, body CreatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyGroupResponse, error) {
	rsp, err := c.CreatePolicyGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyGroupResponse(rsp)
}

// DeletePolicyGroupWithResponse request returning *DeletePolicyGroupResponse
func (c *ClientWithResponses) DeletePolicyGroupWithResponse(ctx context.Context, policyGroupID PolicyGroupID, reqEditors ...RequestEditorFn) (*DeletePolicyGroupResponse, error) {
	rsp, err := c.DeletePolicyGroup(ctx, policyGroupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyGroupResponse(rsp)
}

// ListPoliciesInGroupWithResponse request returning *ListPoliciesInGroupResponse
func (c *ClientWithResponses) ListPoliciesInGroupWithResponse(ctx context.Context, policyGroupID PolicyGroupID, params *ListPoliciesInGroupParams, reqEditors ...RequestEditorFn) (*ListPoliciesInGroupResponse, error) {
	rsp, err := c.ListPoliciesInGroup(ctx, policyGroupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesInGroupResponse(rsp)
}

// UpdatePolicyGroupWithBodyWithResponse request with arbitrary body returning *UpdatePolicyGroupResponse
func (c *ClientWithResponses) UpdatePolicyGroupWithBodyWithResponse(ctx context.Context, policyGroupID PolicyGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyGroupResponse, error) {
	rsp, err := c.UpdatePolicyGroupWithBody(ctx, policyGroupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyGroupWithResponse(ctx context.Context, policyGroupID PolicyGroupID, body UpdatePolicyGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyGroupResponse, error) {
	rsp, err := c.UpdatePolicyGroup(ctx, policyGroupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyGroupResponse(rsp)
}

// ListAllQueriesWithResponse request returning *ListAllQueriesResponse
func (c *ClientWithResponses) ListAllQueriesWithResponse(ctx context.Context, params *ListAllQueriesParams, reqEditors ...RequestEditorFn) (*ListAllQueriesResponse, error) {
	rsp, err := c.ListAllQueries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllQueriesResponse(rsp)
}

// ExecuteAdHocQueryWithBodyWithResponse request with arbitrary body returning *ExecuteAdHocQueryResponse
func (c *ClientWithResponses) ExecuteAdHocQueryWithBodyWithResponse(ctx context.Context, params *ExecuteAdHocQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteAdHocQueryResponse, error) {
	rsp, err := c.ExecuteAdHocQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteAdHocQueryResponse(rsp)
}

func (c *ClientWithResponses) ExecuteAdHocQueryWithResponse(ctx context.Context, params *ExecuteAdHocQueryParams, body ExecuteAdHocQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteAdHocQueryResponse, error) {
	rsp, err := c.ExecuteAdHocQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteAdHocQueryResponse(rsp)
}

// SaveQueryWithBodyWithResponse request with arbitrary body returning *SaveQueryResponse
func (c *ClientWithResponses) SaveQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveQueryResponse, error) {
	rsp, err := c.SaveQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveQueryResponse(rsp)
}

func (c *ClientWithResponses) SaveQueryWithResponse(ctx context.Context, body SaveQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveQueryResponse, error) {
	rsp, err := c.SaveQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveQueryResponse(rsp)
}

// ListQueryTagsWithResponse request returning *ListQueryTagsResponse
func (c *ClientWithResponses) ListQueryTagsWithResponse(ctx context.Context, params *ListQueryTagsParams, reqEditors ...RequestEditorFn) (*ListQueryTagsResponse, error) {
	rsp, err := c.ListQueryTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQueryTagsResponse(rsp)
}

// DeleteSavedQueryWithResponse request returning *DeleteSavedQueryResponse
func (c *ClientWithResponses) DeleteSavedQueryWithResponse(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error) {
	rsp, err := c.DeleteSavedQuery(ctx, queryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryResponse(rsp)
}

// GetSavedQueryWithResponse request returning *GetSavedQueryResponse
func (c *ClientWithResponses) GetSavedQueryWithResponse(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*GetSavedQueryResponse, error) {
	rsp, err := c.GetSavedQuery(ctx, queryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSavedQueryResponse(rsp)
}

// UpdateQueryWithBodyWithResponse request with arbitrary body returning *UpdateQueryResponse
func (c *ClientWithResponses) UpdateQueryWithBodyWithResponse(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateQueryResponse, error) {
	rsp, err := c.UpdateQueryWithBody(ctx, queryID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQueryResponse(rsp)
}

func (c *ClientWithResponses) UpdateQueryWithResponse(ctx context.Context, queryID QueryID, body UpdateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateQueryResponse, error) {
	rsp, err := c.UpdateQuery(ctx, queryID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQueryResponse(rsp)
}

// DeleteAlertWithResponse request returning *DeleteAlertResponse
func (c *ClientWithResponses) DeleteAlertWithResponse(ctx context.Context, queryID QueryID, reqEditors ...RequestEditorFn) (*DeleteAlertResponse, error) {
	rsp, err := c.DeleteAlert(ctx, queryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAlertResponse(rsp)
}

// ExecuteSavedQueryWithResponse request returning *ExecuteSavedQueryResponse
func (c *ClientWithResponses) ExecuteSavedQueryWithResponse(ctx context.Context, queryID QueryID, params *ExecuteSavedQueryParams, reqEditors ...RequestEditorFn) (*ExecuteSavedQueryResponse, error) {
	rsp, err := c.ExecuteSavedQuery(ctx, queryID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteSavedQueryResponse(rsp)
}

// QueryListFiltersWithResponse request returning *QueryListFiltersResponse
func (c *ClientWithResponses) QueryListFiltersWithResponse(ctx context.Context, queryID QueryID, params *QueryListFiltersParams, reqEditors ...RequestEditorFn) (*QueryListFiltersResponse, error) {
	rsp, err := c.QueryListFilters(ctx, queryID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryListFiltersResponse(rsp)
}

// QuerySaveFilterWithBodyWithResponse request with arbitrary body returning *QuerySaveFilterResponse
func (c *ClientWithResponses) QuerySaveFilterWithBodyWithResponse(ctx context.Context, queryID QueryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QuerySaveFilterResponse, error) {
	rsp, err := c.QuerySaveFilterWithBody(ctx, queryID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerySaveFilterResponse(rsp)
}

func (c *ClientWithResponses) QuerySaveFilterWithResponse(ctx context.Context, queryID QueryID, body QuerySaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*QuerySaveFilterResponse, error) {
	rsp, err := c.QuerySaveFilter(ctx, queryID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerySaveFilterResponse(rsp)
}

// QueryListFilterTagsWithResponse request returning *QueryListFilterTagsResponse
func (c *ClientWithResponses) QueryListFilterTagsWithResponse(ctx context.Context, queryID QueryID, params *QueryListFilterTagsParams, reqEditors ...RequestEditorFn) (*QueryListFilterTagsResponse, error) {
	rsp, err := c.QueryListFilterTags(ctx, queryID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryListFilterTagsResponse(rsp)
}

// ListAllRBACPermissionsWithResponse request returning *ListAllRBACPermissionsResponse
func (c *ClientWithResponses) ListAllRBACPermissionsWithResponse(ctx context.Context, params *ListAllRBACPermissionsParams, reqEditors ...RequestEditorFn) (*ListAllRBACPermissionsResponse, error) {
	rsp, err := c.ListAllRBACPermissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllRBACPermissionsResponse(rsp)
}

// CreateRBACPermissionWithBodyWithResponse request with arbitrary body returning *CreateRBACPermissionResponse
func (c *ClientWithResponses) CreateRBACPermissionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRBACPermissionResponse, error) {
	rsp, err := c.CreateRBACPermissionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRBACPermissionResponse(rsp)
}

func (c *ClientWithResponses) CreateRBACPermissionWithResponse(ctx context.Context, body CreateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRBACPermissionResponse, error) {
	rsp, err := c.CreateRBACPermission(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRBACPermissionResponse(rsp)
}

// DeleteRBACPermissionWithResponse request returning *DeleteRBACPermissionResponse
func (c *ClientWithResponses) DeleteRBACPermissionWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*DeleteRBACPermissionResponse, error) {
	rsp, err := c.DeleteRBACPermission(ctx, rbacPermissionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRBACPermissionResponse(rsp)
}

// GetRBACPermissionWithResponse request returning *GetRBACPermissionResponse
func (c *ClientWithResponses) GetRBACPermissionWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, reqEditors ...RequestEditorFn) (*GetRBACPermissionResponse, error) {
	rsp, err := c.GetRBACPermission(ctx, rbacPermissionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRBACPermissionResponse(rsp)
}

// UpdateRBACPermissionWithBodyWithResponse request with arbitrary body returning *UpdateRBACPermissionResponse
func (c *ClientWithResponses) UpdateRBACPermissionWithBodyWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRBACPermissionResponse, error) {
	rsp, err := c.UpdateRBACPermissionWithBody(ctx, rbacPermissionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRBACPermissionResponse(rsp)
}

func (c *ClientWithResponses) UpdateRBACPermissionWithResponse(ctx context.Context, rbacPermissionID RBACPermissionID, body UpdateRBACPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRBACPermissionResponse, error) {
	rsp, err := c.UpdateRBACPermission(ctx, rbacPermissionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRBACPermissionResponse(rsp)
}

// ListAllRBACRolesWithResponse request returning *ListAllRBACRolesResponse
func (c *ClientWithResponses) ListAllRBACRolesWithResponse(ctx context.Context, params *ListAllRBACRolesParams, reqEditors ...RequestEditorFn) (*ListAllRBACRolesResponse, error) {
	rsp, err := c.ListAllRBACRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllRBACRolesResponse(rsp)
}

// CreateRBACRoleWithBodyWithResponse request with arbitrary body returning *CreateRBACRoleResponse
func (c *ClientWithResponses) CreateRBACRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRBACRoleResponse, error) {
	rsp, err := c.CreateRBACRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRBACRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRBACRoleWithResponse(ctx context.Context, body CreateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRBACRoleResponse, error) {
	rsp, err := c.CreateRBACRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRBACRoleResponse(rsp)
}

// DeleteRBACRoleWithResponse request returning *DeleteRBACRoleResponse
func (c *ClientWithResponses) DeleteRBACRoleWithResponse(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*DeleteRBACRoleResponse, error) {
	rsp, err := c.DeleteRBACRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRBACRoleResponse(rsp)
}

// GetRBACRoleWithResponse request returning *GetRBACRoleResponse
func (c *ClientWithResponses) GetRBACRoleWithResponse(ctx context.Context, roleID RoleID, reqEditors ...RequestEditorFn) (*GetRBACRoleResponse, error) {
	rsp, err := c.GetRBACRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRBACRoleResponse(rsp)
}

// UpdateRBACRoleWithBodyWithResponse request with arbitrary body returning *UpdateRBACRoleResponse
func (c *ClientWithResponses) UpdateRBACRoleWithBodyWithResponse(ctx context.Context, roleID RoleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRBACRoleResponse, error) {
	rsp, err := c.UpdateRBACRoleWithBody(ctx, roleID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRBACRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRBACRoleWithResponse(ctx context.Context, roleID RoleID, body UpdateRBACRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRBACRoleResponse, error) {
	rsp, err := c.UpdateRBACRole(ctx, roleID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRBACRoleResponse(rsp)
}

// ListReportsWithResponse request returning *ListReportsResponse
func (c *ClientWithResponses) ListReportsWithResponse(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResponse, error) {
	rsp, err := c.ListReports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportsResponse(rsp)
}

// CreateReportWithBodyWithResponse request with arbitrary body returning *CreateReportResponse
func (c *ClientWithResponses) CreateReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportResponse, error) {
	rsp, err := c.CreateReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportResponse(rsp)
}

func (c *ClientWithResponses) CreateReportWithResponse(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportResponse, error) {
	rsp, err := c.CreateReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportResponse(rsp)
}

// ListReportTemplatesWithResponse request returning *ListReportTemplatesResponse
func (c *ClientWithResponses) ListReportTemplatesWithResponse(ctx context.Context, params *ListReportTemplatesParams, reqEditors ...RequestEditorFn) (*ListReportTemplatesResponse, error) {
	rsp, err := c.ListReportTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportTemplatesResponse(rsp)
}

// CreateReportTemplateWithBodyWithResponse request with arbitrary body returning *CreateReportTemplateResponse
func (c *ClientWithResponses) CreateReportTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportTemplateResponse, error) {
	rsp, err := c.CreateReportTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateReportTemplateWithResponse(ctx context.Context, body CreateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportTemplateResponse, error) {
	rsp, err := c.CreateReportTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportTemplateResponse(rsp)
}

// DeleteReportTemplateWithResponse request returning *DeleteReportTemplateResponse
func (c *ClientWithResponses) DeleteReportTemplateWithResponse(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteReportTemplateResponse, error) {
	rsp, err := c.DeleteReportTemplate(ctx, templateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReportTemplateResponse(rsp)
}

// GetReportTemplateWithResponse request returning *GetReportTemplateResponse
func (c *ClientWithResponses) GetReportTemplateWithResponse(ctx context.Context, templateId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetReportTemplateResponse, error) {
	rsp, err := c.GetReportTemplate(ctx, templateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportTemplateResponse(rsp)
}

// UpdateReportTemplateWithBodyWithResponse request with arbitrary body returning *UpdateReportTemplateResponse
func (c *ClientWithResponses) UpdateReportTemplateWithBodyWithResponse(ctx context.Context, templateId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReportTemplateResponse, error) {
	rsp, err := c.UpdateReportTemplateWithBody(ctx, templateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReportTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateReportTemplateWithResponse(ctx context.Context, templateId openapi_types.UUID, body UpdateReportTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReportTemplateResponse, error) {
	rsp, err := c.UpdateReportTemplate(ctx, templateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReportTemplateResponse(rsp)
}

// DeleteReportWithResponse request returning *DeleteReportResponse
func (c *ClientWithResponses) DeleteReportWithResponse(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteReportResponse, error) {
	rsp, err := c.DeleteReport(ctx, reportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReportResponse(rsp)
}

// GetReportWithResponse request returning *GetReportResponse
func (c *ClientWithResponses) GetReportWithResponse(ctx context.Context, reportId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetReportResponse, error) {
	rsp, err := c.GetReport(ctx, reportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportResponse(rsp)
}

// UpdateReportWithBodyWithResponse request with arbitrary body returning *UpdateReportResponse
func (c *ClientWithResponses) UpdateReportWithBodyWithResponse(ctx context.Context, reportId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReportResponse, error) {
	rsp, err := c.UpdateReportWithBody(ctx, reportId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReportResponse(rsp)
}

func (c *ClientWithResponses) UpdateReportWithResponse(ctx context.Context, reportId openapi_types.UUID, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReportResponse, error) {
	rsp, err := c.UpdateReport(ctx, reportId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReportResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// UpdateSettingsWithBodyWithResponse request with arbitrary body returning *UpdateSettingsResponse
func (c *ClientWithResponses) UpdateSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error) {
	rsp, err := c.UpdateSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsWithResponse(ctx context.Context, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error) {
	rsp, err := c.UpdateSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsResponse(rsp)
}

// GetDataSettingsWithResponse request returning *GetDataSettingsResponse
func (c *ClientWithResponses) GetDataSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataSettingsResponse, error) {
	rsp, err := c.GetDataSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataSettingsResponse(rsp)
}

// UpdateDataSettingsWithBodyWithResponse request with arbitrary body returning *UpdateDataSettingsResponse
func (c *ClientWithResponses) UpdateDataSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataSettingsResponse, error) {
	rsp, err := c.UpdateDataSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDataSettingsWithResponse(ctx context.Context, body UpdateDataSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataSettingsResponse, error) {
	rsp, err := c.UpdateDataSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataSettingsResponse(rsp)
}

// CreateSlackConnectionWithBodyWithResponse request with arbitrary body returning *CreateSlackConnectionResponse
func (c *ClientWithResponses) CreateSlackConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSlackConnectionResponse, error) {
	rsp, err := c.CreateSlackConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSlackConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateSlackConnectionWithResponse(ctx context.Context, body CreateSlackConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSlackConnectionResponse, error) {
	rsp, err := c.CreateSlackConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSlackConnectionResponse(rsp)
}

// ListSlackChannelsWithResponse request returning *ListSlackChannelsResponse
func (c *ClientWithResponses) ListSlackChannelsWithResponse(ctx context.Context, id openapi_types.UUID, params *ListSlackChannelsParams, reqEditors ...RequestEditorFn) (*ListSlackChannelsResponse, error) {
	rsp, err := c.ListSlackChannels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSlackChannelsResponse(rsp)
}

// CreateSyncDestinationTestConnectionWithBodyWithResponse request with arbitrary body returning *CreateSyncDestinationTestConnectionResponse
func (c *ClientWithResponses) CreateSyncDestinationTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncDestinationTestConnectionResponse, error) {
	rsp, err := c.CreateSyncDestinationTestConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncDestinationTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncDestinationTestConnectionWithResponse(ctx context.Context, body CreateSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncDestinationTestConnectionResponse, error) {
	rsp, err := c.CreateSyncDestinationTestConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncDestinationTestConnectionResponse(rsp)
}

// GetSyncDestinationTestConnectionWithResponse request returning *GetSyncDestinationTestConnectionResponse
func (c *ClientWithResponses) GetSyncDestinationTestConnectionWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, reqEditors ...RequestEditorFn) (*GetSyncDestinationTestConnectionResponse, error) {
	rsp, err := c.GetSyncDestinationTestConnection(ctx, syncDestinationTestConnectionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncDestinationTestConnectionResponse(rsp)
}

// UpdateSyncTestConnectionForSyncDestinationWithBodyWithResponse request with arbitrary body returning *UpdateSyncTestConnectionForSyncDestinationResponse
func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncDestinationWithBodyWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncDestinationWithBody(ctx, syncDestinationTestConnectionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncDestinationWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncDestination(ctx, syncDestinationTestConnectionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncDestinationResponse(rsp)
}

// GetSyncDestinationTestConnectionLogsLiveWithResponse request returning *GetSyncDestinationTestConnectionLogsLiveResponse
func (c *ClientWithResponses) GetSyncDestinationTestConnectionLogsLiveWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*GetSyncDestinationTestConnectionLogsLiveResponse, error) {
	rsp, err := c.GetSyncDestinationTestConnectionLogsLive(ctx, syncDestinationTestConnectionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncDestinationTestConnectionLogsLiveResponse(rsp)
}

// GetSyncDestinationTestConnectionLogsQueryWithResponse request returning *GetSyncDestinationTestConnectionLogsQueryResponse
func (c *ClientWithResponses) GetSyncDestinationTestConnectionLogsQueryWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, params *GetSyncDestinationTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*GetSyncDestinationTestConnectionLogsQueryResponse, error) {
	rsp, err := c.GetSyncDestinationTestConnectionLogsQuery(ctx, syncDestinationTestConnectionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncDestinationTestConnectionLogsQueryResponse(rsp)
}

// PromoteSyncDestinationTestConnectionWithBodyWithResponse request with arbitrary body returning *PromoteSyncDestinationTestConnectionResponse
func (c *ClientWithResponses) PromoteSyncDestinationTestConnectionWithBodyWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromoteSyncDestinationTestConnectionResponse, error) {
	rsp, err := c.PromoteSyncDestinationTestConnectionWithBody(ctx, syncDestinationTestConnectionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromoteSyncDestinationTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) PromoteSyncDestinationTestConnectionWithResponse(ctx context.Context, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body PromoteSyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PromoteSyncDestinationTestConnectionResponse, error) {
	rsp, err := c.PromoteSyncDestinationTestConnection(ctx, syncDestinationTestConnectionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromoteSyncDestinationTestConnectionResponse(rsp)
}

// ListSyncDestinationsWithResponse request returning *ListSyncDestinationsResponse
func (c *ClientWithResponses) ListSyncDestinationsWithResponse(ctx context.Context, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*ListSyncDestinationsResponse, error) {
	rsp, err := c.ListSyncDestinations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncDestinationsResponse(rsp)
}

// DeleteSyncDestinationWithResponse request returning *DeleteSyncDestinationResponse
func (c *ClientWithResponses) DeleteSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*DeleteSyncDestinationResponse, error) {
	rsp, err := c.DeleteSyncDestination(ctx, syncDestinationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncDestinationResponse(rsp)
}

// GetSyncDestinationWithResponse request returning *GetSyncDestinationResponse
func (c *ClientWithResponses) GetSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*GetSyncDestinationResponse, error) {
	rsp, err := c.GetSyncDestination(ctx, syncDestinationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncDestinationResponse(rsp)
}

// UpdateSyncDestinationWithBodyWithResponse request with arbitrary body returning *UpdateSyncDestinationResponse
func (c *ClientWithResponses) UpdateSyncDestinationWithBodyWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error) {
	rsp, err := c.UpdateSyncDestinationWithBody(ctx, syncDestinationName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error) {
	rsp, err := c.UpdateSyncDestination(ctx, syncDestinationName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncDestinationResponse(rsp)
}

// ListSyncDestinationSyncsWithResponse request returning *ListSyncDestinationSyncsResponse
func (c *ClientWithResponses) ListSyncDestinationSyncsWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, params *ListSyncDestinationSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncDestinationSyncsResponse, error) {
	rsp, err := c.ListSyncDestinationSyncs(ctx, syncDestinationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncDestinationSyncsResponse(rsp)
}

// GetTestConnectionForSyncDestinationWithResponse request returning *GetTestConnectionForSyncDestinationResponse
func (c *ClientWithResponses) GetTestConnectionForSyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*GetTestConnectionForSyncDestinationResponse, error) {
	rsp, err := c.GetTestConnectionForSyncDestination(ctx, syncDestinationName, syncTestConnectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestConnectionForSyncDestinationResponse(rsp)
}

// CreateSyncSourceTestConnectionWithBodyWithResponse request with arbitrary body returning *CreateSyncSourceTestConnectionResponse
func (c *ClientWithResponses) CreateSyncSourceTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncSourceTestConnectionResponse, error) {
	rsp, err := c.CreateSyncSourceTestConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncSourceTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncSourceTestConnectionWithResponse(ctx context.Context, body CreateSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncSourceTestConnectionResponse, error) {
	rsp, err := c.CreateSyncSourceTestConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncSourceTestConnectionResponse(rsp)
}

// GetSyncSourceTestConnectionWithResponse request returning *GetSyncSourceTestConnectionResponse
func (c *ClientWithResponses) GetSyncSourceTestConnectionWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, reqEditors ...RequestEditorFn) (*GetSyncSourceTestConnectionResponse, error) {
	rsp, err := c.GetSyncSourceTestConnection(ctx, syncSourceTestConnectionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncSourceTestConnectionResponse(rsp)
}

// UpdateSyncTestConnectionForSyncSourceWithBodyWithResponse request with arbitrary body returning *UpdateSyncTestConnectionForSyncSourceResponse
func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncSourceWithBodyWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncSourceWithBody(ctx, syncSourceTestConnectionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncSourceWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncSource(ctx, syncSourceTestConnectionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncSourceResponse(rsp)
}

// GetSyncSourceTestConnectionLogsLiveWithResponse request returning *GetSyncSourceTestConnectionLogsLiveResponse
func (c *ClientWithResponses) GetSyncSourceTestConnectionLogsLiveWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsLiveParams, reqEditors ...RequestEditorFn) (*GetSyncSourceTestConnectionLogsLiveResponse, error) {
	rsp, err := c.GetSyncSourceTestConnectionLogsLive(ctx, syncSourceTestConnectionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncSourceTestConnectionLogsLiveResponse(rsp)
}

// GetSyncSourceTestConnectionLogsQueryWithResponse request returning *GetSyncSourceTestConnectionLogsQueryResponse
func (c *ClientWithResponses) GetSyncSourceTestConnectionLogsQueryWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, params *GetSyncSourceTestConnectionLogsQueryParams, reqEditors ...RequestEditorFn) (*GetSyncSourceTestConnectionLogsQueryResponse, error) {
	rsp, err := c.GetSyncSourceTestConnectionLogsQuery(ctx, syncSourceTestConnectionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncSourceTestConnectionLogsQueryResponse(rsp)
}

// PromoteSyncSourceTestConnectionWithBodyWithResponse request with arbitrary body returning *PromoteSyncSourceTestConnectionResponse
func (c *ClientWithResponses) PromoteSyncSourceTestConnectionWithBodyWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromoteSyncSourceTestConnectionResponse, error) {
	rsp, err := c.PromoteSyncSourceTestConnectionWithBody(ctx, syncSourceTestConnectionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromoteSyncSourceTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) PromoteSyncSourceTestConnectionWithResponse(ctx context.Context, syncSourceTestConnectionID SyncSourceTestConnectionID, body PromoteSyncSourceTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PromoteSyncSourceTestConnectionResponse, error) {
	rsp, err := c.PromoteSyncSourceTestConnection(ctx, syncSourceTestConnectionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromoteSyncSourceTestConnectionResponse(rsp)
}

// ListSyncSourcesWithResponse request returning *ListSyncSourcesResponse
func (c *ClientWithResponses) ListSyncSourcesWithResponse(ctx context.Context, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*ListSyncSourcesResponse, error) {
	rsp, err := c.ListSyncSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncSourcesResponse(rsp)
}

// DeleteSyncSourceWithResponse request returning *DeleteSyncSourceResponse
func (c *ClientWithResponses) DeleteSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*DeleteSyncSourceResponse, error) {
	rsp, err := c.DeleteSyncSource(ctx, syncSourceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncSourceResponse(rsp)
}

// GetSyncSourceWithResponse request returning *GetSyncSourceResponse
func (c *ClientWithResponses) GetSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*GetSyncSourceResponse, error) {
	rsp, err := c.GetSyncSource(ctx, syncSourceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncSourceResponse(rsp)
}

// UpdateSyncSourceWithBodyWithResponse request with arbitrary body returning *UpdateSyncSourceResponse
func (c *ClientWithResponses) UpdateSyncSourceWithBodyWithResponse(ctx context.Context, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error) {
	rsp, err := c.UpdateSyncSourceWithBody(ctx, syncSourceName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error) {
	rsp, err := c.UpdateSyncSource(ctx, syncSourceName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncSourceResponse(rsp)
}

// ListSyncSourceSyncsWithResponse request returning *ListSyncSourceSyncsResponse
func (c *ClientWithResponses) ListSyncSourceSyncsWithResponse(ctx context.Context, syncSourceName SyncSourceName, params *ListSyncSourceSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncSourceSyncsResponse, error) {
	rsp, err := c.ListSyncSourceSyncs(ctx, syncSourceName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncSourceSyncsResponse(rsp)
}

// GetTestConnectionForSyncSourceWithResponse request returning *GetTestConnectionForSyncSourceResponse
func (c *ClientWithResponses) GetTestConnectionForSyncSourceWithResponse(ctx context.Context, syncSourceName SyncSourceName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*GetTestConnectionForSyncSourceResponse, error) {
	rsp, err := c.GetTestConnectionForSyncSource(ctx, syncSourceName, syncTestConnectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestConnectionForSyncSourceResponse(rsp)
}

// ListSyncTransformersWithResponse request returning *ListSyncTransformersResponse
func (c *ClientWithResponses) ListSyncTransformersWithResponse(ctx context.Context, params *ListSyncTransformersParams, reqEditors ...RequestEditorFn) (*ListSyncTransformersResponse, error) {
	rsp, err := c.ListSyncTransformers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncTransformersResponse(rsp)
}

// DeleteSyncTransformerWithResponse request returning *DeleteSyncTransformerResponse
func (c *ClientWithResponses) DeleteSyncTransformerWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*DeleteSyncTransformerResponse, error) {
	rsp, err := c.DeleteSyncTransformer(ctx, syncTransformerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncTransformerResponse(rsp)
}

// GetSyncTransformerWithResponse request returning *GetSyncTransformerResponse
func (c *ClientWithResponses) GetSyncTransformerWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, reqEditors ...RequestEditorFn) (*GetSyncTransformerResponse, error) {
	rsp, err := c.GetSyncTransformer(ctx, syncTransformerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncTransformerResponse(rsp)
}

// UpdateSyncTransformerWithBodyWithResponse request with arbitrary body returning *UpdateSyncTransformerResponse
func (c *ClientWithResponses) UpdateSyncTransformerWithBodyWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTransformerResponse, error) {
	rsp, err := c.UpdateSyncTransformerWithBody(ctx, syncTransformerName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTransformerResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncTransformerWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, body UpdateSyncTransformerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTransformerResponse, error) {
	rsp, err := c.UpdateSyncTransformer(ctx, syncTransformerName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTransformerResponse(rsp)
}

// ListSyncTransformerSyncDestinationsWithResponse request returning *ListSyncTransformerSyncDestinationsResponse
func (c *ClientWithResponses) ListSyncTransformerSyncDestinationsWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncDestinationsParams, reqEditors ...RequestEditorFn) (*ListSyncTransformerSyncDestinationsResponse, error) {
	rsp, err := c.ListSyncTransformerSyncDestinations(ctx, syncTransformerName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncTransformerSyncDestinationsResponse(rsp)
}

// ListSyncTransformerSyncsWithResponse request returning *ListSyncTransformerSyncsResponse
func (c *ClientWithResponses) ListSyncTransformerSyncsWithResponse(ctx context.Context, syncTransformerName SyncTransformerName, params *ListSyncTransformerSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncTransformerSyncsResponse, error) {
	rsp, err := c.ListSyncTransformerSyncs(ctx, syncTransformerName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncTransformerSyncsResponse(rsp)
}

// ListSyncUpgradesWithResponse request returning *ListSyncUpgradesResponse
func (c *ClientWithResponses) ListSyncUpgradesWithResponse(ctx context.Context, params *ListSyncUpgradesParams, reqEditors ...RequestEditorFn) (*ListSyncUpgradesResponse, error) {
	rsp, err := c.ListSyncUpgrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncUpgradesResponse(rsp)
}

// ListSyncsWithResponse request returning *ListSyncsResponse
func (c *ClientWithResponses) ListSyncsWithResponse(ctx context.Context, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncsResponse, error) {
	rsp, err := c.ListSyncs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncsResponse(rsp)
}

// CreateSyncWithBodyWithResponse request with arbitrary body returning *CreateSyncResponse
func (c *ClientWithResponses) CreateSyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error) {
	rsp, err := c.CreateSyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncWithResponse(ctx context.Context, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error) {
	rsp, err := c.CreateSync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncResponse(rsp)
}

// DeleteSyncWithResponse request returning *DeleteSyncResponse
func (c *ClientWithResponses) DeleteSyncWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*DeleteSyncResponse, error) {
	rsp, err := c.DeleteSync(ctx, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncResponse(rsp)
}

// GetSyncWithResponse request returning *GetSyncResponse
func (c *ClientWithResponses) GetSyncWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*GetSyncResponse, error) {
	rsp, err := c.GetSync(ctx, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncResponse(rsp)
}

// UpdateSyncWithBodyWithResponse request with arbitrary body returning *UpdateSyncResponse
func (c *ClientWithResponses) UpdateSyncWithBodyWithResponse(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error) {
	rsp, err := c.UpdateSyncWithBody(ctx, syncName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncWithResponse(ctx context.Context, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error) {
	rsp, err := c.UpdateSync(ctx, syncName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncResponse(rsp)
}

// ListSyncRunsWithResponse request returning *ListSyncRunsResponse
func (c *ClientWithResponses) ListSyncRunsWithResponse(ctx context.Context, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*ListSyncRunsResponse, error) {
	rsp, err := c.ListSyncRuns(ctx, syncName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncRunsResponse(rsp)
}

// CreateSyncRunWithResponse request returning *CreateSyncRunResponse
func (c *ClientWithResponses) CreateSyncRunWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*CreateSyncRunResponse, error) {
	rsp, err := c.CreateSyncRun(ctx, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunResponse(rsp)
}

// GetSyncRunWithResponse request returning *GetSyncRunResponse
func (c *ClientWithResponses) GetSyncRunWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*GetSyncRunResponse, error) {
	rsp, err := c.GetSyncRun(ctx, syncName, syncRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunResponse(rsp)
}

// UpdateSyncRunWithBodyWithResponse request with arbitrary body returning *UpdateSyncRunResponse
func (c *ClientWithResponses) UpdateSyncRunWithBodyWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error) {
	rsp, err := c.UpdateSyncRunWithBody(ctx, syncName, syncRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncRunResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncRunWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error) {
	rsp, err := c.UpdateSyncRun(ctx, syncName, syncRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncRunResponse(rsp)
}

// GetSyncRunLogsLiveWithResponse request returning *GetSyncRunLogsLiveResponse
func (c *ClientWithResponses) GetSyncRunLogsLiveWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsLiveParams, reqEditors ...RequestEditorFn) (*GetSyncRunLogsLiveResponse, error) {
	rsp, err := c.GetSyncRunLogsLive(ctx, syncName, syncRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunLogsLiveResponse(rsp)
}

// GetSyncRunLogsQueryWithResponse request returning *GetSyncRunLogsQueryResponse
func (c *ClientWithResponses) GetSyncRunLogsQueryWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsQueryParams, reqEditors ...RequestEditorFn) (*GetSyncRunLogsQueryResponse, error) {
	rsp, err := c.GetSyncRunLogsQuery(ctx, syncName, syncRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunLogsQueryResponse(rsp)
}

// CreateSyncRunProgressWithBodyWithResponse request with arbitrary body returning *CreateSyncRunProgressResponse
func (c *ClientWithResponses) CreateSyncRunProgressWithBodyWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error) {
	rsp, err := c.CreateSyncRunProgressWithBody(ctx, syncName, syncRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunProgressResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncRunProgressWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error) {
	rsp, err := c.CreateSyncRunProgress(ctx, syncName, syncRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunProgressResponse(rsp)
}

// GetSyncRunStatsWithResponse request returning *GetSyncRunStatsResponse
func (c *ClientWithResponses) GetSyncRunStatsWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*GetSyncRunStatsResponse, error) {
	rsp, err := c.GetSyncRunStats(ctx, syncName, syncRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunStatsResponse(rsp)
}

// GetSyncRunTablesWithResponse request returning *GetSyncRunTablesResponse
func (c *ClientWithResponses) GetSyncRunTablesWithResponse(ctx context.Context, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunTablesParams, reqEditors ...RequestEditorFn) (*GetSyncRunTablesResponse, error) {
	rsp, err := c.GetSyncRunTables(ctx, syncName, syncRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunTablesResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// GetTablesDataWithResponse request returning *GetTablesDataResponse
func (c *ClientWithResponses) GetTablesDataWithResponse(ctx context.Context, params *GetTablesDataParams, reqEditors ...RequestEditorFn) (*GetTablesDataResponse, error) {
	rsp, err := c.GetTablesData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesDataResponse(rsp)
}

// TablesDataActionWithBodyWithResponse request with arbitrary body returning *TablesDataActionResponse
func (c *ClientWithResponses) TablesDataActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TablesDataActionResponse, error) {
	rsp, err := c.TablesDataActionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTablesDataActionResponse(rsp)
}

func (c *ClientWithResponses) TablesDataActionWithResponse(ctx context.Context, body TablesDataActionJSONRequestBody, reqEditors ...RequestEditorFn) (*TablesDataActionResponse, error) {
	rsp, err := c.TablesDataAction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTablesDataActionResponse(rsp)
}

// BatchTableSchemasWithResponse request returning *BatchTableSchemasResponse
func (c *ClientWithResponses) BatchTableSchemasWithResponse(ctx context.Context, params *BatchTableSchemasParams, reqEditors ...RequestEditorFn) (*BatchTableSchemasResponse, error) {
	rsp, err := c.BatchTableSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBatchTableSchemasResponse(rsp)
}

// TableListColumnsWithResponse request returning *TableListColumnsResponse
func (c *ClientWithResponses) TableListColumnsWithResponse(ctx context.Context, tableName TableName, params *TableListColumnsParams, reqEditors ...RequestEditorFn) (*TableListColumnsResponse, error) {
	rsp, err := c.TableListColumns(ctx, tableName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableListColumnsResponse(rsp)
}

// TableColumnListValuesWithResponse request returning *TableColumnListValuesResponse
func (c *ClientWithResponses) TableColumnListValuesWithResponse(ctx context.Context, tableName TableName, columnName ColumnName, params *TableColumnListValuesParams, reqEditors ...RequestEditorFn) (*TableColumnListValuesResponse, error) {
	rsp, err := c.TableColumnListValues(ctx, tableName, columnName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableColumnListValuesResponse(rsp)
}

// TableListRowsWithResponse request returning *TableListRowsResponse
func (c *ClientWithResponses) TableListRowsWithResponse(ctx context.Context, tableName TableName, params *TableListRowsParams, reqEditors ...RequestEditorFn) (*TableListRowsResponse, error) {
	rsp, err := c.TableListRows(ctx, tableName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableListRowsResponse(rsp)
}

// TableRowByIdWithResponse request returning *TableRowByIdResponse
func (c *ClientWithResponses) TableRowByIdWithResponse(ctx context.Context, tableName TableName, tableRowId TableRowId, params *TableRowByIdParams, reqEditors ...RequestEditorFn) (*TableRowByIdResponse, error) {
	rsp, err := c.TableRowById(ctx, tableName, tableRowId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableRowByIdResponse(rsp)
}

// TableListFiltersWithResponse request returning *TableListFiltersResponse
func (c *ClientWithResponses) TableListFiltersWithResponse(ctx context.Context, tableName TableName, params *TableListFiltersParams, reqEditors ...RequestEditorFn) (*TableListFiltersResponse, error) {
	rsp, err := c.TableListFilters(ctx, tableName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableListFiltersResponse(rsp)
}

// TableSaveFilterWithBodyWithResponse request with arbitrary body returning *TableSaveFilterResponse
func (c *ClientWithResponses) TableSaveFilterWithBodyWithResponse(ctx context.Context, tableName TableName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TableSaveFilterResponse, error) {
	rsp, err := c.TableSaveFilterWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableSaveFilterResponse(rsp)
}

func (c *ClientWithResponses) TableSaveFilterWithResponse(ctx context.Context, tableName TableName, body TableSaveFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*TableSaveFilterResponse, error) {
	rsp, err := c.TableSaveFilter(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableSaveFilterResponse(rsp)
}

// TableListFilterTagsWithResponse request returning *TableListFilterTagsResponse
func (c *ClientWithResponses) TableListFilterTagsWithResponse(ctx context.Context, tableName TableName, params *TableListFilterTagsParams, reqEditors ...RequestEditorFn) (*TableListFilterTagsResponse, error) {
	rsp, err := c.TableListFilterTags(ctx, tableName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableListFilterTagsResponse(rsp)
}

// TableSchemaWithResponse request returning *TableSchemaResponse
func (c *ClientWithResponses) TableSchemaWithResponse(ctx context.Context, tableName TableName, reqEditors ...RequestEditorFn) (*TableSchemaResponse, error) {
	rsp, err := c.TableSchema(ctx, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableSchemaResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// DownloadPluginAssetByTeamWithResponse request returning *DownloadPluginAssetByTeamResponse
func (c *ClientWithResponses) DownloadPluginAssetByTeamWithResponse(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetByTeamResponse, error) {
	rsp, err := c.DownloadPluginAssetByTeam(ctx, teamName, pluginTeam, pluginKind, pluginName, versionName, targetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPluginAssetByTeamResponse(rsp)
}

// UpdateSyncTestConnectionForSyncDestinationTeamWithBodyWithResponse request with arbitrary body returning *UpdateSyncTestConnectionForSyncDestinationTeamResponse
func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncDestinationTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationTeamResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncDestinationTeamWithBody(ctx, teamName, syncDestinationTestConnectionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncDestinationTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncDestinationTeamWithResponse(ctx context.Context, teamName TeamName, syncDestinationTestConnectionID SyncDestinationTestConnectionID, body UpdateSyncTestConnectionForSyncDestinationTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncDestinationTeamResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncDestinationTeam(ctx, teamName, syncDestinationTestConnectionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncDestinationTeamResponse(rsp)
}

// UpdateSyncTestConnectionForSyncSourceTeamWithBodyWithResponse request with arbitrary body returning *UpdateSyncTestConnectionForSyncSourceTeamResponse
func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncSourceTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceTeamResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncSourceTeamWithBody(ctx, teamName, syncSourceTestConnectionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncSourceTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncTestConnectionForSyncSourceTeamWithResponse(ctx context.Context, teamName TeamName, syncSourceTestConnectionID SyncSourceTestConnectionID, body UpdateSyncTestConnectionForSyncSourceTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionForSyncSourceTeamResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionForSyncSourceTeam(ctx, teamName, syncSourceTestConnectionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionForSyncSourceTeamResponse(rsp)
}

// CreateSyncRunProgressTeamWithBodyWithResponse request with arbitrary body returning *CreateSyncRunProgressTeamResponse
func (c *ClientWithResponses) CreateSyncRunProgressTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressTeamResponse, error) {
	rsp, err := c.CreateSyncRunProgressTeamWithBody(ctx, teamName, syncName, syncRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunProgressTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncRunProgressTeamWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressTeamResponse, error) {
	rsp, err := c.CreateSyncRunProgressTeam(ctx, teamName, syncName, syncRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunProgressTeamResponse(rsp)
}

// GetTeamUsageSummaryWithResponse request returning *GetTeamUsageSummaryResponse
func (c *ClientWithResponses) GetTeamUsageSummaryWithResponse(ctx context.Context, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetTeamUsageSummaryResponse, error) {
	rsp, err := c.GetTeamUsageSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamUsageSummaryResponse(rsp)
}

// GetGroupedTeamUsageSummaryWithResponse request returning *GetGroupedTeamUsageSummaryResponse
func (c *ClientWithResponses) GetGroupedTeamUsageSummaryWithResponse(ctx context.Context, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetGroupedTeamUsageSummaryResponse, error) {
	rsp, err := c.GetGroupedTeamUsageSummary(ctx, groupBy, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupedTeamUsageSummaryResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// UpdateCurrentUserWithBodyWithResponse request with arbitrary body returning *UpdateCurrentUserResponse
func (c *ClientWithResponses) UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

// SendAnonymousEventWithBodyWithResponse request with arbitrary body returning *SendAnonymousEventResponse
func (c *ClientWithResponses) SendAnonymousEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendAnonymousEventResponse, error) {
	rsp, err := c.SendAnonymousEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendAnonymousEventResponse(rsp)
}

func (c *ClientWithResponses) SendAnonymousEventWithResponse(ctx context.Context, body SendAnonymousEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SendAnonymousEventResponse, error) {
	rsp, err := c.SendAnonymousEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendAnonymousEventResponse(rsp)
}

// AuthenticateUserWithBodyWithResponse request with arbitrary body returning *AuthenticateUserResponse
func (c *ClientWithResponses) AuthenticateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateUserResponse, error) {
	rsp, err := c.AuthenticateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateUserResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateUserWithResponse(ctx context.Context, body AuthenticateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateUserResponse, error) {
	rsp, err := c.AuthenticateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateUserResponse(rsp)
}

// ChangeUserPasswordWithBodyWithResponse request with arbitrary body returning *ChangeUserPasswordResponse
func (c *ClientWithResponses) ChangeUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeUserPasswordResponse, error) {
	rsp, err := c.ChangeUserPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) ChangeUserPasswordWithResponse(ctx context.Context, body ChangeUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeUserPasswordResponse, error) {
	rsp, err := c.ChangeUserPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeUserPasswordResponse(rsp)
}

// UpdateCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCustomerResponse
func (c *ClientWithResponses) UpdateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerWithResponse(ctx context.Context, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

// SendUserEventWithBodyWithResponse request with arbitrary body returning *SendUserEventResponse
func (c *ClientWithResponses) SendUserEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserEventResponse, error) {
	rsp, err := c.SendUserEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserEventResponse(rsp)
}

func (c *ClientWithResponses) SendUserEventWithResponse(ctx context.Context, body SendUserEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserEventResponse, error) {
	rsp, err := c.SendUserEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserEventResponse(rsp)
}

// LogoutUserWithResponse request returning *LogoutUserResponse
func (c *ClientWithResponses) LogoutUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutUserResponse, error) {
	rsp, err := c.LogoutUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutUserResponse(rsp)
}

// LoginUserWithBodyWithResponse request with arbitrary body returning *LoginUserResponse
func (c *ClientWithResponses) LoginUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginUserResponse, error) {
	rsp, err := c.LoginUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginUserResponse(rsp)
}

func (c *ClientWithResponses) LoginUserWithResponse(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginUserResponse, error) {
	rsp, err := c.LoginUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginUserResponse(rsp)
}

// UserTOTPDeleteWithResponse request returning *UserTOTPDeleteResponse
func (c *ClientWithResponses) UserTOTPDeleteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserTOTPDeleteResponse, error) {
	rsp, err := c.UserTOTPDelete(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserTOTPDeleteResponse(rsp)
}

// UserTOTPSetupWithResponse request returning *UserTOTPSetupResponse
func (c *ClientWithResponses) UserTOTPSetupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserTOTPSetupResponse, error) {
	rsp, err := c.UserTOTPSetup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserTOTPSetupResponse(rsp)
}

// UserTOTPVerifyWithBodyWithResponse request with arbitrary body returning *UserTOTPVerifyResponse
func (c *ClientWithResponses) UserTOTPVerifyWithBodyWithResponse(ctx context.Context, params *UserTOTPVerifyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserTOTPVerifyResponse, error) {
	rsp, err := c.UserTOTPVerifyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserTOTPVerifyResponse(rsp)
}

func (c *ClientWithResponses) UserTOTPVerifyWithResponse(ctx context.Context, params *UserTOTPVerifyParams, body UserTOTPVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*UserTOTPVerifyResponse, error) {
	rsp, err := c.UserTOTPVerify(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserTOTPVerifyResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// AddUserWithBodyWithResponse request with arbitrary body returning *AddUserResponse
func (c *ClientWithResponses) AddUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

func (c *ClientWithResponses) AddUserWithResponse(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// DeleteUserTOTPWithResponse request returning *DeleteUserTOTPResponse
func (c *ClientWithResponses) DeleteUserTOTPWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserTOTPResponse, error) {
	rsp, err := c.DeleteUserTOTP(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserTOTPResponse(rsp)
}

// CreateV2SyncDestinationTestConnectionWithBodyWithResponse request with arbitrary body returning *CreateV2SyncDestinationTestConnectionResponse
func (c *ClientWithResponses) CreateV2SyncDestinationTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationTestConnectionResponse, error) {
	rsp, err := c.CreateV2SyncDestinationTestConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncDestinationTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateV2SyncDestinationTestConnectionWithResponse(ctx context.Context, body CreateV2SyncDestinationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationTestConnectionResponse, error) {
	rsp, err := c.CreateV2SyncDestinationTestConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncDestinationTestConnectionResponse(rsp)
}

// GetV2SyncDestinationsWithResponse request returning *GetV2SyncDestinationsResponse
func (c *ClientWithResponses) GetV2SyncDestinationsWithResponse(ctx context.Context, params *GetV2SyncDestinationsParams, reqEditors ...RequestEditorFn) (*GetV2SyncDestinationsResponse, error) {
	rsp, err := c.GetV2SyncDestinations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SyncDestinationsResponse(rsp)
}

// CreateV2SyncDestinationWithBodyWithResponse request with arbitrary body returning *CreateV2SyncDestinationResponse
func (c *ClientWithResponses) CreateV2SyncDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationResponse, error) {
	rsp, err := c.CreateV2SyncDestinationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) CreateV2SyncDestinationWithResponse(ctx context.Context, body CreateV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncDestinationResponse, error) {
	rsp, err := c.CreateV2SyncDestination(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncDestinationResponse(rsp)
}

// DeleteV2SyncDestinationWithResponse request returning *DeleteV2SyncDestinationResponse
func (c *ClientWithResponses) DeleteV2SyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*DeleteV2SyncDestinationResponse, error) {
	rsp, err := c.DeleteV2SyncDestination(ctx, syncDestinationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2SyncDestinationResponse(rsp)
}

// GetV2SyncDestinationWithResponse request returning *GetV2SyncDestinationResponse
func (c *ClientWithResponses) GetV2SyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*GetV2SyncDestinationResponse, error) {
	rsp, err := c.GetV2SyncDestination(ctx, syncDestinationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SyncDestinationResponse(rsp)
}

// PatchV2SyncDestinationWithBodyWithResponse request with arbitrary body returning *PatchV2SyncDestinationResponse
func (c *ClientWithResponses) PatchV2SyncDestinationWithBodyWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2SyncDestinationResponse, error) {
	rsp, err := c.PatchV2SyncDestinationWithBody(ctx, syncDestinationName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2SyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) PatchV2SyncDestinationWithResponse(ctx context.Context, syncDestinationName SyncDestinationName, body PatchV2SyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2SyncDestinationResponse, error) {
	rsp, err := c.PatchV2SyncDestination(ctx, syncDestinationName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2SyncDestinationResponse(rsp)
}

// CreateV2SyncIntegrationTestConnectionWithBodyWithResponse request with arbitrary body returning *CreateV2SyncIntegrationTestConnectionResponse
func (c *ClientWithResponses) CreateV2SyncIntegrationTestConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationTestConnectionResponse, error) {
	rsp, err := c.CreateV2SyncIntegrationTestConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncIntegrationTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateV2SyncIntegrationTestConnectionWithResponse(ctx context.Context, body CreateV2SyncIntegrationTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationTestConnectionResponse, error) {
	rsp, err := c.CreateV2SyncIntegrationTestConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncIntegrationTestConnectionResponse(rsp)
}

// ListV2SyncIntegrationsWithResponse request returning *ListV2SyncIntegrationsResponse
func (c *ClientWithResponses) ListV2SyncIntegrationsWithResponse(ctx context.Context, params *ListV2SyncIntegrationsParams, reqEditors ...RequestEditorFn) (*ListV2SyncIntegrationsResponse, error) {
	rsp, err := c.ListV2SyncIntegrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListV2SyncIntegrationsResponse(rsp)
}

// CreateV2SyncIntegrationWithBodyWithResponse request with arbitrary body returning *CreateV2SyncIntegrationResponse
func (c *ClientWithResponses) CreateV2SyncIntegrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationResponse, error) {
	rsp, err := c.CreateV2SyncIntegrationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncIntegrationResponse(rsp)
}

func (c *ClientWithResponses) CreateV2SyncIntegrationWithResponse(ctx context.Context, body CreateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2SyncIntegrationResponse, error) {
	rsp, err := c.CreateV2SyncIntegration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateV2SyncIntegrationResponse(rsp)
}

// DeleteV2SyncIntegrationWithResponse request returning *DeleteV2SyncIntegrationResponse
func (c *ClientWithResponses) DeleteV2SyncIntegrationWithResponse(ctx context.Context, syncName SyncName, params *DeleteV2SyncIntegrationParams, reqEditors ...RequestEditorFn) (*DeleteV2SyncIntegrationResponse, error) {
	rsp, err := c.DeleteV2SyncIntegration(ctx, syncName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2SyncIntegrationResponse(rsp)
}

// GetV2SyncIntegrationWithResponse request returning *GetV2SyncIntegrationResponse
func (c *ClientWithResponses) GetV2SyncIntegrationWithResponse(ctx context.Context, syncName SyncName, reqEditors ...RequestEditorFn) (*GetV2SyncIntegrationResponse, error) {
	rsp, err := c.GetV2SyncIntegration(ctx, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SyncIntegrationResponse(rsp)
}

// UpdateV2SyncIntegrationWithBodyWithResponse request with arbitrary body returning *UpdateV2SyncIntegrationResponse
func (c *ClientWithResponses) UpdateV2SyncIntegrationWithBodyWithResponse(ctx context.Context, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateV2SyncIntegrationResponse, error) {
	rsp, err := c.UpdateV2SyncIntegrationWithBody(ctx, syncName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateV2SyncIntegrationResponse(rsp)
}

func (c *ClientWithResponses) UpdateV2SyncIntegrationWithResponse(ctx context.Context, syncName SyncName, body UpdateV2SyncIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateV2SyncIntegrationResponse, error) {
	rsp, err := c.UpdateV2SyncIntegration(ctx, syncName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateV2SyncIntegrationResponse(rsp)
}

// ParseIndexResponse parses an HTTP response from a IndexWithResponse call
func ParseIndexResponse(rsp *http.Response) (*IndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors      *[]string          `json:"errors,omitempty"`
			FieldErrors *map[string]string `json:"field_errors,omitempty"`
			Message     string             `json:"message"`
			Status      int                `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAllAlertsResponse parses an HTTP response from a ListAllAlertsWithResponse call
func ParseListAllAlertsResponse(rsp *http.Response) (*ListAllAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []AlertDetail `json:"items"`
			Metadata ListMetadata  `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestUnsavedAlertResponse parses an HTTP response from a TestUnsavedAlertWithResponse call
func ParseTestUnsavedAlertResponse(rsp *http.Response) (*TestUnsavedAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestUnsavedAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Results Notification results for the test alert
			Results []AlertTestResponse `json:"results"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAPIKeysResponse parses an HTTP response from a ListAPIKeysWithResponse call
func ParseListAPIKeysResponse(rsp *http.Response) (*ListAPIKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAPIKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AllowedRoles List of allowed roles when creating a new API key
			AllowedRoles []Role       `json:"allowed_roles"`
			Items        []APIKey     `json:"items"`
			Metadata     ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAPIKeyResponse parses an HTTP response from a CreateAPIKeyWithResponse call
func ParseCreateAPIKeyResponse(rsp *http.Response) (*CreateAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest APIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAPIKeyResponse parses an HTTP response from a DeleteAPIKeyWithResponse call
func ParseDeleteAPIKeyResponse(rsp *http.Response) (*DeleteAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []AuditLogEvent `json:"items"`
			Metadata ListMetadata    `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuditLogResponse parses an HTTP response from a GetAuditLogWithResponse call
func ParseGetAuditLogResponse(rsp *http.Response) (*GetAuditLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditLogEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSAMLResponse parses an HTTP response from a GetSAMLWithResponse call
func ParseGetSAMLResponse(rsp *http.Response) (*GetSAMLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSAMLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSAMLResponse parses an HTTP response from a UpdateSAMLWithResponse call
func ParseUpdateSAMLResponse(rsp *http.Response) (*UpdateSAMLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSAMLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateConversationResponse parses an HTTP response from a CreateConversationWithResponse call
func ParseCreateConversationResponse(rsp *http.Response) (*CreateConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Conversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConversationResponse parses an HTTP response from a GetConversationWithResponse call
func ParseGetConversationResponse(rsp *http.Response) (*GetConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Conversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendMessageResponse parses an HTTP response from a SendMessageWithResponse call
func ParseSendMessageResponse(rsp *http.Response) (*SendMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllCustomColumnsResponse parses an HTTP response from a ListAllCustomColumnsWithResponse call
func ParseListAllCustomColumnsResponse(rsp *http.Response) (*ListAllCustomColumnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllCustomColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []CustomColumn `json:"items"`
			Metadata ListMetadata   `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSaveCustomColumnResponse parses an HTTP response from a SaveCustomColumnWithResponse call
func ParseSaveCustomColumnResponse(rsp *http.Response) (*SaveCustomColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveCustomColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomColumnResponse parses an HTTP response from a DeleteCustomColumnWithResponse call
func ParseDeleteCustomColumnResponse(rsp *http.Response) (*DeleteCustomColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomColumnResponse parses an HTTP response from a GetCustomColumnWithResponse call
func ParseGetCustomColumnResponse(rsp *http.Response) (*GetCustomColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCustomColumnResponse parses an HTTP response from a UpdateCustomColumnWithResponse call
func ParseUpdateCustomColumnResponse(rsp *http.Response) (*UpdateCustomColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFiltersResponse parses an HTTP response from a ListFiltersWithResponse call
func ParseListFiltersResponse(rsp *http.Response) (*ListFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Filter     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFilterTagsResponse parses an HTTP response from a ListFilterTagsWithResponse call
func ParseListFilterTagsResponse(rsp *http.Response) (*ListFilterTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFilterTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []FilterTag  `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFilterResponse parses an HTTP response from a DeleteFilterWithResponse call
func ParseDeleteFilterResponse(rsp *http.Response) (*DeleteFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFilterByIDResponse parses an HTTP response from a GetFilterByIDWithResponse call
func ParseGetFilterByIDResponse(rsp *http.Response) (*GetFilterByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFilterResponse parses an HTTP response from a UpdateFilterWithResponse call
func ParseUpdateFilterResponse(rsp *http.Response) (*UpdateFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseHealthCheckHeadResponse parses an HTTP response from a HealthCheckHeadWithResponse call
func ParseHealthCheckHeadResponse(rsp *http.Response) (*HealthCheckHeadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckHeadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListNotificationsResponse parses an HTTP response from a ListNotificationsWithResponse call
func ParseListNotificationsResponse(rsp *http.Response) (*ListNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []NotificationDetail `json:"items"`
			Metadata ListMetadata         `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationDestinationResponse parses an HTTP response from a DeleteNotificationDestinationWithResponse call
func ParseDeleteNotificationDestinationResponse(rsp *http.Response) (*DeleteNotificationDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationDestinationResponse parses an HTTP response from a GetNotificationDestinationWithResponse call
func ParseGetNotificationDestinationResponse(rsp *http.Response) (*GetNotificationDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNotificationDestinationResponse parses an HTTP response from a UpdateNotificationDestinationWithResponse call
func ParseUpdateNotificationDestinationResponse(rsp *http.Response) (*UpdateNotificationDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationDestinationAlertsResponse parses an HTTP response from a GetNotificationDestinationAlertsWithResponse call
func ParseGetNotificationDestinationAlertsResponse(rsp *http.Response) (*GetNotificationDestinationAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationDestinationAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []AlertDetail `json:"items"`
			Metadata ListMetadata  `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestNotificationDestinationResponse parses an HTTP response from a TestNotificationDestinationWithResponse call
func ParseTestNotificationDestinationResponse(rsp *http.Response) (*TestNotificationDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestNotificationDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationDestinationTestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllNotificationDestinationsResponse parses an HTTP response from a ListAllNotificationDestinationsWithResponse call
func ParseListAllNotificationDestinationsResponse(rsp *http.Response) (*ListAllNotificationDestinationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllNotificationDestinationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []NotificationDestinationListItem `json:"items"`
			Metadata ListMetadata                      `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateNotificationDestinationResponse parses an HTTP response from a CreateNotificationDestinationWithResponse call
func ParseCreateNotificationDestinationResponse(rsp *http.Response) (*CreateNotificationDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestUnsavedNotificationDestinationResponse parses an HTTP response from a TestUnsavedNotificationDestinationWithResponse call
func ParseTestUnsavedNotificationDestinationResponse(rsp *http.Response) (*TestUnsavedNotificationDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestUnsavedNotificationDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationDestinationTestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAWSOnboardingResponse parses an HTTP response from a CreateAWSOnboardingWithResponse call
func ParseCreateAWSOnboardingResponse(rsp *http.Response) (*CreateAWSOnboardingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAWSOnboardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OnboardingAWSCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAWSOnboardingResponse parses an HTTP response from a GetAWSOnboardingWithResponse call
func ParseGetAWSOnboardingResponse(rsp *http.Response) (*GetAWSOnboardingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSOnboardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnboardingAWS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAWSAccountsInRootResponse parses an HTTP response from a GetAWSAccountsInRootWithResponse call
func ParseGetAWSAccountsInRootResponse(rsp *http.Response) (*GetAWSAccountsInRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSAccountsInRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnboardingAWSAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProvisionOnboardingConfigurationResponse parses an HTTP response from a ProvisionOnboardingConfigurationWithResponse call
func ParseProvisionOnboardingConfigurationResponse(rsp *http.Response) (*ProvisionOnboardingConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisionOnboardingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAWSAccountsInParentResponse parses an HTTP response from a GetAWSAccountsInParentWithResponse call
func ParseGetAWSAccountsInParentResponse(rsp *http.Response) (*GetAWSAccountsInParentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSAccountsInParentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnboardingAWSAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseNotifyOnboardingResponse parses an HTTP response from a NotifyOnboardingWithResponse call
func ParseNotifyOnboardingResponse(rsp *http.Response) (*NotifyOnboardingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifyOnboardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOpenAPIJSONResponse parses an HTTP response from a GetOpenAPIJSONWithResponse call
func ParseGetOpenAPIJSONResponse(rsp *http.Response) (*GetOpenAPIJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenAPIJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPlatformInfoResponse parses an HTTP response from a GetPlatformInfoWithResponse call
func ParseGetPlatformInfoResponse(rsp *http.Response) (*GetPlatformInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// PublicIPs List of public IPs for the platform
			PublicIPs *[]string `json:"public_ips,omitempty"`

			// Version Version of the platform
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPlatformVersionsResponse parses an HTTP response from a ListPlatformVersionsWithResponse call
func ParseListPlatformVersionsResponse(rsp *http.Response) (*ListPlatformVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlatformVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PlatformVersion `json:"items"`
			Metadata ListMetadata      `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginsResponse parses an HTTP response from a ListPluginsWithResponse call
func ParseListPluginsResponse(rsp *http.Response) (*ListPluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    ListPlugins  `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginResponse parses an HTTP response from a GetPluginWithResponse call
func ParseGetPluginResponse(rsp *http.Response) (*GetPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionsResponse parses an HTTP response from a ListPluginVersionsWithResponse call
func ParseListPluginVersionsResponse(rsp *http.Response) (*ListPluginVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PluginVersionList `json:"items"`
			Metadata ListMetadata        `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginVersionResponse parses an HTTP response from a GetPluginVersionWithResponse call
func ParseGetPluginVersionResponse(rsp *http.Response) (*GetPluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersionDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadPluginAssetResponse parses an HTTP response from a DownloadPluginAssetWithResponse call
func ParseDownloadPluginAssetResponse(rsp *http.Response) (*DownloadPluginAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPluginAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionTablesResponse parses an HTTP response from a ListPluginVersionTablesWithResponse call
func ParseListPluginVersionTablesResponse(rsp *http.Response) (*ListPluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PluginTable `json:"items"`
			Metadata ListMetadata  `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginVersionTableResponse parses an HTTP response from a GetPluginVersionTableWithResponse call
func ParseGetPluginVersionTableResponse(rsp *http.Response) (*GetPluginVersionTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginVersionTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginTableDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Policy     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPolicyMetricsResponse parses an HTTP response from a GetPolicyMetricsWithResponse call
func ParseGetPolicyMetricsResponse(rsp *http.Response) (*GetPolicyMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetViolationsByDomainResponse parses an HTTP response from a GetViolationsByDomainWithResponse call
func ParseGetViolationsByDomainResponse(rsp *http.Response) (*GetViolationsByDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetViolationsByDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ViolationsByDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetViolationsHistoryResponse parses an HTTP response from a GetViolationsHistoryWithResponse call
func ParseGetViolationsHistoryResponse(rsp *http.Response) (*GetViolationsHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetViolationsHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ViolationsHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTogglePolicyResponse parses an HTTP response from a TogglePolicyWithResponse call
func ParseTogglePolicyResponse(rsp *http.Response) (*TogglePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TogglePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPolicyViolationsResponse parses an HTTP response from a GetPolicyViolationsWithResponse call
func ParseGetPolicyViolationsResponse(rsp *http.Response) (*GetPolicyViolationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyViolationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PolicyViolation `json:"items"`
			Metadata *ListMetadata     `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPolicyViolationsHistoryResponse parses an HTTP response from a GetPolicyViolationsHistoryWithResponse call
func ParseGetPolicyViolationsHistoryResponse(rsp *http.Response) (*GetPolicyViolationsHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyViolationsHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PolicyEvaluationLog `json:"items"`
			Metadata ListMetadata          `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPolicyGroupsResponse parses an HTTP response from a ListPolicyGroupsWithResponse call
func ParseListPolicyGroupsResponse(rsp *http.Response) (*ListPolicyGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPolicyGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []PolicyGroupWithCounts `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePolicyGroupResponse parses an HTTP response from a CreatePolicyGroupWithResponse call
func ParseCreatePolicyGroupResponse(rsp *http.Response) (*CreatePolicyGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PolicyGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePolicyGroupResponse parses an HTTP response from a DeletePolicyGroupWithResponse call
func ParseDeletePolicyGroupResponse(rsp *http.Response) (*DeletePolicyGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPoliciesInGroupResponse parses an HTTP response from a ListPoliciesInGroupWithResponse call
func ParseListPoliciesInGroupResponse(rsp *http.Response) (*ListPoliciesInGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesInGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Policy     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyGroupResponse parses an HTTP response from a UpdatePolicyGroupWithResponse call
func ParseUpdatePolicyGroupResponse(rsp *http.Response) (*UpdatePolicyGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllQueriesResponse parses an HTTP response from a ListAllQueriesWithResponse call
func ParseListAllQueriesResponse(rsp *http.Response) (*ListAllQueriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllQueriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Query      `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExecuteAdHocQueryResponse parses an HTTP response from a ExecuteAdHocQueryWithResponse call
func ParseExecuteAdHocQueryResponse(rsp *http.Response) (*ExecuteAdHocQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteAdHocQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     TableData    `json:"data"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSaveQueryResponse parses an HTTP response from a SaveQueryWithResponse call
func ParseSaveQueryResponse(rsp *http.Response) (*SaveQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest QueryDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListQueryTagsResponse parses an HTTP response from a ListQueryTagsWithResponse call
func ParseListQueryTagsResponse(rsp *http.Response) (*ListQueryTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQueryTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []QueryTag   `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryResponse parses an HTTP response from a DeleteSavedQueryWithResponse call
func ParseDeleteSavedQueryResponse(rsp *http.Response) (*DeleteSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSavedQueryResponse parses an HTTP response from a GetSavedQueryWithResponse call
func ParseGetSavedQueryResponse(rsp *http.Response) (*GetSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateQueryResponse parses an HTTP response from a UpdateQueryWithResponse call
func ParseUpdateQueryResponse(rsp *http.Response) (*UpdateQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAlertResponse parses an HTTP response from a DeleteAlertWithResponse call
func ParseDeleteAlertResponse(rsp *http.Response) (*DeleteAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExecuteSavedQueryResponse parses an HTTP response from a ExecuteSavedQueryWithResponse call
func ParseExecuteSavedQueryResponse(rsp *http.Response) (*ExecuteSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     TableData    `json:"data"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQueryListFiltersResponse parses an HTTP response from a QueryListFiltersWithResponse call
func ParseQueryListFiltersResponse(rsp *http.Response) (*QueryListFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryListFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Filter     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQuerySaveFilterResponse parses an HTTP response from a QuerySaveFilterWithResponse call
func ParseQuerySaveFilterResponse(rsp *http.Response) (*QuerySaveFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QuerySaveFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQueryListFilterTagsResponse parses an HTTP response from a QueryListFilterTagsWithResponse call
func ParseQueryListFilterTagsResponse(rsp *http.Response) (*QueryListFilterTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryListFilterTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []FilterTag  `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllRBACPermissionsResponse parses an HTTP response from a ListAllRBACPermissionsWithResponse call
func ParseListAllRBACPermissionsResponse(rsp *http.Response) (*ListAllRBACPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllRBACPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []RBACPermission `json:"items"`
			Metadata ListMetadata     `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateRBACPermissionResponse parses an HTTP response from a CreateRBACPermissionWithResponse call
func ParseCreateRBACPermissionResponse(rsp *http.Response) (*CreateRBACPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRBACPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RBACPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRBACPermissionResponse parses an HTTP response from a DeleteRBACPermissionWithResponse call
func ParseDeleteRBACPermissionResponse(rsp *http.Response) (*DeleteRBACPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRBACPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRBACPermissionResponse parses an HTTP response from a GetRBACPermissionWithResponse call
func ParseGetRBACPermissionResponse(rsp *http.Response) (*GetRBACPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRBACPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RBACPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRBACPermissionResponse parses an HTTP response from a UpdateRBACPermissionWithResponse call
func ParseUpdateRBACPermissionResponse(rsp *http.Response) (*UpdateRBACPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRBACPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RBACPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllRBACRolesResponse parses an HTTP response from a ListAllRBACRolesWithResponse call
func ParseListAllRBACRolesResponse(rsp *http.Response) (*ListAllRBACRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllRBACRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Role       `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateRBACRoleResponse parses an HTTP response from a CreateRBACRoleWithResponse call
func ParseCreateRBACRoleResponse(rsp *http.Response) (*CreateRBACRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRBACRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRBACRoleResponse parses an HTTP response from a DeleteRBACRoleWithResponse call
func ParseDeleteRBACRoleResponse(rsp *http.Response) (*DeleteRBACRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRBACRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRBACRoleResponse parses an HTTP response from a GetRBACRoleWithResponse call
func ParseGetRBACRoleResponse(rsp *http.Response) (*GetRBACRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRBACRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRBACRoleResponse parses an HTTP response from a UpdateRBACRoleWithResponse call
func ParseUpdateRBACRoleResponse(rsp *http.Response) (*UpdateRBACRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRBACRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListReportsResponse parses an HTTP response from a ListReportsWithResponse call
func ParseListReportsResponse(rsp *http.Response) (*ListReportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata ListMetadata `json:"metadata"`
			Reports  []Report     `json:"reports"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateReportResponse parses an HTTP response from a CreateReportWithResponse call
func ParseCreateReportResponse(rsp *http.Response) (*CreateReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data Report `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListReportTemplatesResponse parses an HTTP response from a ListReportTemplatesWithResponse call
func ParseListReportTemplatesResponse(rsp *http.Response) (*ListReportTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata  ListMetadata     `json:"metadata"`
			Templates []ReportTemplate `json:"templates"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateReportTemplateResponse parses an HTTP response from a CreateReportTemplateWithResponse call
func ParseCreateReportTemplateResponse(rsp *http.Response) (*CreateReportTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReportTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data ReportTemplate `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteReportTemplateResponse parses an HTTP response from a DeleteReportTemplateWithResponse call
func ParseDeleteReportTemplateResponse(rsp *http.Response) (*DeleteReportTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReportTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReportTemplateResponse parses an HTTP response from a GetReportTemplateWithResponse call
func ParseGetReportTemplateResponse(rsp *http.Response) (*GetReportTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data ReportTemplate `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateReportTemplateResponse parses an HTTP response from a UpdateReportTemplateWithResponse call
func ParseUpdateReportTemplateResponse(rsp *http.Response) (*UpdateReportTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateReportTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data ReportTemplate `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteReportResponse parses an HTTP response from a DeleteReportWithResponse call
func ParseDeleteReportResponse(rsp *http.Response) (*DeleteReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReportResponse parses an HTTP response from a GetReportWithResponse call
func ParseGetReportResponse(rsp *http.Response) (*GetReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Report `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateReportResponse parses an HTTP response from a UpdateReportWithResponse call
func ParseUpdateReportResponse(rsp *http.Response) (*UpdateReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Report `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSettingsResponse parses an HTTP response from a UpdateSettingsWithResponse call
func ParseUpdateSettingsResponse(rsp *http.Response) (*UpdateSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDataSettingsResponse parses an HTTP response from a GetDataSettingsWithResponse call
func ParseGetDataSettingsResponse(rsp *http.Response) (*GetDataSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformDataSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDataSettingsResponse parses an HTTP response from a UpdateDataSettingsWithResponse call
func ParseUpdateDataSettingsResponse(rsp *http.Response) (*UpdateDataSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformDataSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSlackConnectionResponse parses an HTTP response from a CreateSlackConnectionWithResponse call
func ParseCreateSlackConnectionResponse(rsp *http.Response) (*CreateSlackConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSlackConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SlackConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSlackChannelsResponse parses an HTTP response from a ListSlackChannelsWithResponse call
func ParseListSlackChannelsResponse(rsp *http.Response) (*ListSlackChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSlackChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []SlackChannel `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncDestinationTestConnectionResponse parses an HTTP response from a CreateSyncDestinationTestConnectionWithResponse call
func ParseCreateSyncDestinationTestConnectionResponse(rsp *http.Response) (*CreateSyncDestinationTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncDestinationTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncDestinationTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncDestinationTestConnectionResponse parses an HTTP response from a GetSyncDestinationTestConnectionWithResponse call
func ParseGetSyncDestinationTestConnectionResponse(rsp *http.Response) (*GetSyncDestinationTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncDestinationTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestinationTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncTestConnectionForSyncDestinationResponse parses an HTTP response from a UpdateSyncTestConnectionForSyncDestinationWithResponse call
func ParseUpdateSyncTestConnectionForSyncDestinationResponse(rsp *http.Response) (*UpdateSyncTestConnectionForSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncTestConnectionForSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestinationTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncDestinationTestConnectionLogsLiveResponse parses an HTTP response from a GetSyncDestinationTestConnectionLogsLiveWithResponse call
func ParseGetSyncDestinationTestConnectionLogsLiveResponse(rsp *http.Response) (*GetSyncDestinationTestConnectionLogsLiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncDestinationTestConnectionLogsLiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncDestinationTestConnectionLogsQueryResponse parses an HTTP response from a GetSyncDestinationTestConnectionLogsQueryWithResponse call
func ParseGetSyncDestinationTestConnectionLogsQueryResponse(rsp *http.Response) (*GetSyncDestinationTestConnectionLogsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncDestinationTestConnectionLogsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     TableData    `json:"data"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParsePromoteSyncDestinationTestConnectionResponse parses an HTTP response from a PromoteSyncDestinationTestConnectionWithResponse call
func ParsePromoteSyncDestinationTestConnectionResponse(rsp *http.Response) (*PromoteSyncDestinationTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromoteSyncDestinationTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncDestinationsResponse parses an HTTP response from a ListSyncDestinationsWithResponse call
func ParseListSyncDestinationsResponse(rsp *http.Response) (*ListSyncDestinationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncDestinationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncDestination `json:"items"`
			Metadata ListMetadata      `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncDestinationResponse parses an HTTP response from a DeleteSyncDestinationWithResponse call
func ParseDeleteSyncDestinationResponse(rsp *http.Response) (*DeleteSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncDestinationResponse parses an HTTP response from a GetSyncDestinationWithResponse call
func ParseGetSyncDestinationResponse(rsp *http.Response) (*GetSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncDestinationResponse parses an HTTP response from a UpdateSyncDestinationWithResponse call
func ParseUpdateSyncDestinationResponse(rsp *http.Response) (*UpdateSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncDestinationSyncsResponse parses an HTTP response from a ListSyncDestinationSyncsWithResponse call
func ParseListSyncDestinationSyncsResponse(rsp *http.Response) (*ListSyncDestinationSyncsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncDestinationSyncsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []ListSync   `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTestConnectionForSyncDestinationResponse parses an HTTP response from a GetTestConnectionForSyncDestinationWithResponse call
func ParseGetTestConnectionForSyncDestinationResponse(rsp *http.Response) (*GetTestConnectionForSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestConnectionForSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncSourceTestConnectionResponse parses an HTTP response from a CreateSyncSourceTestConnectionWithResponse call
func ParseCreateSyncSourceTestConnectionResponse(rsp *http.Response) (*CreateSyncSourceTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncSourceTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncSourceTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncSourceTestConnectionResponse parses an HTTP response from a GetSyncSourceTestConnectionWithResponse call
func ParseGetSyncSourceTestConnectionResponse(rsp *http.Response) (*GetSyncSourceTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncSourceTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSourceTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncTestConnectionForSyncSourceResponse parses an HTTP response from a UpdateSyncTestConnectionForSyncSourceWithResponse call
func ParseUpdateSyncTestConnectionForSyncSourceResponse(rsp *http.Response) (*UpdateSyncTestConnectionForSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncTestConnectionForSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSourceTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncSourceTestConnectionLogsLiveResponse parses an HTTP response from a GetSyncSourceTestConnectionLogsLiveWithResponse call
func ParseGetSyncSourceTestConnectionLogsLiveResponse(rsp *http.Response) (*GetSyncSourceTestConnectionLogsLiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncSourceTestConnectionLogsLiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncSourceTestConnectionLogsQueryResponse parses an HTTP response from a GetSyncSourceTestConnectionLogsQueryWithResponse call
func ParseGetSyncSourceTestConnectionLogsQueryResponse(rsp *http.Response) (*GetSyncSourceTestConnectionLogsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncSourceTestConnectionLogsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     TableData    `json:"data"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParsePromoteSyncSourceTestConnectionResponse parses an HTTP response from a PromoteSyncSourceTestConnectionWithResponse call
func ParsePromoteSyncSourceTestConnectionResponse(rsp *http.Response) (*PromoteSyncSourceTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromoteSyncSourceTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncSourcesResponse parses an HTTP response from a ListSyncSourcesWithResponse call
func ParseListSyncSourcesResponse(rsp *http.Response) (*ListSyncSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncSource `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncSourceResponse parses an HTTP response from a DeleteSyncSourceWithResponse call
func ParseDeleteSyncSourceResponse(rsp *http.Response) (*DeleteSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncSourceResponse parses an HTTP response from a GetSyncSourceWithResponse call
func ParseGetSyncSourceResponse(rsp *http.Response) (*GetSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncSourceResponse parses an HTTP response from a UpdateSyncSourceWithResponse call
func ParseUpdateSyncSourceResponse(rsp *http.Response) (*UpdateSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncSourceSyncsResponse parses an HTTP response from a ListSyncSourceSyncsWithResponse call
func ParseListSyncSourceSyncsResponse(rsp *http.Response) (*ListSyncSourceSyncsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncSourceSyncsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []ListSync   `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTestConnectionForSyncSourceResponse parses an HTTP response from a GetTestConnectionForSyncSourceWithResponse call
func ParseGetTestConnectionForSyncSourceResponse(rsp *http.Response) (*GetTestConnectionForSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestConnectionForSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncTransformersResponse parses an HTTP response from a ListSyncTransformersWithResponse call
func ParseListSyncTransformersResponse(rsp *http.Response) (*ListSyncTransformersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncTransformersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncTransformer `json:"items"`
			Metadata ListMetadata      `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncTransformerResponse parses an HTTP response from a DeleteSyncTransformerWithResponse call
func ParseDeleteSyncTransformerResponse(rsp *http.Response) (*DeleteSyncTransformerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncTransformerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncTransformerResponse parses an HTTP response from a GetSyncTransformerWithResponse call
func ParseGetSyncTransformerResponse(rsp *http.Response) (*GetSyncTransformerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncTransformerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTransformer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncTransformerResponse parses an HTTP response from a UpdateSyncTransformerWithResponse call
func ParseUpdateSyncTransformerResponse(rsp *http.Response) (*UpdateSyncTransformerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncTransformerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTransformer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncTransformerSyncDestinationsResponse parses an HTTP response from a ListSyncTransformerSyncDestinationsWithResponse call
func ParseListSyncTransformerSyncDestinationsResponse(rsp *http.Response) (*ListSyncTransformerSyncDestinationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncTransformerSyncDestinationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncDestination `json:"items"`
			Metadata ListMetadata      `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncTransformerSyncsResponse parses an HTTP response from a ListSyncTransformerSyncsWithResponse call
func ParseListSyncTransformerSyncsResponse(rsp *http.Response) (*ListSyncTransformerSyncsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncTransformerSyncsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Sync       `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncUpgradesResponse parses an HTTP response from a ListSyncUpgradesWithResponse call
func ParseListSyncUpgradesResponse(rsp *http.Response) (*ListSyncUpgradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncUpgradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncUpgrade `json:"items"`
			Metadata ListMetadata  `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncsResponse parses an HTTP response from a ListSyncsWithResponse call
func ParseListSyncsResponse(rsp *http.Response) (*ListSyncsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []ListSync   `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncResponse parses an HTTP response from a CreateSyncWithResponse call
func ParseCreateSyncResponse(rsp *http.Response) (*CreateSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sync
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncResponse parses an HTTP response from a DeleteSyncWithResponse call
func ParseDeleteSyncResponse(rsp *http.Response) (*DeleteSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncResponse parses an HTTP response from a GetSyncWithResponse call
func ParseGetSyncResponse(rsp *http.Response) (*GetSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sync
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncResponse parses an HTTP response from a UpdateSyncWithResponse call
func ParseUpdateSyncResponse(rsp *http.Response) (*UpdateSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sync
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncRunsResponse parses an HTTP response from a ListSyncRunsWithResponse call
func ParseListSyncRunsResponse(rsp *http.Response) (*ListSyncRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncRun    `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncRunResponse parses an HTTP response from a CreateSyncRunWithResponse call
func ParseCreateSyncRunResponse(rsp *http.Response) (*CreateSyncRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunResponse parses an HTTP response from a GetSyncRunWithResponse call
func ParseGetSyncRunResponse(rsp *http.Response) (*GetSyncRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncRunDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncRunResponse parses an HTTP response from a UpdateSyncRunWithResponse call
func ParseUpdateSyncRunResponse(rsp *http.Response) (*UpdateSyncRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunLogsLiveResponse parses an HTTP response from a GetSyncRunLogsLiveWithResponse call
func ParseGetSyncRunLogsLiveResponse(rsp *http.Response) (*GetSyncRunLogsLiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunLogsLiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunLogsQueryResponse parses an HTTP response from a GetSyncRunLogsQueryWithResponse call
func ParseGetSyncRunLogsQueryResponse(rsp *http.Response) (*GetSyncRunLogsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunLogsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     TableData    `json:"data"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseCreateSyncRunProgressResponse parses an HTTP response from a CreateSyncRunProgressWithResponse call
func ParseCreateSyncRunProgressResponse(rsp *http.Response) (*CreateSyncRunProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncRunProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunStatsResponse parses an HTTP response from a GetSyncRunStatsWithResponse call
func ParseGetSyncRunStatsResponse(rsp *http.Response) (*GetSyncRunStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncRunStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunTablesResponse parses an HTTP response from a GetSyncRunTablesWithResponse call
func ParseGetSyncRunTablesResponse(rsp *http.Response) (*GetSyncRunTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncRunTableStat `json:"items"`
			Metadata ListMetadata       `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []TableListItem `json:"items"`
			Metadata ListMetadata    `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTablesDataResponse parses an HTTP response from a GetTablesDataWithResponse call
func ParseGetTablesDataResponse(rsp *http.Response) (*GetTablesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata ListMetadata        `json:"metadata"`
			Syncs    []TableDataListItem `json:"syncs"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTablesDataActionResponse parses an HTTP response from a TablesDataActionWithResponse call
func ParseTablesDataActionResponse(rsp *http.Response) (*TablesDataActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TablesDataActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBatchTableSchemasResponse parses an HTTP response from a BatchTableSchemasWithResponse call
func ParseBatchTableSchemasResponse(rsp *http.Response) (*BatchTableSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BatchTableSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []BatchTableSchemaItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableListColumnsResponse parses an HTTP response from a TableListColumnsWithResponse call
func ParseTableListColumnsResponse(rsp *http.Response) (*TableListColumnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableListColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []TableColumnListItem `json:"items"`
			Metadata ListMetadata          `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableColumnListValuesResponse parses an HTTP response from a TableColumnListValuesWithResponse call
func ParseTableColumnListValuesResponse(rsp *http.Response) (*TableColumnListValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableColumnListValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []TableColumnValueListItem `json:"items"`
			Metadata ListMetadata               `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableListRowsResponse parses an HTTP response from a TableListRowsWithResponse call
func ParseTableListRowsResponse(rsp *http.Response) (*TableListRowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableListRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     TableData    `json:"data"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableRowByIdResponse parses an HTTP response from a TableRowByIdWithResponse call
func ParseTableRowByIdResponse(rsp *http.Response) (*TableRowByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableRowByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data    TableRow             `json:"data"`
			Matches []TableRowFieldMatch `json:"matches"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableListFiltersResponse parses an HTTP response from a TableListFiltersWithResponse call
func ParseTableListFiltersResponse(rsp *http.Response) (*TableListFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableListFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Filter     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableSaveFilterResponse parses an HTTP response from a TableSaveFilterWithResponse call
func ParseTableSaveFilterResponse(rsp *http.Response) (*TableSaveFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableSaveFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableListFilterTagsResponse parses an HTTP response from a TableListFilterTagsWithResponse call
func ParseTableListFilterTagsResponse(rsp *http.Response) (*TableListFilterTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableListFilterTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []FilterTag  `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTableSchemaResponse parses an HTTP response from a TableSchemaWithResponse call
func ParseTableSchemaResponse(rsp *http.Response) (*TableSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DefaultColumns []string    `json:"default_columns"`
			Schema         TableSchema `json:"schema"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Team       `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadPluginAssetByTeamResponse parses an HTTP response from a DownloadPluginAssetByTeamWithResponse call
func ParseDownloadPluginAssetByTeamResponse(rsp *http.Response) (*DownloadPluginAssetByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPluginAssetByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncTestConnectionForSyncDestinationTeamResponse parses an HTTP response from a UpdateSyncTestConnectionForSyncDestinationTeamWithResponse call
func ParseUpdateSyncTestConnectionForSyncDestinationTeamResponse(rsp *http.Response) (*UpdateSyncTestConnectionForSyncDestinationTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncTestConnectionForSyncDestinationTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestinationTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncTestConnectionForSyncSourceTeamResponse parses an HTTP response from a UpdateSyncTestConnectionForSyncSourceTeamWithResponse call
func ParseUpdateSyncTestConnectionForSyncSourceTeamResponse(rsp *http.Response) (*UpdateSyncTestConnectionForSyncSourceTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncTestConnectionForSyncSourceTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSourceTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncRunProgressTeamResponse parses an HTTP response from a CreateSyncRunProgressTeamWithResponse call
func ParseCreateSyncRunProgressTeamResponse(rsp *http.Response) (*CreateSyncRunProgressTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncRunProgressTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamUsageSummaryResponse parses an HTTP response from a GetTeamUsageSummaryWithResponse call
func ParseGetTeamUsageSummaryResponse(rsp *http.Response) (*GetTeamUsageSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamUsageSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupedTeamUsageSummaryResponse parses an HTTP response from a GetGroupedTeamUsageSummaryWithResponse call
func ParseGetGroupedTeamUsageSummaryResponse(rsp *http.Response) (*GetGroupedTeamUsageSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupedTeamUsageSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedAt *time.Time `json:"created_at,omitempty"`
			Email     string     `json:"email"`

			// Enabled Whether the user is enabled
			Enabled          bool                    `json:"enabled"`
			EventIdentifiers *map[string]interface{} `json:"event_identifiers,omitempty"`
			GroupIdentifier  *string                 `json:"group_identifier,omitempty"`

			// ID ID of the User
			ID          openapi_types.UUID `json:"id"`
			LastLoginAt *time.Time         `json:"last_login_at,omitempty"`

			// MFAConfigured Whether the user has MFA configured
			MFAConfigured bool `json:"mfa_configured"`

			// Name The unique name for the user.
			Name *UserName `json:"name,omitempty"`

			// ProfileImageURL Profile image URL of user
			ProfileImageURL *string      `json:"profile_image_url,omitempty"`
			Provider        UserProvider `json:"provider"`

			// RegisteredTeamInternal Whether the team is internal or not
			RegisteredTeamInternal *bool `json:"registered_team_internal,omitempty"`

			// RegisteredTeamName The name of the team that the platform is registered with
			RegisteredTeamName *string `json:"registered_team_name,omitempty"`
			Roles              []Role  `json:"roles"`

			// TrackingOptedIn Whether anonymous user tracking was opted into
			TrackingOptedIn *bool      `json:"tracking_opted_in,omitempty"`
			UpdatedAt       *time.Time `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message string `json:"message"`

			// PasswordResetRequired Whether the user needs to reset their password
			PasswordResetRequired *bool `json:"password_reset_required,omitempty"`
			Status                int   `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCurrentUserResponse parses an HTTP response from a UpdateCurrentUserWithResponse call
func ParseUpdateCurrentUserResponse(rsp *http.Response) (*UpdateCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendAnonymousEventResponse parses an HTTP response from a SendAnonymousEventWithResponse call
func ParseSendAnonymousEventResponse(rsp *http.Response) (*SendAnonymousEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendAnonymousEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthenticateUserResponse parses an HTTP response from a AuthenticateUserWithResponse call
func ParseAuthenticateUserResponse(rsp *http.Response) (*AuthenticateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IDToken string `json:"id_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChangeUserPasswordResponse parses an HTTP response from a ChangeUserPasswordWithResponse call
func ParseChangeUserPasswordResponse(rsp *http.Response) (*ChangeUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCustomerResponse parses an HTTP response from a UpdateCustomerWithResponse call
func ParseUpdateCustomerResponse(rsp *http.Response) (*UpdateCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendUserEventResponse parses an HTTP response from a SendUserEventWithResponse call
func ParseSendUserEventResponse(rsp *http.Response) (*SendUserEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendUserEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogoutUserResponse parses an HTTP response from a LogoutUserWithResponse call
func ParseLogoutUserResponse(rsp *http.Response) (*LogoutUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLoginUserResponse parses an HTTP response from a LoginUserWithResponse call
func ParseLoginUserResponse(rsp *http.Response) (*LoginUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserTOTPDeleteResponse parses an HTTP response from a UserTOTPDeleteWithResponse call
func ParseUserTOTPDeleteResponse(rsp *http.Response) (*UserTOTPDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserTOTPDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserTOTPSetupResponse parses an HTTP response from a UserTOTPSetupWithResponse call
func ParseUserTOTPSetupResponse(rsp *http.Response) (*UserTOTPSetupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserTOTPSetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secret string `json:"secret"`
			Url    string `json:"url"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserTOTPVerifyResponse parses an HTTP response from a UserTOTPVerifyWithResponse call
func ParseUserTOTPVerifyResponse(rsp *http.Response) (*UserTOTPVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserTOTPVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []User       `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUserResponse parses an HTTP response from a AddUserWithResponse call
func ParseAddUserResponse(rsp *http.Response) (*AddUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserTOTPResponse parses an HTTP response from a DeleteUserTOTPWithResponse call
func ParseDeleteUserTOTPResponse(rsp *http.Response) (*DeleteUserTOTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserTOTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateV2SyncDestinationTestConnectionResponse parses an HTTP response from a CreateV2SyncDestinationTestConnectionWithResponse call
func ParseCreateV2SyncDestinationTestConnectionResponse(rsp *http.Response) (*CreateV2SyncDestinationTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateV2SyncDestinationTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncDestinationTestConnectionV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2SyncDestinationsResponse parses an HTTP response from a GetV2SyncDestinationsWithResponse call
func ParseGetV2SyncDestinationsResponse(rsp *http.Response) (*GetV2SyncDestinationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SyncDestinationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncDestinationV2 `json:"items"`
			Metadata ListMetadata        `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateV2SyncDestinationResponse parses an HTTP response from a CreateV2SyncDestinationWithResponse call
func ParseCreateV2SyncDestinationResponse(rsp *http.Response) (*CreateV2SyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateV2SyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestinationV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncDestinationV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteV2SyncDestinationResponse parses an HTTP response from a DeleteV2SyncDestinationWithResponse call
func ParseDeleteV2SyncDestinationResponse(rsp *http.Response) (*DeleteV2SyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2SyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2SyncDestinationResponse parses an HTTP response from a GetV2SyncDestinationWithResponse call
func ParseGetV2SyncDestinationResponse(rsp *http.Response) (*GetV2SyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestinationV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchV2SyncDestinationResponse parses an HTTP response from a PatchV2SyncDestinationWithResponse call
func ParsePatchV2SyncDestinationResponse(rsp *http.Response) (*PatchV2SyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2SyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateV2SyncIntegrationTestConnectionResponse parses an HTTP response from a CreateV2SyncIntegrationTestConnectionWithResponse call
func ParseCreateV2SyncIntegrationTestConnectionResponse(rsp *http.Response) (*CreateV2SyncIntegrationTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateV2SyncIntegrationTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncIntegrationTestConnectionV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListV2SyncIntegrationsResponse parses an HTTP response from a ListV2SyncIntegrationsWithResponse call
func ParseListV2SyncIntegrationsResponse(rsp *http.Response) (*ListV2SyncIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListV2SyncIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []SyncIntegrationExpandedV2 `json:"items"`
			Metadata ListMetadata                `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateV2SyncIntegrationResponse parses an HTTP response from a CreateV2SyncIntegrationWithResponse call
func ParseCreateV2SyncIntegrationResponse(rsp *http.Response) (*CreateV2SyncIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateV2SyncIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncIntegrationV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteV2SyncIntegrationResponse parses an HTTP response from a DeleteV2SyncIntegrationWithResponse call
func ParseDeleteV2SyncIntegrationResponse(rsp *http.Response) (*DeleteV2SyncIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2SyncIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2SyncIntegrationResponse parses an HTTP response from a GetV2SyncIntegrationWithResponse call
func ParseGetV2SyncIntegrationResponse(rsp *http.Response) (*GetV2SyncIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SyncIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncIntegrationExpandedV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateV2SyncIntegrationResponse parses an HTTP response from a UpdateV2SyncIntegrationWithResponse call
func ParseUpdateV2SyncIntegrationResponse(rsp *http.Response) (*UpdateV2SyncIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateV2SyncIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncIntegrationV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
